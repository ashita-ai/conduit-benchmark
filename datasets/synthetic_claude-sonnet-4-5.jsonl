{"query_id": "synthetic-001", "query_text": "Write a Python function named `merge_sorted_lists` that takes two sorted lists and merges them into a single sorted list. Language: Python. Function name: merge_sorted_lists", "reference_answer": "def merge_sorted_lists(list1: list, list2: list) -> list:\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result", "assertions": "assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3]\nassert merge_sorted_lists([1], [2]) == [1, 2]\nassert merge_sorted_lists([1, 1], [1, 1]) == [1, 1, 1, 1]", "metadata": {"language": "Python", "function_name": "merge_sorted_lists", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-002", "query_text": "Write a Python function named `find_duplicates` that takes a list and returns all duplicate elements. Language: Python. Function name: find_duplicates", "reference_answer": "def find_duplicates(nums: list) -> list:\n    seen = set()\n    duplicates = set()\n    for num in nums:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    return sorted(list(duplicates))", "assertions": "assert find_duplicates([1, 2, 3, 2, 4, 1]) == [1, 2]\nassert find_duplicates([1, 1, 1, 1]) == [1]\nassert find_duplicates([1, 2, 3, 4, 5]) == []\nassert find_duplicates([]) == []\nassert find_duplicates([5, 5, 6, 6, 7]) == [5, 6]", "metadata": {"language": "Python", "function_name": "find_duplicates", "difficulty": "medium", "category": "data_structures", "complexity": 0.3}}
{"query_id": "synthetic-003", "query_text": "Write a Python function named `validate_parentheses` that checks if parentheses in a string are balanced. Language: Python. Function name: validate_parentheses", "reference_answer": "def validate_parentheses(s: str) -> bool:\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    for char in s:\n        if char in pairs:\n            stack.append(char)\n        elif char in pairs.values():\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    return len(stack) == 0", "assertions": "assert validate_parentheses(\"()\") == True\nassert validate_parentheses(\"()[]{}\") == True\nassert validate_parentheses(\"(]\") == False\nassert validate_parentheses(\"([)]\") == False\nassert validate_parentheses(\"{[]}\") == True\nassert validate_parentheses(\"\") == True\nassert validate_parentheses(\"(((\") == False", "metadata": {"language": "Python", "function_name": "validate_parentheses", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-004", "query_text": "Write a Python function named `fibonacci_memoized` that calculates the nth Fibonacci number using memoization. Language: Python. Function name: fibonacci_memoized", "reference_answer": "def fibonacci_memoized(n: int, memo: dict = None) -> int:\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_memoized(n-1, memo) + fibonacci_memoized(n-2, memo)\n    return memo[n]", "assertions": "assert fibonacci_memoized(0) == 0\nassert fibonacci_memoized(1) == 1\nassert fibonacci_memoized(5) == 5\nassert fibonacci_memoized(10) == 55\nassert fibonacci_memoized(15) == 610\nassert fibonacci_memoized(20) == 6765", "metadata": {"language": "Python", "function_name": "fibonacci_memoized", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-005", "query_text": "Write a TypeScript function named `reverseString` that reverses a string in place. Language: TypeScript. Function name: reverseString", "reference_answer": "function reverseString(s: string): string {\n    return s.split('').reverse().join('');\n}", "assertions": "if (reverseString('hello') !== 'olleh') throw new Error('Failed');\nif (reverseString('world') !== 'dlrow') throw new Error('Failed');\nif (reverseString('') !== '') throw new Error('Failed');\nif (reverseString('a') !== 'a') throw new Error('Failed');\nif (reverseString('12345') !== '54321') throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "reverseString", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-006", "query_text": "Write a TypeScript function named `findMax` that finds the maximum number in an array. Language: TypeScript. Function name: findMax", "reference_answer": "function findMax(nums: number[]): number | null {\n    if (nums.length === 0) return null;\n    return Math.max(...nums);\n}", "assertions": "if (findMax([1, 5, 3, 9, 2]) !== 9) throw new Error('Failed');\nif (findMax([10]) !== 10) throw new Error('Failed');\nif (findMax([]) !== null) throw new Error('Failed');\nif (findMax([-5, -2, -10]) !== -2) throw new Error('Failed');\nif (findMax([0, 0, 0]) !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "findMax", "difficulty": "medium", "category": "algorithms", "complexity": 0.25}}
{"query_id": "synthetic-007", "query_text": "Write a TypeScript function named `isPalindrome` that checks if a string is a palindrome. Language: TypeScript. Function name: isPalindrome", "reference_answer": "function isPalindrome(s: string): boolean {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return cleaned === cleaned.split('').reverse().join('');\n}", "assertions": "if (isPalindrome('racecar') !== true) throw new Error('Failed');\nif (isPalindrome('hello') !== false) throw new Error('Failed');\nif (isPalindrome('A man a plan a canal Panama') !== true) throw new Error('Failed');\nif (isPalindrome('') !== true) throw new Error('Failed');\nif (isPalindrome('Was it a car or a cat I saw') !== true) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "isPalindrome", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-008", "query_text": "Write a TypeScript function named `groupBy` that groups array elements by a key function. Language: TypeScript. Function name: groupBy", "reference_answer": "function groupBy<T>(arr: T[], keyFn: (item: T) => string): Record<string, T[]> {\n    return arr.reduce((groups, item) => {\n        const key = keyFn(item);\n        if (!groups[key]) groups[key] = [];\n        groups[key].push(item);\n        return groups;\n    }, {} as Record<string, T[]>);\n}", "assertions": "const result1 = groupBy([1, 2, 3, 4, 5, 6], n => n % 2 === 0 ? 'even' : 'odd');\nif (result1['even'].length !== 3 || result1['odd'].length !== 3) throw new Error('Failed');\nconst result2 = groupBy(['apple', 'banana', 'apricot', 'blueberry'], s => s[0]);\nif (result2['a'].length !== 2 || result2['b'].length !== 2) throw new Error('Failed');\nconst result3 = groupBy([], n => 'key');\nif (Object.keys(result3).length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "groupBy", "difficulty": "medium", "category": "data_structures", "complexity": 0.55}}
{"query_id": "synthetic-009", "query_text": "Write a Go function named `Sum` that calculates the sum of integers in a slice. Language: Go. Function name: Sum", "reference_answer": "package main\n\nfunc Sum(nums []int) int {\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total\n}", "assertions": "if Sum([]int{1, 2, 3, 4, 5}) != 15 { panic(\"Failed\") }\nif Sum([]int{}) != 0 { panic(\"Failed\") }\nif Sum([]int{-1, -2, -3}) != -6 { panic(\"Failed\") }\nif Sum([]int{100}) != 100 { panic(\"Failed\") }\nif Sum([]int{0, 0, 0}) != 0 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-010", "query_text": "Write a Go function named `Contains` that checks if a slice contains a value. Language: Go. Function name: Contains", "reference_answer": "package main\n\nfunc Contains(nums []int, target int) bool {\n\tfor _, num := range nums {\n\t\tif num == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "assertions": "if Contains([]int{1, 2, 3, 4, 5}, 3) != true { panic(\"Failed\") }\nif Contains([]int{1, 2, 3, 4, 5}, 6) != false { panic(\"Failed\") }\nif Contains([]int{}, 1) != false { panic(\"Failed\") }\nif Contains([]int{10}, 10) != true { panic(\"Failed\") }\nif Contains([]int{-1, -2, -3}, -2) != true { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Contains", "difficulty": "medium", "category": "algorithms", "complexity": 0.25}}
{"query_id": "synthetic-011", "query_text": "Write a Rust function named `sum_vec` that calculates the sum of integers in a vector. Language: Rust. Function name: sum_vec", "reference_answer": "pub fn sum_vec(nums: &[i32]) -> i32 {\n    nums.iter().sum()\n}", "assertions": "assert_eq!(sum_vec(&[1, 2, 3, 4, 5]), 15);\nassert_eq!(sum_vec(&[]), 0);\nassert_eq!(sum_vec(&[-1, -2, -3]), -6);\nassert_eq!(sum_vec(&[100]), 100);\nassert_eq!(sum_vec(&[0, 0, 0]), 0);", "metadata": {"language": "Rust", "function_name": "sum_vec", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-012", "query_text": "Write a Rust function named `contains` that checks if a vector contains a value. Language: Rust. Function name: contains", "reference_answer": "pub fn contains(nums: &[i32], target: i32) -> bool {\n    nums.iter().any(|&x| x == target)\n}", "assertions": "assert_eq!(contains(&[1, 2, 3, 4, 5], 3), true);\nassert_eq!(contains(&[1, 2, 3, 4, 5], 6), false);\nassert_eq!(contains(&[], 1), false);\nassert_eq!(contains(&[10], 10), true);\nassert_eq!(contains(&[-1, -2, -3], -2), true);", "metadata": {"language": "Rust", "function_name": "contains", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-013", "query_text": "Write a Java function named `factorial` that calculates the factorial of a number. Language: Java. Function name: factorial", "reference_answer": "public class Solution {\n    public static long factorial(int n) {\n        if (n <= 1) return 1;\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}", "assertions": "if (Solution.factorial(0) != 1) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(1) != 1) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(5) != 120) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(10) != 3628800) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(3) != 6) throw new RuntimeException(\"Failed\");", "metadata": {"language": "Java", "function_name": "factorial", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-014", "query_text": "Write a JavaScript function named `flattenArray` that flattens a nested array. Language: JavaScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr) {\n    return arr.flat(Infinity);\n}", "assertions": "const result1 = flattenArray([1, [2, [3, 4], 5], 6]);\nif (JSON.stringify(result1) !== JSON.stringify([1, 2, 3, 4, 5, 6])) throw new Error('Failed');\nconst result2 = flattenArray([1, 2, 3]);\nif (JSON.stringify(result2) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nconst result3 = flattenArray([]);\nif (JSON.stringify(result3) !== JSON.stringify([])) throw new Error('Failed');\nconst result4 = flattenArray([[[]]]);\nif (JSON.stringify(result4) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "JavaScript", "function_name": "flattenArray", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-015", "query_text": "Write a Python function named `binary_search` that performs binary search on a sorted list. Language: Python. Function name: binary_search", "reference_answer": "def binary_search(arr: list, target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "assertions": "assert binary_search([1, 2, 3, 4, 5], 3) == 2\nassert binary_search([1, 2, 3, 4, 5], 1) == 0\nassert binary_search([1, 2, 3, 4, 5], 5) == 4\nassert binary_search([1, 2, 3, 4, 5], 6) == -1\nassert binary_search([], 1) == -1\nassert binary_search([10], 10) == 0", "metadata": {"language": "Python", "function_name": "binary_search", "difficulty": "advanced", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-016", "query_text": "Write a Python function named `quicksort` that implements the quicksort algorithm. Language: Python. Function name: quicksort", "reference_answer": "def quicksort(arr: list) -> list:\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)", "assertions": "assert quicksort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\nassert quicksort([]) == []\nassert quicksort([1]) == [1]\nassert quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\nassert quicksort([1, 1, 1, 1]) == [1, 1, 1, 1]", "metadata": {"language": "Python", "function_name": "quicksort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-017", "query_text": "Write a Python function named `lcs` that finds the longest common subsequence of two strings. Language: Python. Function name: lcs", "reference_answer": "def lcs(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + s1[i-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n    \n    return dp[m][n]", "assertions": "assert lcs('ABCDGH', 'AEDFHR') == 'ADH'\nassert lcs('AGGTAB', 'GXTXAYB') == 'GTAB'\nassert lcs('', 'ABC') == ''\nassert lcs('ABC', '') == ''\nassert lcs('ABC', 'ABC') == 'ABC'", "metadata": {"language": "Python", "function_name": "lcs", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-018", "query_text": "Write a Python function named `build_trie` that builds a trie from a list of words. Language: Python. Function name: build_trie", "reference_answer": "def build_trie(words: list) -> dict:\n    root = {}\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    return root", "assertions": "trie = build_trie(['cat', 'car', 'dog'])\nassert 'c' in trie and 'a' in trie['c'] and 't' in trie['c']['a']\nassert 'd' in trie and 'o' in trie['d'] and 'g' in trie['d']['o']\nassert '$' in trie['c']['a']['t'] and '$' in trie['c']['a']['r']\ntrie2 = build_trie([])\nassert trie2 == {}\ntrie3 = build_trie(['a'])\nassert 'a' in trie3 and '$' in trie3['a']", "metadata": {"language": "Python", "function_name": "build_trie", "difficulty": "advanced", "category": "data_structures", "complexity": 0.7}}
{"query_id": "synthetic-019", "query_text": "Write a TypeScript function named `debounce` that creates a debounced version of a function. Language: TypeScript. Function name: debounce", "reference_answer": "function debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout | null = null;\n    return (...args: Parameters<T>) => {\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(() => func(...args), wait);\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst debouncedIncrement = debounce(increment, 100);\ndebouncedIncrement();\ndebouncedIncrement();\ndebouncedIncrement();\nsetTimeout(() => {\n    if (counter !== 1) throw new Error('Failed');\n}, 150);", "metadata": {"language": "TypeScript", "function_name": "debounce", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-020", "query_text": "Write a TypeScript function named `deepClone` that performs a deep clone of an object. Language: TypeScript. Function name: deepClone", "reference_answer": "function deepClone<T>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (obj instanceof Date) return new Date(obj.getTime()) as any;\n    if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n    const cloned: any = {};\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            cloned[key] = deepClone((obj as any)[key]);\n        }\n    }\n    return cloned;\n}", "assertions": "const original = { a: 1, b: { c: 2, d: [3, 4] } };\nconst cloned = deepClone(original);\nif (cloned.b.c !== 2 || cloned.b.d[0] !== 3) throw new Error('Failed');\ncloned.b.c = 99;\nif (original.b.c === 99) throw new Error('Failed - not deep cloned');\nconst arr = [1, [2, 3]];\nconst clonedArr = deepClone(arr);\nif (JSON.stringify(clonedArr) !== JSON.stringify([1, [2, 3]])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "deepClone", "difficulty": "advanced", "category": "data_structures", "complexity": 0.75}}
{"query_id": "synthetic-021", "query_text": "Write a Python function named `rotate_matrix` that rotates a 2D matrix 90 degrees clockwise. Language: Python. Function name: rotate_matrix", "reference_answer": "def rotate_matrix(matrix: list) -> list:\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - 1 - j][i]\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]\n            matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]\n            matrix[j][n - 1 - i] = temp\n    return matrix", "assertions": "assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\nassert rotate_matrix([[1]]) == [[1]]", "metadata": {"language": "Python", "function_name": "rotate_matrix", "difficulty": "medium", "category": "algorithms", "complexity": 0.55}}
{"query_id": "synthetic-022", "query_text": "Write a Python function named `two_sum` that finds two indices in an array that sum to a target. Language: Python. Function name: two_sum", "reference_answer": "def two_sum(nums: list, target: int) -> list:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []", "assertions": "assert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 2, 4], 6) == [1, 2]\nassert two_sum([3, 3], 6) == [0, 1]\nassert two_sum([1, 2, 3], 10) == []", "metadata": {"language": "Python", "function_name": "two_sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-023", "query_text": "Write a Python function named `is_anagram` that checks if two strings are anagrams. Language: Python. Function name: is_anagram", "reference_answer": "def is_anagram(s1: str, s2: str) -> bool:\n    if len(s1) != len(s2):\n        return False\n    counts = {}\n    for char in s1:\n        counts[char] = counts.get(char, 0) + 1\n    for char in s2:\n        if char not in counts:\n            return False\n        counts[char] -= 1\n        if counts[char] < 0:\n            return False\n    return all(count == 0 for count in counts.values())", "assertions": "assert is_anagram('listen', 'silent') == True\nassert is_anagram('hello', 'world') == False\nassert is_anagram('', '') == True\nassert is_anagram('a', 'a') == True\nassert is_anagram('rat', 'car') == False", "metadata": {"language": "Python", "function_name": "is_anagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-024", "query_text": "Write a Python function named `find_kth_largest` that finds the kth largest element in an array. Language: Python. Function name: find_kth_largest", "reference_answer": "def find_kth_largest(nums: list, k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k - 1]", "assertions": "assert find_kth_largest([3, 2, 1, 5, 6, 4], 2) == 5\nassert find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) == 4\nassert find_kth_largest([1], 1) == 1\nassert find_kth_largest([7, 6, 5, 4, 3, 2, 1], 1) == 7", "metadata": {"language": "Python", "function_name": "find_kth_largest", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-025", "query_text": "Write a Python function named `dijkstra` that implements Dijkstra's shortest path algorithm. Language: Python. Function name: dijkstra", "reference_answer": "import heapq\n\ndef dijkstra(graph: dict, start: str) -> dict:\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances", "assertions": "graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}}\nresult = dijkstra(graph, 'A')\nassert result['A'] == 0\nassert result['B'] == 1\nassert result['C'] == 3\nassert result['D'] == 4", "metadata": {"language": "Python", "function_name": "dijkstra", "difficulty": "advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-026", "query_text": "Write a Python function named `serialize_tree` that serializes a binary tree to a string. Language: Python. Function name: serialize_tree", "reference_answer": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef serialize_tree(root: TreeNode) -> str:\n    if not root:\n        return 'null'\n    return f'{root.val},{serialize_tree(root.left)},{serialize_tree(root.right)}'", "assertions": "node = TreeNode(1, TreeNode(2), TreeNode(3))\nassert serialize_tree(node) == '1,2,null,null,3,null,null'\nassert serialize_tree(None) == 'null'\nassert serialize_tree(TreeNode(5)) == '5,null,null'", "metadata": {"language": "Python", "function_name": "serialize_tree", "difficulty": "advanced", "category": "data_structures", "complexity": 0.75}}
{"query_id": "synthetic-027", "query_text": "Write a Python function named `coin_change` that finds minimum coins needed for a target amount. Language: Python. Function name: coin_change", "reference_answer": "def coin_change(coins: list, amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1", "assertions": "assert coin_change([1, 2, 5], 11) == 3\nassert coin_change([2], 3) == -1\nassert coin_change([1], 0) == 0\nassert coin_change([1, 2, 5], 100) == 20", "metadata": {"language": "Python", "function_name": "coin_change", "difficulty": "advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-028", "query_text": "Write a Python function named `word_break` that checks if a string can be segmented into dictionary words. Language: Python. Function name: word_break", "reference_answer": "def word_break(s: str, word_dict: set) -> bool:\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    \n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_dict:\n                dp[i] = True\n                break\n    \n    return dp[len(s)]", "assertions": "assert word_break('leetcode', {'leet', 'code'}) == True\nassert word_break('applepenapple', {'apple', 'pen'}) == True\nassert word_break('catsandog', {'cats', 'dog', 'sand', 'and', 'cat'}) == False\nassert word_break('', set()) == True", "metadata": {"language": "Python", "function_name": "word_break", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-029", "query_text": "Write a Python function named `topological_sort` that performs topological sort on a DAG. Language: Python. Function name: topological_sort", "reference_answer": "from collections import deque\n\ndef topological_sort(graph: dict) -> list:\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] = in_degree.get(neighbor, 0) + 1\n    \n    queue = deque([node for node in graph if in_degree[node] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == len(graph) else []", "assertions": "graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}\nresult = topological_sort(graph)\nassert result[0] == 'A'\nassert result[-1] == 'D'\nassert set(result) == {'A', 'B', 'C', 'D'}", "metadata": {"language": "Python", "function_name": "topological_sort", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-030", "query_text": "Write a Python function named `lru_cache_impl` that implements an LRU cache. Language: Python. Function name: LRUCache", "reference_answer": "class LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.order = []\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.order.remove(key)\n        self.order.append(key)\n        return self.cache[key]\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.order.remove(key)\n        elif len(self.cache) >= self.capacity:\n            lru = self.order.pop(0)\n            del self.cache[lru]\n        self.cache[key] = value\n        self.order.append(key)", "assertions": "cache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4", "metadata": {"language": "Python", "function_name": "LRUCache", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.85}}
{"query_id": "synthetic-031", "query_text": "Write a TypeScript function named `uniqueArray` that removes duplicates from an array. Language: TypeScript. Function name: uniqueArray", "reference_answer": "function uniqueArray<T>(arr: T[]): T[] {\n    return Array.from(new Set(arr));\n}", "assertions": "if (JSON.stringify(uniqueArray([1, 2, 2, 3, 3, 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(uniqueArray([])) !== JSON.stringify([])) throw new Error('Failed');\nif (JSON.stringify(uniqueArray(['a', 'b', 'a'])) !== JSON.stringify(['a', 'b'])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "uniqueArray", "difficulty": "medium", "category": "data_structures", "complexity": 0.3}}
{"query_id": "synthetic-032", "query_text": "Write a TypeScript function named `chunkArray` that splits an array into chunks of a given size. Language: TypeScript. Function name: chunkArray", "reference_answer": "function chunkArray<T>(arr: T[], size: number): T[][] {\n    const result: T[][] = [];\n    for (let i = 0; i < arr.length; i += size) {\n        result.push(arr.slice(i, i + size));\n    }\n    return result;\n}", "assertions": "if (JSON.stringify(chunkArray([1, 2, 3, 4, 5], 2)) !== JSON.stringify([[1, 2], [3, 4], [5]])) throw new Error('Failed');\nif (JSON.stringify(chunkArray([1, 2, 3], 1)) !== JSON.stringify([[1], [2], [3]])) throw new Error('Failed');\nif (JSON.stringify(chunkArray([], 2)) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "chunkArray", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-033", "query_text": "Write a TypeScript function named `capitalize` that capitalizes the first letter of each word. Language: TypeScript. Function name: capitalize", "reference_answer": "function capitalize(str: string): string {\n    return str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n}", "assertions": "if (capitalize('hello world') !== 'Hello World') throw new Error('Failed');\nif (capitalize('typescript') !== 'Typescript') throw new Error('Failed');\nif (capitalize('') !== '') throw new Error('Failed');\nif (capitalize('a b c') !== 'A B C') throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "capitalize", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-034", "query_text": "Write a TypeScript function named `intersection` that finds common elements in two arrays. Language: TypeScript. Function name: intersection", "reference_answer": "function intersection<T>(arr1: T[], arr2: T[]): T[] {\n    const set2 = new Set(arr2);\n    return Array.from(new Set(arr1.filter(item => set2.has(item))));\n}", "assertions": "if (JSON.stringify(intersection([1, 2, 3], [2, 3, 4]).sort()) !== JSON.stringify([2, 3])) throw new Error('Failed');\nif (JSON.stringify(intersection([1, 2], [3, 4])) !== JSON.stringify([])) throw new Error('Failed');\nif (JSON.stringify(intersection([], [1, 2])) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "intersection", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-035", "query_text": "Write a TypeScript function named `memoize` that creates a memoized version of a function. Language: TypeScript. Function name: memoize", "reference_answer": "function memoize<T extends (...args: any[]) => any>(fn: T): T {\n    const cache = new Map<string, ReturnType<T>>();\n    return ((...args: Parameters<T>) => {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) return cache.get(key)!;\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    }) as T;\n}", "assertions": "let callCount = 0;\nconst expensiveFn = (n: number) => { callCount++; return n * 2; };\nconst memoized = memoize(expensiveFn);\nif (memoized(5) !== 10 || callCount !== 1) throw new Error('Failed');\nif (memoized(5) !== 10 || callCount !== 1) throw new Error('Failed - should use cache');\nif (memoized(10) !== 20 || callCount !== 2) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "memoize", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-036", "query_text": "Write a TypeScript function named `promiseAll` that implements Promise.all functionality. Language: TypeScript. Function name: promiseAll", "reference_answer": "function promiseAll<T>(promises: Promise<T>[]): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n        if (promises.length === 0) return resolve([]);\n        const results: T[] = [];\n        let completed = 0;\n        promises.forEach((promise, index) => {\n            promise.then(value => {\n                results[index] = value;\n                completed++;\n                if (completed === promises.length) resolve(results);\n            }).catch(reject);\n        });\n    });\n}", "assertions": "promiseAll([Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)]).then(results => {\n    if (JSON.stringify(results) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\n});\npromiseAll([]).then(results => {\n    if (JSON.stringify(results) !== JSON.stringify([])) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "promiseAll", "difficulty": "advanced", "category": "concurrency", "complexity": 0.75}}
{"query_id": "synthetic-037", "query_text": "Write a TypeScript function named `throttle` that creates a throttled version of a function. Language: TypeScript. Function name: throttle", "reference_answer": "function throttle<T extends (...args: any[]) => void>(func: T, limit: number): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n        if (!inThrottle) {\n            func(...args);\n            inThrottle = true;\n            setTimeout(() => inThrottle = false, limit);\n        }\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst throttled = throttle(increment, 100);\nthrottled();\nthrottled();\nthrottled();\nif (counter !== 1) throw new Error('Failed - should only call once');", "metadata": {"language": "TypeScript", "function_name": "throttle", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-038", "query_text": "Write a TypeScript function named `curry` that curries a function. Language: TypeScript. Function name: curry", "reference_answer": "function curry<T extends any[], R>(fn: (...args: T) => R): any {\n    return function curried(...args: any[]): any {\n        if (args.length >= fn.length) {\n            return fn(...args as T);\n        }\n        return (...nextArgs: any[]) => curried(...args, ...nextArgs);\n    };\n}", "assertions": "const add = (a: number, b: number, c: number) => a + b + c;\nconst curriedAdd = curry(add);\nif (curriedAdd(1)(2)(3) !== 6) throw new Error('Failed');\nif (curriedAdd(1, 2)(3) !== 6) throw new Error('Failed');\nif (curriedAdd(1)(2, 3) !== 6) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "curry", "difficulty": "advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-039", "query_text": "Write a TypeScript function named `eventEmitter` that implements a type-safe event emitter. Language: TypeScript. Function name: EventEmitter", "reference_answer": "class EventEmitter<T extends Record<string, any[]>> {\n    private listeners: { [K in keyof T]?: Array<(...args: T[K]) => void> } = {};\n    \n    on<K extends keyof T>(event: K, callback: (...args: T[K]) => void): void {\n        if (!this.listeners[event]) this.listeners[event] = [];\n        this.listeners[event]!.push(callback);\n    }\n    \n    emit<K extends keyof T>(event: K, ...args: T[K]): void {\n        this.listeners[event]?.forEach(callback => callback(...args));\n    }\n    \n    off<K extends keyof T>(event: K, callback: (...args: T[K]) => void): void {\n        const callbacks = this.listeners[event];\n        if (callbacks) {\n            this.listeners[event] = callbacks.filter(cb => cb !== callback) as any;\n        }\n    }\n}", "assertions": "type Events = { message: [string]; count: [number] };\nconst emitter = new EventEmitter<Events>();\nlet received = '';\nemitter.on('message', (msg) => { received = msg; });\nemitter.emit('message', 'hello');\nif (received !== 'hello') throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "EventEmitter", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.85}}
{"query_id": "synthetic-040", "query_text": "Write a TypeScript function named `retryWithBackoff` that retries a promise with exponential backoff. Language: TypeScript. Function name: retryWithBackoff", "reference_answer": "async function retryWithBackoff<T>(fn: () => Promise<T>, maxRetries: number = 3, baseDelay: number = 1000): Promise<T> {\n    for (let i = 0; i < maxRetries; i++) {\n        try {\n            return await fn();\n        } catch (error) {\n            if (i === maxRetries - 1) throw error;\n            const delay = baseDelay * Math.pow(2, i);\n            await new Promise(resolve => setTimeout(resolve, delay));\n        }\n    }\n    throw new Error('Max retries exceeded');\n}", "assertions": "let attempts = 0;\nconst unstableFn = () => { attempts++; if (attempts < 3) return Promise.reject('fail'); return Promise.resolve('success'); };\nretryWithBackoff(unstableFn, 5, 10).then(result => {\n    if (result !== 'success' || attempts !== 3) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "retryWithBackoff", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.9}}
{"query_id": "synthetic-041", "query_text": "Write a Python function named `remove_nth_node` that removes the nth node from the end of a linked list. Language: Python. Function name: remove_nth_node", "reference_answer": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_nth_node(head: ListNode, n: int) -> ListNode:\n    dummy = ListNode(0)\n    dummy.next = head\n    fast = slow = dummy\n    for _ in range(n + 1):\n        fast = fast.next\n    while fast:\n        fast = fast.next\n        slow = slow.next\n    slow.next = slow.next.next\n    return dummy.next", "assertions": "node = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nresult = remove_nth_node(node, 2)\nvals = []\nwhile result:\n    vals.append(result.val)\n    result = result.next\nassert vals == [1, 2, 3, 5]", "metadata": {"language": "Python", "function_name": "remove_nth_node", "difficulty": "medium", "category": "data_structures", "complexity": 0.6}}
{"query_id": "synthetic-042", "query_text": "Write a Python function named `max_subarray_sum` that finds the maximum sum of a contiguous subarray. Language: Python. Function name: max_subarray_sum", "reference_answer": "def max_subarray_sum(nums: list) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "assertions": "assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert max_subarray_sum([1]) == 1\nassert max_subarray_sum([5, 4, -1, 7, 8]) == 23\nassert max_subarray_sum([-1]) == -1", "metadata": {"language": "Python", "function_name": "max_subarray_sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.55}}
{"query_id": "synthetic-043", "query_text": "Write a Python function named `longest_substring_no_repeat` that finds the length of the longest substring without repeating characters. Language: Python. Function name: longest_substring_no_repeat", "reference_answer": "def longest_substring_no_repeat(s: str) -> int:\n    char_map = {}\n    left = max_length = 0\n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] >= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length", "assertions": "assert longest_substring_no_repeat('abcabcbb') == 3\nassert longest_substring_no_repeat('bbbbb') == 1\nassert longest_substring_no_repeat('pwwkew') == 3\nassert longest_substring_no_repeat('') == 0\nassert longest_substring_no_repeat('abcdef') == 6", "metadata": {"language": "Python", "function_name": "longest_substring_no_repeat", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-044", "query_text": "Write a Python function named `zigzag_conversion` that converts a string to zigzag pattern. Language: Python. Function name: zigzag_conversion", "reference_answer": "def zigzag_conversion(s: str, num_rows: int) -> str:\n    if num_rows == 1 or num_rows >= len(s):\n        return s\n    rows = [''] * num_rows\n    idx, step = 0, 1\n    for char in s:\n        rows[idx] += char\n        if idx == 0:\n            step = 1\n        elif idx == num_rows - 1:\n            step = -1\n        idx += step\n    return ''.join(rows)", "assertions": "assert zigzag_conversion('PAYPALISHIRING', 3) == 'PAHNAPLSIIGYIR'\nassert zigzag_conversion('PAYPALISHIRING', 4) == 'PINALSIGYAHRPI'\nassert zigzag_conversion('A', 1) == 'A'\nassert zigzag_conversion('AB', 1) == 'AB'", "metadata": {"language": "Python", "function_name": "zigzag_conversion", "difficulty": "medium", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-045", "query_text": "Write a Python function named `product_except_self` that returns an array where each element is the product of all others. Language: Python. Function name: product_except_self", "reference_answer": "def product_except_self(nums: list) -> list:\n    n = len(nums)\n    result = [1] * n\n    left = 1\n    for i in range(n):\n        result[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= right\n        right *= nums[i]\n    return result", "assertions": "assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6]\nassert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24]\nassert product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1]", "metadata": {"language": "Python", "function_name": "product_except_self", "difficulty": "medium", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-046", "query_text": "Write a Python function named `kmp_search` that implements the KMP string matching algorithm. Language: Python. Function name: kmp_search", "reference_answer": "def kmp_search(text: str, pattern: str) -> int:\n    def compute_lps(pattern):\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n    \n    lps = compute_lps(pattern)\n    i = j = 0\n    while i < len(text):\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n        if j == len(pattern):\n            return i - j\n        elif i < len(text) and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return -1", "assertions": "assert kmp_search('ababcabcabababd', 'ababd') == 10\nassert kmp_search('hello world', 'world') == 6\nassert kmp_search('abc', 'def') == -1\nassert kmp_search('aaaa', 'aa') == 0", "metadata": {"language": "Python", "function_name": "kmp_search", "difficulty": "advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-047", "query_text": "Write a Python function named `edit_distance` that calculates the minimum edit distance between two strings. Language: Python. Function name: edit_distance", "reference_answer": "def edit_distance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]", "assertions": "assert edit_distance('horse', 'ros') == 3\nassert edit_distance('intention', 'execution') == 5\nassert edit_distance('', '') == 0\nassert edit_distance('abc', 'abc') == 0\nassert edit_distance('abc', 'def') == 3", "metadata": {"language": "Python", "function_name": "edit_distance", "difficulty": "advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-048", "query_text": "Write a Python function named `max_sliding_window` that finds the maximum in each sliding window of size k. Language: Python. Function name: max_sliding_window", "reference_answer": "from collections import deque\n\ndef max_sliding_window(nums: list, k: int) -> list:\n    dq = deque()\n    result = []\n    for i, num in enumerate(nums):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        dq.append(i)\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    return result", "assertions": "assert max_sliding_window([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7]\nassert max_sliding_window([1], 1) == [1]\nassert max_sliding_window([1, -1], 1) == [1, -1]\nassert max_sliding_window([9, 11], 2) == [11]\nassert max_sliding_window([4, -2], 2) == [4]", "metadata": {"language": "Python", "function_name": "max_sliding_window", "difficulty": "advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-049", "query_text": "Write a Python function named `merge_intervals` that merges overlapping intervals. Language: Python. Function name: merge_intervals", "reference_answer": "def merge_intervals(intervals: list) -> list:\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            last[1] = max(last[1], current[1])\n        else:\n            merged.append(current)\n    return merged", "assertions": "assert merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) == [[1, 6], [8, 10], [15, 18]]\nassert merge_intervals([[1, 4], [4, 5]]) == [[1, 5]]\nassert merge_intervals([[1, 4]]) == [[1, 4]]\nassert merge_intervals([]) == []", "metadata": {"language": "Python", "function_name": "merge_intervals", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-050", "query_text": "Write a Python function named `trap_rain_water` that calculates how much rain water can be trapped. Language: Python. Function name: trap_rain_water", "reference_answer": "def trap_rain_water(height: list) -> int:\n    if not height:\n        return 0\n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water = 0\n    \n    while left < right:\n        if left_max < right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water += right_max - height[right]\n    \n    return water", "assertions": "assert trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6\nassert trap_rain_water([4, 2, 0, 3, 2, 5]) == 9\nassert trap_rain_water([]) == 0\nassert trap_rain_water([3, 0, 2, 0, 4]) == 7", "metadata": {"language": "Python", "function_name": "trap_rain_water", "difficulty": "advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-051", "query_text": "Write a TypeScript function named `range` that generates a range of numbers. Language: TypeScript. Function name: range", "reference_answer": "function range(start: number, end: number, step: number = 1): number[] {\n    const result: number[] = [];\n    for (let i = start; i < end; i += step) {\n        result.push(i);\n    }\n    return result;\n}", "assertions": "if (JSON.stringify(range(0, 5)) !== JSON.stringify([0, 1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(range(0, 10, 2)) !== JSON.stringify([0, 2, 4, 6, 8])) throw new Error('Failed');\nif (JSON.stringify(range(5, 5)) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "range", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-052", "query_text": "Write a TypeScript function named `partition` that partitions an array into two groups based on a predicate. Language: TypeScript. Function name: partition", "reference_answer": "function partition<T>(arr: T[], predicate: (item: T) => boolean): [T[], T[]] {\n    return arr.reduce(([pass, fail], item) => {\n        return predicate(item) ? [[...pass, item], fail] : [pass, [...fail, item]];\n    }, [[], []] as [T[], T[]]);\n}", "assertions": "const [evens, odds] = partition([1, 2, 3, 4, 5, 6], n => n % 2 === 0);\nif (JSON.stringify(evens) !== JSON.stringify([2, 4, 6])) throw new Error('Failed');\nif (JSON.stringify(odds) !== JSON.stringify([1, 3, 5])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "partition", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-053", "query_text": "Write a TypeScript function named `zip` that zips two arrays together. Language: TypeScript. Function name: zip", "reference_answer": "function zip<T, U>(arr1: T[], arr2: U[]): [T, U][] {\n    const length = Math.min(arr1.length, arr2.length);\n    return Array.from({ length }, (_, i) => [arr1[i], arr2[i]]);\n}", "assertions": "const result = zip([1, 2, 3], ['a', 'b', 'c']);\nif (JSON.stringify(result) !== JSON.stringify([[1, 'a'], [2, 'b'], [3, 'c']])) throw new Error('Failed');\nconst result2 = zip([1, 2], ['a']);\nif (JSON.stringify(result2) !== JSON.stringify([[1, 'a']])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "zip", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-054", "query_text": "Write a TypeScript function named `pick` that picks specified properties from an object. Language: TypeScript. Function name: pick", "reference_answer": "function pick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n    return keys.reduce((result, key) => {\n        if (key in obj) result[key] = obj[key];\n        return result;\n    }, {} as Pick<T, K>);\n}", "assertions": "const obj = { a: 1, b: 2, c: 3, d: 4 };\nconst result = pick(obj, ['a', 'c']);\nif (JSON.stringify(result) !== JSON.stringify({ a: 1, c: 3 })) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "pick", "difficulty": "medium", "category": "data_structures", "complexity": 0.55}}
{"query_id": "synthetic-055", "query_text": "Write a TypeScript function named `asyncMap` that maps an array with an async function. Language: TypeScript. Function name: asyncMap", "reference_answer": "async function asyncMap<T, U>(arr: T[], fn: (item: T, index: number) => Promise<U>): Promise<U[]> {\n    return Promise.all(arr.map(fn));\n}", "assertions": "const double = async (n: number) => n * 2;\nasyncMap([1, 2, 3], double).then(result => {\n    if (JSON.stringify(result) !== JSON.stringify([2, 4, 6])) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "asyncMap", "difficulty": "advanced", "category": "concurrency", "complexity": 0.65}}
{"query_id": "synthetic-056", "query_text": "Write a TypeScript function named `pipeAsync` that composes async functions left-to-right. Language: TypeScript. Function name: pipeAsync", "reference_answer": "function pipeAsync<T>(...fns: Array<(arg: any) => Promise<any>>): (input: T) => Promise<any> {\n    return async (input: T) => {\n        let result: any = input;\n        for (const fn of fns) {\n            result = await fn(result);\n        }\n        return result;\n    };\n}", "assertions": "const addOne = async (n: number) => n + 1;\nconst double = async (n: number) => n * 2;\nconst pipeline = pipeAsync(addOne, double);\npipeline(5).then(result => {\n    if (result !== 12) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "pipeAsync", "difficulty": "advanced", "category": "concurrency", "complexity": 0.75}}
{"query_id": "synthetic-057", "query_text": "Write a TypeScript function named `batchPromises` that executes promises in batches. Language: TypeScript. Function name: batchPromises", "reference_answer": "async function batchPromises<T>(promises: (() => Promise<T>)[], batchSize: number): Promise<T[]> {\n    const results: T[] = [];\n    for (let i = 0; i < promises.length; i += batchSize) {\n        const batch = promises.slice(i, i + batchSize).map(fn => fn());\n        const batchResults = await Promise.all(batch);\n        results.push(...batchResults);\n    }\n    return results;\n}", "assertions": "const createPromise = (n: number) => () => Promise.resolve(n * 2);\nconst promises = [1, 2, 3, 4, 5].map(createPromise);\nbatchPromises(promises, 2).then(results => {\n    if (JSON.stringify(results) !== JSON.stringify([2, 4, 6, 8, 10])) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "batchPromises", "difficulty": "advanced", "category": "concurrency", "complexity": 0.8}}
{"query_id": "synthetic-058", "query_text": "Write a TypeScript function named `rateLimiter` that creates a rate-limited version of a function. Language: TypeScript. Function name: rateLimiter", "reference_answer": "function rateLimiter<T extends (...args: any[]) => Promise<any>>(fn: T, maxCalls: number, interval: number): T {\n    const calls: number[] = [];\n    return (async (...args: Parameters<T>) => {\n        const now = Date.now();\n        const validCalls = calls.filter(time => now - time < interval);\n        if (validCalls.length >= maxCalls) {\n            throw new Error('Rate limit exceeded');\n        }\n        calls.push(now);\n        return fn(...args);\n    }) as T;\n}", "assertions": "const fn = async (n: number) => n * 2;\nconst limited = rateLimiter(fn, 2, 1000);\nlimited(1).then(result => {\n    if (result !== 2) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "rateLimiter", "difficulty": "advanced", "category": "concurrency", "complexity": 0.85}}
{"query_id": "synthetic-059", "query_text": "Write a Go function named `BinarySearch` that performs binary search on a sorted slice. Language: Go. Function name: BinarySearch", "reference_answer": "package main\n\nfunc BinarySearch(nums []int, target int) int {\n\tleft, right := 0, len(nums)-1\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t} else if nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn -1\n}", "assertions": "if BinarySearch([]int{1, 2, 3, 4, 5}, 3) != 2 { panic(\"Failed\") }\nif BinarySearch([]int{1, 2, 3, 4, 5}, 6) != -1 { panic(\"Failed\") }\nif BinarySearch([]int{}, 1) != -1 { panic(\"Failed\") }\nif BinarySearch([]int{10}, 10) != 0 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "BinarySearch", "difficulty": "advanced", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-060", "query_text": "Write a Go function named `MergeSort` that implements merge sort. Language: Go. Function name: MergeSort", "reference_answer": "package main\n\nfunc MergeSort(nums []int) []int {\n\tif len(nums) <= 1 {\n\t\treturn nums\n\t}\n\tmid := len(nums) / 2\n\tleft := MergeSort(nums[:mid])\n\tright := MergeSort(nums[mid:])\n\treturn merge(left, right)\n}\n\nfunc merge(left, right []int) []int {\n\tresult := make([]int, 0, len(left)+len(right))\n\ti, j := 0, 0\n\tfor i < len(left) && j < len(right) {\n\t\tif left[i] <= right[j] {\n\t\t\tresult = append(result, left[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, right[j])\n\t\t\tj++\n\t\t}\n\t}\n\tresult = append(result, left[i:]...)\n\tresult = append(result, right[j:]...)\n\treturn result\n}", "assertions": "sorted := MergeSort([]int{3, 1, 4, 1, 5, 9, 2, 6})\nexpected := []int{1, 1, 2, 3, 4, 5, 6, 9}\nfor i := range sorted {\n\tif sorted[i] != expected[i] { panic(\"Failed\") }\n}", "metadata": {"language": "Go", "function_name": "MergeSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-061", "query_text": "Write a Python function named `a_star_search` that implements the A* pathfinding algorithm. Language: Python. Function name: a_star_search", "reference_answer": "import heapq\n\ndef a_star_search(graph: dict, start: str, goal: str, heuristic: dict) -> list:\n    open_set = [(0, start, [start])]\n    visited = set()\n    \n    while open_set:\n        f_score, current, path = heapq.heappop(open_set)\n        \n        if current == goal:\n            return path\n        \n        if current in visited:\n            continue\n        visited.add(current)\n        \n        for neighbor, cost in graph.get(current, {}).items():\n            if neighbor not in visited:\n                g_score = len(path)\n                h_score = heuristic.get(neighbor, 0)\n                f_score = g_score + h_score\n                new_path = path + [neighbor]\n                heapq.heappush(open_set, (f_score, neighbor, new_path))\n    \n    return []", "assertions": "graph = {'A': {'B': 1, 'C': 3}, 'B': {'D': 1}, 'C': {'D': 1}, 'D': {}}\nheuristic = {'A': 2, 'B': 1, 'C': 1, 'D': 0}\npath = a_star_search(graph, 'A', 'D', heuristic)\nassert 'A' in path and 'D' in path\nassert len(path) >= 3", "metadata": {"language": "Python", "function_name": "a_star_search", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-062", "query_text": "Write a Python function named `suffix_array` that builds a suffix array for string matching. Language: Python. Function name: suffix_array", "reference_answer": "def suffix_array(s: str) -> list:\n    suffixes = [(s[i:], i) for i in range(len(s))]\n    suffixes.sort()\n    return [i for _, i in suffixes]", "assertions": "assert suffix_array('banana') == [5, 3, 1, 0, 4, 2]\nassert suffix_array('a') == [0]\nassert suffix_array('aa') == [1, 0]\nassert suffix_array('abc') == [0, 1, 2]", "metadata": {"language": "Python", "function_name": "suffix_array", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-063", "query_text": "Write a Python function named `tarjan_scc` that finds strongly connected components using Tarjan's algorithm. Language: Python. Function name: tarjan_scc", "reference_answer": "def tarjan_scc(graph: dict) -> list:\n    index_counter = [0]\n    stack = []\n    lowlinks = {}\n    index = {}\n    on_stack = set()\n    sccs = []\n    \n    def strongconnect(node):\n        index[node] = index_counter[0]\n        lowlinks[node] = index_counter[0]\n        index_counter[0] += 1\n        stack.append(node)\n        on_stack.add(node)\n        \n        for neighbor in graph.get(node, []):\n            if neighbor not in index:\n                strongconnect(neighbor)\n                lowlinks[node] = min(lowlinks[node], lowlinks[neighbor])\n            elif neighbor in on_stack:\n                lowlinks[node] = min(lowlinks[node], index[neighbor])\n        \n        if lowlinks[node] == index[node]:\n            scc = []\n            while True:\n                w = stack.pop()\n                on_stack.remove(w)\n                scc.append(w)\n                if w == node:\n                    break\n            sccs.append(scc)\n    \n    for node in graph:\n        if node not in index:\n            strongconnect(node)\n    \n    return sccs", "assertions": "graph = {'A': ['B'], 'B': ['C'], 'C': ['A'], 'D': ['E'], 'E': ['D']}\nsccs = tarjan_scc(graph)\nassert len(sccs) == 2\nassert any('A' in scc and 'B' in scc and 'C' in scc for scc in sccs)", "metadata": {"language": "Python", "function_name": "tarjan_scc", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-064", "query_text": "Write a Python function named `segment_tree` that implements a segment tree for range queries. Language: Python. Function name: SegmentTree", "reference_answer": "class SegmentTree:\n    def __init__(self, arr: list):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        if arr:\n            self._build(arr, 0, 0, self.n - 1)\n    \n    def _build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self._build(arr, 2 * node + 1, start, mid)\n            self._build(arr, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n    \n    def query(self, left, right):\n        return self._query(0, 0, self.n - 1, left, right)\n    \n    def _query(self, node, start, end, left, right):\n        if right < start or end < left:\n            return 0\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self._query(2 * node + 1, start, mid, left, right) + self._query(2 * node + 2, mid + 1, end, left, right)", "assertions": "st = SegmentTree([1, 2, 3, 4, 5])\nassert st.query(0, 2) == 6\nassert st.query(1, 3) == 9\nassert st.query(0, 4) == 15", "metadata": {"language": "Python", "function_name": "SegmentTree", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.9}}
{"query_id": "synthetic-065", "query_text": "Write a Python function named `rabin_karp` that implements the Rabin-Karp string matching algorithm. Language: Python. Function name: rabin_karp", "reference_answer": "def rabin_karp(text: str, pattern: str) -> int:\n    d = 256\n    q = 101\n    m = len(pattern)\n    n = len(text)\n    p = t = 0\n    h = pow(d, m - 1, q)\n    \n    for i in range(m):\n        p = (d * p + ord(pattern[i])) % q\n        t = (d * t + ord(text[i])) % q\n    \n    for i in range(n - m + 1):\n        if p == t:\n            if text[i:i + m] == pattern:\n                return i\n        if i < n - m:\n            t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q\n            if t < 0:\n                t += q\n    \n    return -1", "assertions": "assert rabin_karp('hello world', 'world') == 6\nassert rabin_karp('ababcabcabababd', 'ababd') == 10\nassert rabin_karp('abc', 'def') == -1\nassert rabin_karp('aaaa', 'aa') == 0", "metadata": {"language": "Python", "function_name": "rabin_karp", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-066", "query_text": "Write a Python function named `bellman_ford` that implements the Bellman-Ford shortest path algorithm. Language: Python. Function name: bellman_ford", "reference_answer": "def bellman_ford(graph: dict, start: str) -> dict:\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbor, weight in graph[node].items():\n                if distances[node] + weight < distances[neighbor]:\n                    distances[neighbor] = distances[node] + weight\n    \n    for node in graph:\n        for neighbor, weight in graph[node].items():\n            if distances[node] + weight < distances[neighbor]:\n                raise ValueError('Negative cycle detected')\n    \n    return distances", "assertions": "graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': -2, 'D': 5}, 'C': {'D': 1}, 'D': {}}\nresult = bellman_ford(graph, 'A')\nassert result['A'] == 0\nassert result['B'] == 1\nassert result['C'] == -1\nassert result['D'] == 0", "metadata": {"language": "Python", "function_name": "bellman_ford", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-067", "query_text": "Write a Python function named `floyd_warshall` that finds all-pairs shortest paths. Language: Python. Function name: floyd_warshall", "reference_answer": "def floyd_warshall(graph: dict) -> dict:\n    nodes = list(graph.keys())\n    dist = {i: {j: float('infinity') for j in nodes} for i in nodes}\n    \n    for node in nodes:\n        dist[node][node] = 0\n    \n    for node in graph:\n        for neighbor, weight in graph[node].items():\n            dist[node][neighbor] = weight\n    \n    for k in nodes:\n        for i in nodes:\n            for j in nodes:\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n    \n    return dist", "assertions": "graph = {'A': {'B': 3, 'C': 8}, 'B': {'D': 1}, 'C': {'B': 4}, 'D': {'C': 2, 'A': 7}}\nresult = floyd_warshall(graph)\nassert result['A']['D'] == 4\nassert result['A']['C'] == 7\nassert result['D']['A'] == 7", "metadata": {"language": "Python", "function_name": "floyd_warshall", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-068", "query_text": "Write a Python function named `max_flow` that implements the Ford-Fulkerson maximum flow algorithm. Language: Python. Function name: max_flow", "reference_answer": "from collections import defaultdict\n\ndef max_flow(graph: dict, source: str, sink: str) -> int:\n    residual_graph = defaultdict(lambda: defaultdict(int))\n    for u in graph:\n        for v, capacity in graph[u].items():\n            residual_graph[u][v] = capacity\n    \n    def dfs(node, target, visited, min_capacity):\n        if node == target:\n            return min_capacity\n        visited.add(node)\n        for neighbor in residual_graph[node]:\n            if neighbor not in visited and residual_graph[node][neighbor] > 0:\n                flow = dfs(neighbor, target, visited, min(min_capacity, residual_graph[node][neighbor]))\n                if flow > 0:\n                    residual_graph[node][neighbor] -= flow\n                    residual_graph[neighbor][node] += flow\n                    return flow\n        return 0\n    \n    total_flow = 0\n    while True:\n        visited = set()\n        flow = dfs(source, sink, visited, float('inf'))\n        if flow == 0:\n            break\n        total_flow += flow\n    \n    return total_flow", "assertions": "graph = {'S': {'A': 10, 'B': 5}, 'A': {'B': 15, 'T': 10}, 'B': {'T': 10}, 'T': {}}\nresult = max_flow(graph, 'S', 'T')\nassert result == 15", "metadata": {"language": "Python", "function_name": "max_flow", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-069", "query_text": "Write a Python function named `convex_hull` that finds the convex hull of points using Graham scan. Language: Python. Function name: convex_hull", "reference_answer": "def convex_hull(points: list) -> list:\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n    \n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]", "assertions": "points = [(0, 0), (1, 1), (2, 2), (1, 0), (2, 0)]\nhull = convex_hull(points)\nassert (0, 0) in hull\nassert (2, 0) in hull\nassert (2, 2) in hull\nassert len(hull) == 3", "metadata": {"language": "Python", "function_name": "convex_hull", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-070", "query_text": "Write a Python function named `manacher` that finds the longest palindrome using Manacher's algorithm. Language: Python. Function name: manacher", "reference_answer": "def manacher(s: str) -> str:\n    t = '#'.join('^{}$'.format(s))\n    n = len(t)\n    p = [0] * n\n    center = right = 0\n    \n    for i in range(1, n - 1):\n        if i < right:\n            p[i] = min(right - i, p[2 * center - i])\n        \n        while t[i + p[i] + 1] == t[i - p[i] - 1]:\n            p[i] += 1\n        \n        if i + p[i] > right:\n            center, right = i, i + p[i]\n    \n    max_len, center_index = max((n, i) for i, n in enumerate(p))\n    start = (center_index - max_len) // 2\n    return s[start:start + max_len]", "assertions": "assert manacher('babad') in ['bab', 'aba']\nassert manacher('cbbd') == 'bb'\nassert manacher('a') == 'a'\nassert manacher('racecar') == 'racecar'", "metadata": {"language": "Python", "function_name": "manacher", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-071", "query_text": "Write a TypeScript function named `asyncQueue` that implements an async task queue with concurrency limit. Language: TypeScript. Function name: AsyncQueue", "reference_answer": "class AsyncQueue {\n    private queue: Array<() => Promise<any>> = [];\n    private running = 0;\n    \n    constructor(private concurrency: number) {}\n    \n    async add<T>(task: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await task();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.process();\n        });\n    }\n    \n    private async process(): Promise<void> {\n        if (this.running >= this.concurrency || this.queue.length === 0) return;\n        \n        this.running++;\n        const task = this.queue.shift()!;\n        await task();\n        this.running--;\n        this.process();\n    }\n}", "assertions": "const queue = new AsyncQueue(2);\nlet running = 0;\nconst task = async () => { running++; await new Promise(r => setTimeout(r, 10)); running--; };\nPromise.all([queue.add(task), queue.add(task), queue.add(task)]).then(() => {\n    if (running > 2) throw new Error('Exceeded concurrency limit');\n});", "metadata": {"language": "TypeScript", "function_name": "AsyncQueue", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.9}}
{"query_id": "synthetic-072", "query_text": "Write a TypeScript function named `createStateMachine` that implements a type-safe finite state machine. Language: TypeScript. Function name: createStateMachine", "reference_answer": "function createStateMachine<S extends string, E extends string>(config: { initial: S; transitions: Record<S, Record<E, S>> }) {\n    let state = config.initial;\n    \n    return {\n        getState: () => state,\n        send: (event: E) => {\n            const nextState = config.transitions[state]?.[event];\n            if (nextState) {\n                state = nextState;\n                return true;\n            }\n            return false;\n        }\n    };\n}", "assertions": "type State = 'idle' | 'loading' | 'success' | 'error';\ntype Event = 'FETCH' | 'SUCCESS' | 'ERROR' | 'RESET';\nconst machine = createStateMachine<State, Event>({\n    initial: 'idle',\n    transitions: {\n        idle: { FETCH: 'loading' },\n        loading: { SUCCESS: 'success', ERROR: 'error' },\n        success: { RESET: 'idle' },\n        error: { RESET: 'idle' }\n    }\n});\nif (machine.getState() !== 'idle') throw new Error('Failed');\nmachine.send('FETCH');\nif (machine.getState() !== 'loading') throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "createStateMachine", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.85}}
{"query_id": "synthetic-073", "query_text": "Write a TypeScript function named `createObservable` that implements the Observable pattern. Language: TypeScript. Function name: createObservable", "reference_answer": "function createObservable<T>(subscribe: (observer: { next: (value: T) => void; error: (err: any) => void; complete: () => void }) => () => void) {\n    return {\n        subscribe: (observer: Partial<{ next: (value: T) => void; error: (err: any) => void; complete: () => void }>) => {\n            const unsubscribe = subscribe({\n                next: observer.next || (() => {}),\n                error: observer.error || (() => {}),\n                complete: observer.complete || (() => {})\n            });\n            return { unsubscribe };\n        },\n        pipe: <U>(operator: (obs: ReturnType<typeof createObservable<T>>) => ReturnType<typeof createObservable<U>>) => operator({ subscribe } as any)\n    };\n}", "assertions": "const obs = createObservable<number>(observer => {\n    observer.next(1);\n    observer.next(2);\n    observer.complete();\n    return () => {};\n});\nlet values: number[] = [];\nobs.subscribe({ next: v => values.push(v) });\nif (JSON.stringify(values) !== JSON.stringify([1, 2])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "createObservable", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.9}}
{"query_id": "synthetic-074", "query_text": "Write a TypeScript function named `createLazyValue` that implements lazy evaluation with memoization. Language: TypeScript. Function name: createLazyValue", "reference_answer": "function createLazyValue<T>(factory: () => T): { value: T } {\n    let cached: T | undefined;\n    let computed = false;\n    \n    return {\n        get value(): T {\n            if (!computed) {\n                cached = factory();\n                computed = true;\n            }\n            return cached!;\n        }\n    };\n}", "assertions": "let callCount = 0;\nconst lazy = createLazyValue(() => { callCount++; return 42; });\nif (callCount !== 0) throw new Error('Factory called too early');\nif (lazy.value !== 42) throw new Error('Failed');\nif (callCount !== 1) throw new Error('Factory not called');\nif (lazy.value !== 42 || callCount !== 1) throw new Error('Not memoized');", "metadata": {"language": "TypeScript", "function_name": "createLazyValue", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.75}}
{"query_id": "synthetic-075", "query_text": "Write a TypeScript function named `createProxy` that implements a validation proxy. Language: TypeScript. Function name: createProxy", "reference_answer": "function createProxy<T extends object>(target: T, validator: (key: keyof T, value: any) => boolean): T {\n    return new Proxy(target, {\n        set(obj, prop, value) {\n            if (!validator(prop as keyof T, value)) {\n                throw new Error(`Invalid value for ${String(prop)}`);\n            }\n            return Reflect.set(obj, prop, value);\n        }\n    });\n}", "assertions": "const obj = createProxy({ age: 0 }, (key, value) => key === 'age' ? value >= 0 : true);\nobj.age = 25;\nif (obj.age !== 25) throw new Error('Failed');\ntry {\n    obj.age = -5;\n    throw new Error('Should have thrown');\n} catch (e) {\n    if (!String(e).includes('Invalid')) throw new Error('Wrong error');\n}", "metadata": {"language": "TypeScript", "function_name": "createProxy", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.85}}
{"query_id": "synthetic-076", "query_text": "Write a TypeScript function named `createCircuitBreaker` that implements the circuit breaker pattern. Language: TypeScript. Function name: createCircuitBreaker", "reference_answer": "function createCircuitBreaker<T extends (...args: any[]) => Promise<any>>(fn: T, threshold: number, timeout: number) {\n    let failures = 0;\n    let state: 'closed' | 'open' | 'half-open' = 'closed';\n    let nextAttempt = Date.now();\n    \n    return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n        if (state === 'open') {\n            if (Date.now() < nextAttempt) {\n                throw new Error('Circuit breaker is open');\n            }\n            state = 'half-open';\n        }\n        \n        try {\n            const result = await fn(...args);\n            if (state === 'half-open') {\n                state = 'closed';\n                failures = 0;\n            }\n            return result;\n        } catch (error) {\n            failures++;\n            if (failures >= threshold) {\n                state = 'open';\n                nextAttempt = Date.now() + timeout;\n            }\n            throw error;\n        }\n    };\n}", "assertions": "let calls = 0;\nconst unreliable = async () => { calls++; if (calls < 5) throw new Error('fail'); return 'ok'; };\nconst breaker = createCircuitBreaker(unreliable, 3, 1000);\nfor (let i = 0; i < 3; i++) {\n    try { await breaker(); } catch (e) {}\n}\ntry {\n    await breaker();\n    throw new Error('Should be open');\n} catch (e) {\n    if (!String(e).includes('open')) throw new Error('Wrong error');\n}", "metadata": {"language": "TypeScript", "function_name": "createCircuitBreaker", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.9}}
{"query_id": "synthetic-077", "query_text": "Write a TypeScript function named `createTransducer` that implements transducers for composable data transformations. Language: TypeScript. Function name: createTransducer", "reference_answer": "function createTransducer<T, U>(transformer: (reducer: (acc: U[], item: U) => U[]) => (acc: U[], item: T) => U[]) {\n    return {\n        map: <V>(fn: (item: U) => V) => createTransducer<T, V>(nextReducer => transformer((acc, item) => nextReducer(acc, fn(item)))),\n        filter: (pred: (item: U) => boolean) => createTransducer<T, U>(nextReducer => transformer((acc, item) => pred(item) ? nextReducer(acc, item) : acc)),\n        transduce: (arr: T[]) => arr.reduce(transformer((acc, item) => [...acc, item]), [] as U[])\n    };\n}", "assertions": "const identity = createTransducer<number, number>(reducer => reducer);\nconst doubled = identity.map(x => x * 2);\nconst evens = doubled.filter(x => x % 2 === 0);\nconst result = evens.transduce([1, 2, 3, 4, 5]);\nif (JSON.stringify(result) !== JSON.stringify([2, 4, 6, 8, 10])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "createTransducer", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-078", "query_text": "Write a TypeScript function named `createTimeoutPool` that manages a pool of timeout-aware workers. Language: TypeScript. Function name: TimeoutPool", "reference_answer": "class TimeoutPool<T> {\n    private queue: Array<{ task: () => Promise<T>; resolve: (value: T) => void; reject: (error: any) => void }> = [];\n    private active = 0;\n    \n    constructor(private concurrency: number, private timeout: number) {}\n    \n    async add(task: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push({ task, resolve, reject });\n            this.process();\n        });\n    }\n    \n    private async process(): Promise<void> {\n        if (this.active >= this.concurrency || this.queue.length === 0) return;\n        \n        this.active++;\n        const { task, resolve, reject } = this.queue.shift()!;\n        \n        const timeoutPromise = new Promise<never>((_, rej) => setTimeout(() => rej(new Error('Timeout')), this.timeout));\n        \n        try {\n            const result = await Promise.race([task(), timeoutPromise]);\n            resolve(result);\n        } catch (error) {\n            reject(error);\n        } finally {\n            this.active--;\n            this.process();\n        }\n    }\n}", "assertions": "const pool = new TimeoutPool<number>(2, 100);\nconst fast = () => Promise.resolve(42);\nconst slow = () => new Promise<number>(r => setTimeout(() => r(1), 200));\npool.add(fast).then(result => {\n    if (result !== 42) throw new Error('Failed');\n});\npool.add(slow).catch(e => {\n    if (!String(e).includes('Timeout')) throw new Error('Should timeout');\n});", "metadata": {"language": "TypeScript", "function_name": "TimeoutPool", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.95}}
{"query_id": "synthetic-079", "query_text": "Write a Go function named `ParallelMap` that maps a function over a slice in parallel. Language: Go. Function name: ParallelMap", "reference_answer": "package main\n\nimport \"sync\"\n\nfunc ParallelMap(nums []int, fn func(int) int) []int {\n\tresult := make([]int, len(nums))\n\tvar wg sync.WaitGroup\n\t\n\tfor i, num := range nums {\n\t\twg.Add(1)\n\t\tgo func(idx, val int) {\n\t\t\tdefer wg.Done()\n\t\t\tresult[idx] = fn(val)\n\t\t}(i, num)\n\t}\n\t\n\twg.Wait()\n\treturn result\n}", "assertions": "result := ParallelMap([]int{1, 2, 3, 4, 5}, func(n int) int { return n * 2 })\nexpected := []int{2, 4, 6, 8, 10}\nfor i := range result {\n\tif result[i] != expected[i] { panic(\"Failed\") }\n}", "metadata": {"language": "Go", "function_name": "ParallelMap", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.8}}
{"query_id": "synthetic-080", "query_text": "Write a Rust function named `parallel_filter` that filters a vector in parallel. Language: Rust. Function name: parallel_filter", "reference_answer": "use std::sync::Arc;\nuse std::thread;\n\npub fn parallel_filter<T: Send + Sync + Clone + 'static>(vec: Vec<T>, predicate: Arc<dyn Fn(&T) -> bool + Send + Sync>) -> Vec<T> {\n    let chunk_size = (vec.len() + 3) / 4;\n    let mut handles = vec![];\n    \n    let vec = Arc::new(vec);\n    for i in 0..4 {\n        let vec = Arc::clone(&vec);\n        let predicate = Arc::clone(&predicate);\n        let handle = thread::spawn(move || {\n            let start = i * chunk_size;\n            let end = std::cmp::min(start + chunk_size, vec.len());\n            vec[start..end].iter().filter(|item| predicate(item)).cloned().collect::<Vec<_>>()\n        });\n        handles.push(handle);\n    }\n    \n    handles.into_iter().flat_map(|h| h.join().unwrap()).collect()\n}", "assertions": "let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nlet predicate = Arc::new(|x: &i32| x % 2 == 0);\nlet result = parallel_filter(vec, predicate);\nassert_eq!(result.len(), 5);\nassert!(result.contains(&2) && result.contains(&4));", "metadata": {"language": "Rust", "function_name": "parallel_filter", "difficulty": "advanced", "category": "concurrency", "complexity": 0.8}}
{"query_id": "synthetic-081", "query_text": "Write a Python function named `compress_string` that compresses a string using run-length encoding. Language: Python. Function name: compress_string", "reference_answer": "def compress_string(s: str) -> str:\n    if not s:\n        return ''\n    result = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            result.append(s[i-1] + str(count))\n            count = 1\n    result.append(s[-1] + str(count))\n    compressed = ''.join(result)\n    return compressed if len(compressed) < len(s) else s", "assertions": "assert compress_string('aabcccccaaa') == 'a2b1c5a3'\nassert compress_string('abc') == 'abc'\nassert compress_string('aaa') == 'a3'\nassert compress_string('') == ''", "metadata": {"language": "Python", "function_name": "compress_string", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-082", "query_text": "Write a Python function named `kadane_algorithm` that finds maximum sum subarray using Kadane's algorithm. Language: Python. Function name: kadane_algorithm", "reference_answer": "def kadane_algorithm(nums: list) -> int:\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = max(num, max_current + num)\n        max_global = max(max_global, max_current)\n    return max_global", "assertions": "assert kadane_algorithm([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6\nassert kadane_algorithm([1]) == 1\nassert kadane_algorithm([5, 4, -1, 7, 8]) == 23", "metadata": {"language": "Python", "function_name": "kadane_algorithm", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-083", "query_text": "Write a Python function named `sliding_window_median` that finds median in sliding windows. Language: Python. Function name: sliding_window_median", "reference_answer": "import bisect\n\ndef sliding_window_median(nums: list, k: int) -> list:\n    result = []\n    window = []\n    \n    for i, num in enumerate(nums):\n        bisect.insort(window, num)\n        if i >= k:\n            window.remove(nums[i - k])\n        if i >= k - 1:\n            median = window[k // 2] if k % 2 else (window[k // 2 - 1] + window[k // 2]) / 2\n            result.append(median)\n    \n    return result", "assertions": "assert sliding_window_median([1, 3, -1, -3, 5, 3, 6, 7], 3) == [1, -1, -1, 3, 5, 6]\nassert sliding_window_median([1, 2, 3, 4], 2) == [1.5, 2.5, 3.5]", "metadata": {"language": "Python", "function_name": "sliding_window_median", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-084", "query_text": "Write a Python function named `generate_parentheses` that generates all valid parentheses combinations. Language: Python. Function name: generate_parentheses", "reference_answer": "def generate_parentheses(n: int) -> list:\n    result = []\n    \n    def backtrack(s, open_count, close_count):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if open_count < n:\n            backtrack(s + '(', open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(s + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result", "assertions": "assert set(generate_parentheses(3)) == {'((()))', '(()())', '(())()', '()(())', '()()()'}\nassert generate_parentheses(1) == ['()']\nassert len(generate_parentheses(4)) == 14", "metadata": {"language": "Python", "function_name": "generate_parentheses", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-085", "query_text": "Write a Python function named `minimum_window_substring` that finds the minimum window substring containing all characters. Language: Python. Function name: minimum_window_substring", "reference_answer": "from collections import Counter\n\ndef minimum_window_substring(s: str, t: str) -> str:\n    if not s or not t:\n        return ''\n    \n    target_counts = Counter(t)\n    required = len(target_counts)\n    left = right = formed = 0\n    window_counts = {}\n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        if char in target_counts and window_counts[char] == target_counts[char]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            char = s[left]\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_counts[char] -= 1\n            if char in target_counts and window_counts[char] < target_counts[char]:\n                formed -= 1\n            left += 1\n        \n        right += 1\n    \n    return '' if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]", "assertions": "assert minimum_window_substring('ADOBECODEBANC', 'ABC') == 'BANC'\nassert minimum_window_substring('a', 'a') == 'a'\nassert minimum_window_substring('a', 'aa') == ''", "metadata": {"language": "Python", "function_name": "minimum_window_substring", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-086", "query_text": "Write a Python function named `serialize_deserialize_tree` that serializes and deserializes a binary tree. Language: Python. Function name: serialize, deserialize", "reference_answer": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef serialize(root: TreeNode) -> str:\n    def helper(node):\n        if not node:\n            return ['null']\n        return [str(node.val)] + helper(node.left) + helper(node.right)\n    return ','.join(helper(root))\n\ndef deserialize(data: str) -> TreeNode:\n    def helper(vals):\n        val = next(vals)\n        if val == 'null':\n            return None\n        node = TreeNode(int(val))\n        node.left = helper(vals)\n        node.right = helper(vals)\n        return node\n    return helper(iter(data.split(',')))", "assertions": "node = TreeNode(1, TreeNode(2), TreeNode(3))\nserialized = serialize(node)\ndeserialized = deserialize(serialized)\nassert deserialized.val == 1\nassert deserialized.left.val == 2\nassert deserialized.right.val == 3", "metadata": {"language": "Python", "function_name": "serialize", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.85}}
{"query_id": "synthetic-087", "query_text": "Write a TypeScript function named `shuffle` that randomly shuffles an array. Language: TypeScript. Function name: shuffle", "reference_answer": "function shuffle<T>(arr: T[]): T[] {\n    const result = [...arr];\n    for (let i = result.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [result[i], result[j]] = [result[j], result[i]];\n    }\n    return result;\n}", "assertions": "const arr = [1, 2, 3, 4, 5];\nconst shuffled = shuffle(arr);\nif (shuffled.length !== 5) throw new Error('Failed');\nif (JSON.stringify(shuffled.sort()) !== JSON.stringify([1, 2, 3, 4, 5])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "shuffle", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-088", "query_text": "Write a TypeScript function named `sample` that randomly samples n elements from an array. Language: TypeScript. Function name: sample", "reference_answer": "function sample<T>(arr: T[], n: number): T[] {\n    const result: T[] = [];\n    const taken = new Set<number>();\n    const count = Math.min(n, arr.length);\n    \n    while (result.length < count) {\n        const index = Math.floor(Math.random() * arr.length);\n        if (!taken.has(index)) {\n            taken.add(index);\n            result.push(arr[index]);\n        }\n    }\n    \n    return result;\n}", "assertions": "const arr = [1, 2, 3, 4, 5];\nconst sampled = sample(arr, 3);\nif (sampled.length !== 3) throw new Error('Failed');\nif (sampled.some(x => !arr.includes(x))) throw new Error('Invalid sample');", "metadata": {"language": "TypeScript", "function_name": "sample", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-089", "query_text": "Write a TypeScript function named `omit` that omits specified keys from an object. Language: TypeScript. Function name: omit", "reference_answer": "function omit<T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n    const result = { ...obj };\n    keys.forEach(key => delete result[key]);\n    return result as Omit<T, K>;\n}", "assertions": "const obj = { a: 1, b: 2, c: 3, d: 4 };\nconst result = omit(obj, ['b', 'd']);\nif (JSON.stringify(result) !== JSON.stringify({ a: 1, c: 3 })) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "omit", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-090", "query_text": "Write a TypeScript function named `clamp` that clamps a number between min and max. Language: TypeScript. Function name: clamp", "reference_answer": "function clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n}", "assertions": "if (clamp(10, 0, 5) !== 5) throw new Error('Failed');\nif (clamp(-5, 0, 10) !== 0) throw new Error('Failed');\nif (clamp(3, 0, 10) !== 3) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "clamp", "difficulty": "medium", "category": "algorithms", "complexity": 0.25}}
{"query_id": "synthetic-091", "query_text": "Write a TypeScript function named `compose` that composes functions right-to-left. Language: TypeScript. Function name: compose", "reference_answer": "function compose<T>(...fns: Array<(arg: any) => any>): (arg: T) => any {\n    return (arg: T) => fns.reduceRight((acc, fn) => fn(acc), arg);\n}", "assertions": "const addOne = (n: number) => n + 1;\nconst double = (n: number) => n * 2;\nconst composed = compose(double, addOne);\nif (composed(5) !== 12) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "compose", "difficulty": "advanced", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-092", "query_text": "Write a TypeScript function named `asyncRetry` that retries an async function with delays. Language: TypeScript. Function name: asyncRetry", "reference_answer": "async function asyncRetry<T>(fn: () => Promise<T>, retries: number, delay: number): Promise<T> {\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await fn();\n        } catch (error) {\n            if (i === retries - 1) throw error;\n            await new Promise(resolve => setTimeout(resolve, delay));\n        }\n    }\n    throw new Error('Max retries exceeded');\n}", "assertions": "let attempts = 0;\nconst unstable = () => { attempts++; if (attempts < 3) return Promise.reject('fail'); return Promise.resolve('ok'); };\nasyncRetry(unstable, 5, 10).then(result => {\n    if (result !== 'ok' || attempts !== 3) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "asyncRetry", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-093", "query_text": "Write a TypeScript function named `asyncFilter` that filters an array with an async predicate. Language: TypeScript. Function name: asyncFilter", "reference_answer": "async function asyncFilter<T>(arr: T[], predicate: (item: T) => Promise<boolean>): Promise<T[]> {\n    const results = await Promise.all(arr.map(predicate));\n    return arr.filter((_, index) => results[index]);\n}", "assertions": "const isEven = async (n: number) => n % 2 === 0;\nasyncFilter([1, 2, 3, 4, 5], isEven).then(result => {\n    if (JSON.stringify(result) !== JSON.stringify([2, 4])) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "asyncFilter", "difficulty": "advanced", "category": "concurrency", "complexity": 0.65}}
{"query_id": "synthetic-094", "query_text": "Write a TypeScript function named `asyncReduce` that reduces an array with an async reducer. Language: TypeScript. Function name: asyncReduce", "reference_answer": "async function asyncReduce<T, U>(arr: T[], reducer: (acc: U, item: T) => Promise<U>, initial: U): Promise<U> {\n    let acc = initial;\n    for (const item of arr) {\n        acc = await reducer(acc, item);\n    }\n    return acc;\n}", "assertions": "const sum = async (acc: number, n: number) => acc + n;\nasyncReduce([1, 2, 3, 4, 5], sum, 0).then(result => {\n    if (result !== 15) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "asyncReduce", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-095", "query_text": "Write a TypeScript function named `createPool` that implements a generic resource pool. Language: TypeScript. Function name: ResourcePool", "reference_answer": "class ResourcePool<T> {\n    private available: T[] = [];\n    private inUse = new Set<T>();\n    \n    constructor(private factory: () => T, private maxSize: number) {}\n    \n    acquire(): T | null {\n        if (this.available.length > 0) {\n            const resource = this.available.pop()!;\n            this.inUse.add(resource);\n            return resource;\n        }\n        if (this.inUse.size < this.maxSize) {\n            const resource = this.factory();\n            this.inUse.add(resource);\n            return resource;\n        }\n        return null;\n    }\n    \n    release(resource: T): void {\n        if (this.inUse.has(resource)) {\n            this.inUse.delete(resource);\n            this.available.push(resource);\n        }\n    }\n}", "assertions": "let counter = 0;\nconst pool = new ResourcePool(() => ({ id: counter++ }), 2);\nconst r1 = pool.acquire();\nconst r2 = pool.acquire();\nconst r3 = pool.acquire();\nif (!r1 || !r2 || r3 !== null) throw new Error('Failed');\npool.release(r1);\nconst r4 = pool.acquire();\nif (!r4 || r4.id !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "ResourcePool", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.85}}
{"query_id": "synthetic-096", "query_text": "Write a TypeScript function named `createScheduler` that schedules tasks with priorities. Language: TypeScript. Function name: TaskScheduler", "reference_answer": "class TaskScheduler {\n    private queue: Array<{ task: () => Promise<void>; priority: number }> = [];\n    private running = false;\n    \n    add(task: () => Promise<void>, priority: number = 0): void {\n        this.queue.push({ task, priority });\n        this.queue.sort((a, b) => b.priority - a.priority);\n        this.process();\n    }\n    \n    private async process(): Promise<void> {\n        if (this.running || this.queue.length === 0) return;\n        \n        this.running = true;\n        const { task } = this.queue.shift()!;\n        await task();\n        this.running = false;\n        this.process();\n    }\n}", "assertions": "const scheduler = new TaskScheduler();\nconst results: number[] = [];\nscheduler.add(async () => { results.push(1); }, 1);\nscheduler.add(async () => { results.push(2); }, 3);\nscheduler.add(async () => { results.push(3); }, 2);\nsetTimeout(() => {\n    if (JSON.stringify(results) !== JSON.stringify([2, 3, 1])) throw new Error('Failed');\n}, 100);", "metadata": {"language": "TypeScript", "function_name": "TaskScheduler", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.9}}
{"query_id": "synthetic-097", "query_text": "Write a Go function named `Filter` that filters a slice based on a predicate. Language: Go. Function name: Filter", "reference_answer": "package main\n\nfunc Filter(nums []int, predicate func(int) bool) []int {\n\tresult := make([]int, 0)\n\tfor _, num := range nums {\n\t\tif predicate(num) {\n\t\t\tresult = append(result, num)\n\t\t}\n\t}\n\treturn result\n}", "assertions": "isEven := func(n int) bool { return n%2 == 0 }\nresult := Filter([]int{1, 2, 3, 4, 5, 6}, isEven)\nexpected := []int{2, 4, 6}\nfor i := range result {\n\tif result[i] != expected[i] { panic(\"Failed\") }\n}", "metadata": {"language": "Go", "function_name": "Filter", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-098", "query_text": "Write a Go function named `QuickSort` that implements quicksort. Language: Go. Function name: QuickSort", "reference_answer": "package main\n\nfunc QuickSort(nums []int) []int {\n\tif len(nums) <= 1 {\n\t\treturn nums\n\t}\n\t\n\tpivot := nums[len(nums)/2]\n\tleft := make([]int, 0)\n\tmiddle := make([]int, 0)\n\tright := make([]int, 0)\n\t\n\tfor _, num := range nums {\n\t\tif num < pivot {\n\t\t\tleft = append(left, num)\n\t\t} else if num == pivot {\n\t\t\tmiddle = append(middle, num)\n\t\t} else {\n\t\t\tright = append(right, num)\n\t\t}\n\t}\n\t\n\tresult := append(QuickSort(left), middle...)\n\treturn append(result, QuickSort(right)...)\n}", "assertions": "result := QuickSort([]int{3, 6, 8, 10, 1, 2, 1})\nexpected := []int{1, 1, 2, 3, 6, 8, 10}\nfor i := range result {\n\tif result[i] != expected[i] { panic(\"Failed\") }\n}", "metadata": {"language": "Go", "function_name": "QuickSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-099", "query_text": "Write a C++ function named `fibonacci` that calculates the nth Fibonacci number. Language: C++. Function name: fibonacci", "reference_answer": "#include <vector>\n\nint fibonacci(int n) {\n    if (n <= 1) return n;\n    std::vector<int> dp(n + 1);\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    return dp[n];\n}", "assertions": "if (fibonacci(0) != 0) throw std::runtime_error(\"Failed\");\nif (fibonacci(1) != 1) throw std::runtime_error(\"Failed\");\nif (fibonacci(10) != 55) throw std::runtime_error(\"Failed\");\nif (fibonacci(15) != 610) throw std::runtime_error(\"Failed\");", "metadata": {"language": "C++", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-100", "query_text": "Write a Ruby function named `word_frequency` that counts word frequencies in a string. Language: Ruby. Function name: word_frequency", "reference_answer": "def word_frequency(text)\n  text.downcase.scan(/\\w+/).each_with_object(Hash.new(0)) do |word, counts|\n    counts[word] += 1\n  end\nend", "assertions": "result = word_frequency(\"hello world hello\")\nraise 'Failed' unless result['hello'] == 2 && result['world'] == 1\nresult2 = word_frequency(\"The quick brown fox\")\nraise 'Failed' unless result2['the'] == 1 && result2['quick'] == 1", "metadata": {"language": "Ruby", "function_name": "word_frequency", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
