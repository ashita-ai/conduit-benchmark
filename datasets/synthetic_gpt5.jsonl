{"query_id": "synthetic-001", "query_text": "Write a Python function named `rotate_matrix_clockwise` that rotates a square matrix 90 degrees clockwise in place and returns the matrix. Handle empty matrices gracefully. Language: Python. Function name: rotate_matrix_clockwise", "reference_answer": "def rotate_matrix_clockwise(matrix: list[list[int]]) -> list[list[int]]:\n    n = len(matrix)\n    if n == 0:\n        return matrix\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    for row in matrix:\n        row.reverse()\n    return matrix", "assertions": "m1 = [[1, 2], [3, 4]]\nassert rotate_matrix_clockwise(m1) == [[3, 1], [4, 2]]\nm2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert rotate_matrix_clockwise(m2) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\nassert rotate_matrix_clockwise([]) == []", "metadata": {"language": "Python", "function_name": "rotate_matrix_clockwise", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.68}}
{"query_id": "synthetic-002", "query_text": "Write a Python function named `max_flow_edmonds_karp` that computes the maximum flow between a source and sink in a directed graph represented by a capacity adjacency map using the Edmonds-Karp algorithm. Language: Python. Function name: max_flow_edmonds_karp", "reference_answer": "from collections import deque\n\ndef max_flow_edmonds_karp(capacity: dict[str, dict[str, int]], source: str, sink: str) -> int:\n    nodes = set(capacity.keys())\n    for edges in capacity.values():\n        nodes.update(edges.keys())\n    residual = {u: {v: 0 for v in nodes} for u in nodes}\n    for u, edges in capacity.items():\n        for v, cap in edges.items():\n            residual[u][v] = cap\n    flow = 0\n    while True:\n        parent: dict[str, str | None] = {source: None}\n        queue: deque[str] = deque([source])\n        while queue and sink not in parent:\n            u = queue.popleft()\n            for v, cap in residual[u].items():\n                if cap > 0 and v not in parent:\n                    parent[v] = u\n                    queue.append(v)\n        if sink not in parent:\n            break\n        bottleneck = float('inf')\n        v = sink\n        while v != source:\n            u = parent[v]\n            bottleneck = min(bottleneck, residual[u][v])\n            v = u\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u][v] -= bottleneck\n            residual[v][u] += bottleneck\n            v = u\n        flow += bottleneck\n    return flow", "assertions": "graph = {\n    's': {'a': 3, 'b': 2},\n    'a': {'b': 1, 't': 2},\n    'b': {'t': 3},\n    't': {}\n}\nassert max_flow_edmonds_karp(graph, 's', 't') == 5\nsmall = {'s': {'t': 4}, 't': {}}\nassert max_flow_edmonds_karp(small, 's', 't') == 4", "metadata": {"language": "Python", "function_name": "max_flow_edmonds_karp", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-003", "query_text": "Write a Python function named `count_subarrays_with_sum` that returns how many contiguous subarrays sum to a target integer using prefix sums. Language: Python. Function name: count_subarrays_with_sum", "reference_answer": "from collections import defaultdict\n\ndef count_subarrays_with_sum(nums: list[int], target: int) -> int:\n    prefix_counts: dict[int, int] = defaultdict(int)\n    prefix_counts[0] = 1\n    total = 0\n    running = 0\n    for num in nums:\n        running += num\n        total += prefix_counts[running - target]\n        prefix_counts[running] += 1\n    return total", "assertions": "assert count_subarrays_with_sum([1, 1, 1], 2) == 2\nassert count_subarrays_with_sum([1, 2, 3], 3) == 2\nassert count_subarrays_with_sum([0, 0, 0], 0) == 6\nassert count_subarrays_with_sum([], 0) == 0", "metadata": {"language": "Python", "function_name": "count_subarrays_with_sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.52}}
{"query_id": "synthetic-004", "query_text": "Write a Python function named `longest_common_subsequence` that returns the longest common subsequence string between two input strings using dynamic programming. Language: Python. Function name: longest_common_subsequence", "reference_answer": "def longest_common_subsequence(a: str, b: str) -> str:\n    m, n = len(a), len(b)\n    dp: list[list[str]] = [[\"\" ] * (n + 1) for _ in range(m + 1)]\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if a[i] == b[j]:\n                dp[i][j] = a[i] + dp[i + 1][j + 1]\n            else:\n                left = dp[i + 1][j]\n                right = dp[i][j + 1]\n                dp[i][j] = left if len(left) >= len(right) else right\n    return dp[0][0]", "assertions": "assert longest_common_subsequence('abcde', 'ace') == 'ace'\nassert longest_common_subsequence('abc', 'abc') == 'abc'\nassert longest_common_subsequence('abc', 'def') == ''\nassert longest_common_subsequence('pmjghexybyrgzczy', 'hafcdqbgncrcbihkd') == 'hbgd'", "metadata": {"language": "Python", "function_name": "longest_common_subsequence", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.72}}
{"query_id": "synthetic-005", "query_text": "Write a TypeScript function named `longestIncreasingSubsequence` that returns the lexicographically earliest longest strictly increasing subsequence of a number array using an O(n log n) approach. Language: TypeScript. Function name: longestIncreasingSubsequence", "reference_answer": "function longestIncreasingSubsequence(nums: number[]): number[] {\n    const n = nums.length;\n    if (n === 0) return [];\n    const tails: number[] = [];\n    const tailIndices: number[] = [];\n    const prev: number[] = new Array(n).fill(-1);\n    for (let i = 0; i < n; i++) {\n        let left = 0;\n        let right = tails.length;\n        while (left < right) {\n            const mid = Math.floor((left + right) / 2);\n            if (tails[mid] < nums[i]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        if (left === tails.length) {\n            tails.push(nums[i]);\n            tailIndices[left] = i;\n        } else {\n            tails[left] = nums[i];\n            tailIndices[left] = i;\n        }\n        if (left > 0) {\n            prev[i] = tailIndices[left - 1];\n        }\n    }\n    let k = tailIndices[tails.length - 1];\n    const sequence: number[] = [];\n    while (k !== undefined && k >= 0) {\n        sequence.push(nums[k]);\n        k = prev[k];\n    }\n    return sequence.reverse();\n}", "assertions": "const lis1 = longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]);\nif (JSON.stringify(lis1) !== JSON.stringify([2, 3, 7, 18])) throw new Error('Failed');\nconst lis2 = longestIncreasingSubsequence([0, 1, 0, 3, 2, 3]);\nif (JSON.stringify(lis2) !== JSON.stringify([0, 1, 2, 3])) throw new Error('Failed');\nif (JSON.stringify(longestIncreasingSubsequence([])) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "longestIncreasingSubsequence", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.74}}
{"query_id": "synthetic-006", "query_text": "Write a TypeScript function named `chunkArray` that splits an array into chunks of a given size and returns an array of chunks. Language: TypeScript. Function name: chunkArray", "reference_answer": "function chunkArray<T>(items: T[], size: number): T[][] {\n    if (size <= 0) throw new Error('size must be positive');\n    const result: T[][] = [];\n    for (let i = 0; i < items.length; i += size) {\n        result.push(items.slice(i, i + size));\n    }\n    return result;\n}", "assertions": "const chunks1 = chunkArray([1, 2, 3, 4, 5], 2);\nif (JSON.stringify(chunks1) !== JSON.stringify([[1,2],[3,4],[5]])) throw new Error('Failed');\nconst chunks2 = chunkArray(['a', 'b', 'c'], 3);\nif (JSON.stringify(chunks2) !== JSON.stringify([['a','b','c']])) throw new Error('Failed');\nlet threw = false;\ntry { chunkArray([1], 0); } catch { threw = true; }\nif (!threw) throw new Error('Failed to throw');", "metadata": {"language": "TypeScript", "function_name": "chunkArray", "difficulty": "medium", "category": "data_structures", "complexity": 0.35}}
{"query_id": "synthetic-007", "query_text": "Write a TypeScript function named `topologicalSort` that performs a topological ordering of a directed acyclic graph represented as an adjacency list. Throw an error if a cycle is detected. Language: TypeScript. Function name: topologicalSort", "reference_answer": "function topologicalSort(graph: Record<string, string[]>): string[] {\n    const inDegree: Record<string, number> = {};\n    Object.keys(graph).forEach(node => {\n        if (!(node in inDegree)) inDegree[node] = 0;\n        graph[node].forEach(neighbor => {\n            inDegree[neighbor] = (inDegree[neighbor] || 0) + 1;\n        });\n    });\n    const queue: string[] = Object.keys(inDegree).filter(node => inDegree[node] === 0);\n    const order: string[] = [];\n    let index = 0;\n    while (index < queue.length) {\n        const node = queue[index++];\n        order.push(node);\n        (graph[node] || []).forEach(neighbor => {\n            inDegree[neighbor] -= 1;\n            if (inDegree[neighbor] === 0) {\n                queue.push(neighbor);\n            }\n        });\n    }\n    if (order.length !== Object.keys(inDegree).length) {\n        throw new Error('Graph has a cycle');\n    }\n    return order;\n}", "assertions": "const graph = {\n    'a': ['c'],\n    'b': ['c', 'd'],\n    'c': ['e'],\n    'd': ['f'],\n    'e': ['f'],\n    'f': []\n};\nconst order = topologicalSort(graph);\nif (order.length !== 6) throw new Error('Failed order length');\nconst cyclic = { 'x': ['y'], 'y': ['x'] };\nlet threw = false;\ntry { topologicalSort(cyclic); } catch { threw = true; }\nif (!threw) throw new Error('Failed to detect cycle');", "metadata": {"language": "TypeScript", "function_name": "topologicalSort", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-008", "query_text": "Write a TypeScript function named `rollingAverage` that returns the rolling average of a numeric array for a fixed window size using a sliding window. Language: TypeScript. Function name: rollingAverage", "reference_answer": "function rollingAverage(values: number[], window: number): number[] {\n    if (window <= 0) throw new Error('window must be positive');\n    if (window > values.length) return [];\n    const result: number[] = [];\n    let sum = 0;\n    for (let i = 0; i < values.length; i++) {\n        sum += values[i];\n        if (i >= window) {\n            sum -= values[i - window];\n        }\n        if (i >= window - 1) {\n            result.push(sum / window);\n        }\n    }\n    return result;\n}", "assertions": "const ra1 = rollingAverage([1, 2, 3, 4, 5], 3);\nif (JSON.stringify(ra1) !== JSON.stringify([2,3,4])) throw new Error('Failed');\nconst ra2 = rollingAverage([5, 5, 5], 1);\nif (JSON.stringify(ra2) !== JSON.stringify([5,5,5])) throw new Error('Failed');\nif (JSON.stringify(rollingAverage([1, 2], 5)) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "rollingAverage", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-009", "query_text": "Write a Go function named `ReverseWords` that reverses the order of words in a string while preserving single spaces. Language: Go. Function name: ReverseWords", "reference_answer": "package main\n\nimport (\n    \"strings\"\n)\n\nfunc ReverseWords(input string) string {\n    words := strings.Fields(input)\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    return strings.Join(words, \" \")\n}", "assertions": "if ReverseWords(\"hello world here\") != \"here world hello\" { panic(\"Failed\") }\nif ReverseWords(\"single\") != \"single\" { panic(\"Failed\") }\nif ReverseWords(\"  spaced   words \") != \"words spaced\" { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "ReverseWords", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.38}}
{"query_id": "synthetic-010", "query_text": "Write a Java method named `longestUniqueSubstring` that returns the length of the longest substring without repeated characters using a sliding window. Language: Java. Function name: longestUniqueSubstring", "reference_answer": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class LongestUniqueSubstring {\n    public static int longestUniqueSubstring(String s) {\n        Map<Character, Integer> indices = new HashMap<>();\n        int left = 0;\n        int best = 0;\n        for (int right = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            if (indices.containsKey(c) && indices.get(c) >= left) {\n                left = indices.get(c) + 1;\n            }\n            indices.put(c, right);\n            best = Math.max(best, right - left + 1);\n        }\n        return best;\n    }\n}", "assertions": "if (LongestUniqueSubstring.longestUniqueSubstring(\"abcabcbb\") != 3) throw new RuntimeException(\"Failed\");\nif (LongestUniqueSubstring.longestUniqueSubstring(\"bbbbb\") != 1) throw new RuntimeException(\"Failed\");\nif (LongestUniqueSubstring.longestUniqueSubstring(\"pwwkew\") != 3) throw new RuntimeException(\"Failed\");\nif (LongestUniqueSubstring.longestUniqueSubstring(\"\") != 0) throw new RuntimeException(\"Failed\");", "metadata": {"language": "Java", "function_name": "longestUniqueSubstring", "difficulty": "very_advanced", "category": "string_manipulation", "complexity": 0.69}}
{"query_id": "synthetic-011", "query_text": "Write a Python function named `maximize_profit_with_deadlines` that takes a list of (deadline, profit) tuples representing unit-time tasks and returns the maximum achievable profit when only one task can be executed per day before its deadline. Language: Python. Function name: maximize_profit_with_deadlines", "reference_answer": "import heapq\nfrom typing import List, Tuple\n\ndef maximize_profit_with_deadlines(tasks: List[Tuple[int, int]]) -> int:\n    tasks = sorted(tasks, key=lambda x: x[0])\n    heap: list[int] = []\n    for deadline, profit in tasks:\n        heapq.heappush(heap, profit)\n        if len(heap) > deadline:\n            heapq.heappop(heap)\n    return sum(heap)", "assertions": "assert maximize_profit_with_deadlines([(2, 50), (1, 10), (2, 20), (1, 20)]) == 70\nassert maximize_profit_with_deadlines([(1, 100)]) == 100\nassert maximize_profit_with_deadlines([]) == 0\nassert maximize_profit_with_deadlines([(3, 10), (3, 20), (3, 30), (1, 40)]) == 80", "metadata": {"language": "Python", "function_name": "maximize_profit_with_deadlines", "difficulty": "very_advanced", "category": "scheduling", "complexity": 0.71}}
{"query_id": "synthetic-012", "query_text": "Write a Python function named `articulation_points` that returns the set of articulation points in an undirected graph represented as an adjacency list using Tarjan's algorithm. Language: Python. Function name: articulation_points", "reference_answer": "from typing import Dict, List, Set\n\ndef articulation_points(graph: Dict[str, List[str]]) -> Set[str]:\n    time = 0\n    disc: Dict[str, int] = {}\n    low: Dict[str, int] = {}\n    parent: Dict[str, str | None] = {node: None for node in graph}\n    result: Set[str] = set()\n\n    def dfs(u: str) -> None:\n        nonlocal time\n        time += 1\n        disc[u] = low[u] = time\n        children = 0\n        for v in graph[u]:\n            if v not in disc:\n                parent[v] = u\n                children += 1\n                dfs(v)\n                low[u] = min(low[u], low[v])\n                if parent[u] is None and children > 1:\n                    result.add(u)\n                if parent[u] is not None and low[v] >= disc[u]:\n                    result.add(u)\n            elif v != parent[u]:\n                low[u] = min(low[u], disc[v])\n\n    for node in graph:\n        if node not in disc:\n            dfs(node)\n    return result", "assertions": "g1 = {\n    'a': ['b'],\n    'b': ['a', 'c', 'd'],\n    'c': ['b', 'd'],\n    'd': ['b', 'c', 'e'],\n    'e': ['d', 'f', 'g'],\n    'f': ['e', 'g'],\n    'g': ['e', 'f']\n}\nassert articulation_points(g1) == {'b', 'd', 'e'}\ng2 = {'x': ['y'], 'y': ['x']}\nassert articulation_points(g2) == set()", "metadata": {"language": "Python", "function_name": "articulation_points", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.89}}
{"query_id": "synthetic-013", "query_text": "Write a Python function named `smallest_window_substring` that returns the smallest substring of `s` containing all characters from `t` using a sliding window. Language: Python. Function name: smallest_window_substring", "reference_answer": "from collections import Counter\n\ndef smallest_window_substring(s: str, t: str) -> str:\n    if not s or not t:\n        return \"\"\n    required = Counter(t)\n    missing = len(t)\n    left = start = end = 0\n    for right, char in enumerate(s, 1):\n        if required[char] > 0:\n            missing -= 1\n        required[char] -= 1\n        if missing == 0:\n            while left < right and required[s[left]] < 0:\n                required[s[left]] += 1\n                left += 1\n            if end == 0 or right - left < end - start:\n                start, end = left, right\n            required[s[left]] += 1\n            missing += 1\n            left += 1\n    return s[start:end]", "assertions": "assert smallest_window_substring('ADOBECODEBANC', 'ABC') == 'BANC'\nassert smallest_window_substring('a', 'aa') == ''\nassert smallest_window_substring('ab', 'a') == 'a'\nassert smallest_window_substring('', 'a') == ''", "metadata": {"language": "Python", "function_name": "smallest_window_substring", "difficulty": "medium", "category": "string_algorithms", "complexity": 0.58}}
{"query_id": "synthetic-014", "query_text": "Write a Python function named `shortest_path_with_k_stops` that returns the cheapest price from a source to destination in a weighted directed graph with at most K intermediate stops using layered relaxation (Bellman-Ford). Language: Python. Function name: shortest_path_with_k_stops", "reference_answer": "from typing import List, Tuple\n\ndef shortest_path_with_k_stops(n: int, flights: List[Tuple[int, int, int]], src: int, dst: int, k: int) -> int:\n    dist = [float('inf')] * n\n    dist[src] = 0\n    for _ in range(k + 1):\n        temp = dist[:]\n        for u, v, w in flights:\n            if dist[u] + w < temp[v]:\n                temp[v] = dist[u] + w\n        dist = temp\n    return -1 if dist[dst] == float('inf') else dist[dst]", "assertions": "flights = [(0, 1, 100), (1, 2, 100), (0, 2, 500)]\nassert shortest_path_with_k_stops(3, flights, 0, 2, 1) == 200\nassert shortest_path_with_k_stops(3, flights, 0, 2, 0) == 500\nassert shortest_path_with_k_stops(4, [(0,1,50),(1,3,50),(0,2,120),(2,3,100)], 0, 3, 1) == 100", "metadata": {"language": "Python", "function_name": "shortest_path_with_k_stops", "difficulty": "advanced", "category": "graph_algorithms", "complexity": 0.76}}
{"query_id": "synthetic-015", "query_text": "Write a TypeScript function named `memoize` that takes a pure function and returns a memoized version supporting primitive and JSON-serializable arguments. Language: TypeScript. Function name: memoize", "reference_answer": "type Serializable = string | number | boolean | null | Serializable[] | { [key: string]: Serializable };\n\nexport function memoize<T extends (...args: Serializable[]) => Serializable>(fn: T): T {\n    const cache = new Map<string, Serializable>();\n    return ((...args: Serializable[]) => {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key) as Serializable;\n        }\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    }) as T;\n}", "assertions": "let calls = 0;\nconst square = (n: number) => { calls += 1; return n * n; };\nconst memoSquare = memoize(square);\nif (memoSquare(4) !== 16) throw new Error('Failed');\nmemoSquare(4);\nif (calls !== 1) throw new Error('Memoization did not cache result');", "metadata": {"language": "TypeScript", "function_name": "memoize", "difficulty": "advanced", "category": "functional_programming", "complexity": 0.65}}
{"query_id": "synthetic-016", "query_text": "Write a TypeScript function named `retryPromise` that retries an asynchronous factory function with exponential backoff up to `maxRetries` times before rejecting. Language: TypeScript. Function name: retryPromise", "reference_answer": "export async function retryPromise<T>(factory: () => Promise<T>, maxRetries: number, baseDelayMs = 50): Promise<T> {\n    let attempt = 0;\n    while (true) {\n        try {\n            return await factory();\n        } catch (error) {\n            if (attempt >= maxRetries) {\n                throw error;\n            }\n            const delay = baseDelayMs * Math.pow(2, attempt);\n            await new Promise(resolve => setTimeout(resolve, delay));\n            attempt += 1;\n        }\n    }\n}", "assertions": "let tries = 0;\nconst unstable = () => new Promise<number>((resolve, reject) => {\n    tries += 1;\n    if (tries >= 3) resolve(42);\n    else reject(new Error('fail'));\n});\nretryPromise(unstable, 5).then(value => {\n    if (value !== 42) throw new Error('Wrong value');\n});", "metadata": {"language": "TypeScript", "function_name": "retryPromise", "difficulty": "advanced", "category": "concurrency", "complexity": 0.73}}
{"query_id": "synthetic-017", "query_text": "Write a TypeScript function named `flattenObject` that flattens a nested object into dot-delimited keys (e.g., `{a:{b:1}}` -> `{\"a.b\":1}`). Language: TypeScript. Function name: flattenObject", "reference_answer": "type PlainObject = { [key: string]: any };\n\nexport function flattenObject(obj: PlainObject, prefix = ''): PlainObject {\n    const result: PlainObject = {};\n    Object.keys(obj).forEach(key => {\n        const value = obj[key];\n        const newKey = prefix ? `${prefix}.${key}` : key;\n        if (value !== null && typeof value === 'object' && !Array.isArray(value)) {\n            Object.assign(result, flattenObject(value, newKey));\n        } else {\n            result[newKey] = value;\n        }\n    });\n    return result;\n}", "assertions": "const flattened = flattenObject({ a: { b: { c: 1 } }, d: 2 });\nif (flattened['a.b.c'] !== 1 || flattened['d'] !== 2) throw new Error('Flatten failed');\nconst simple = flattenObject({ x: 1 });\nif (simple['x'] !== 1) throw new Error('Simple flatten failed');", "metadata": {"language": "TypeScript", "function_name": "flattenObject", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-018", "query_text": "Write a TypeScript function named `boundedQueue` that returns an object with `enqueue`, `dequeue`, and `size` methods implementing an async bounded queue that waits when the queue is full. Language: TypeScript. Function name: boundedQueue", "reference_answer": "type Resolver<T> = (value: T | PromiseLike<T>) => void;\n\nexport function boundedQueue<T>(capacity: number) {\n    const queue: T[] = [];\n    const pendingEnqueue: Resolver<void>[] = [];\n    const pendingDequeue: Resolver<T>[] = [];\n\n    const flush = () => {\n        while (pendingDequeue.length && queue.length) {\n            const resolver = pendingDequeue.shift()!;\n            resolver(queue.shift()!);\n        }\n        while (pendingEnqueue.length && queue.length < capacity) {\n            const resolver = pendingEnqueue.shift()!;\n            resolver();\n        }\n    };\n\n    return {\n        enqueue(value: T) {\n            if (queue.length < capacity && pendingDequeue.length === 0) {\n                queue.push(value);\n                flush();\n                return Promise.resolve();\n            }\n            return new Promise<void>(resolve => {\n                pendingEnqueue.push(() => {\n                    queue.push(value);\n                    resolve();\n                    flush();\n                });\n            });\n        },\n        dequeue() {\n            if (queue.length) {\n                const value = queue.shift()!;\n                flush();\n                return Promise.resolve(value);\n            }\n            return new Promise<T>(resolve => {\n                pendingDequeue.push(resolve);\n            });\n        },\n        size() {\n            return queue.length;\n        }\n    };\n}", "assertions": "const q = boundedQueue<number>(1);\nq.enqueue(1).then(() => q.dequeue().then(value => {\n    if (value !== 1) throw new Error('Incorrect dequeue');\n}));", "metadata": {"language": "TypeScript", "function_name": "boundedQueue", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.92}}
{"query_id": "synthetic-019", "query_text": "Write a Go function named `MedianStream` that maintains a running median with `Add` and `Median` methods using two heaps. Language: Go. Function name: MedianStream", "reference_answer": "package main\n\nimport (\n    \"container/heap\"\n)\n\ntype maxHeap []int\n\nfunc (h maxHeap) Len() int            { return len(h) }\nfunc (h maxHeap) Less(i, j int) bool  { return h[i] > h[j] }\nfunc (h maxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *maxHeap) Push(x any)         { *h = append(*h, x.(int)) }\nfunc (h *maxHeap) Pop() any {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[:n-1]\n    return x\n}\n\ntype minHeap []int\n\nfunc (h minHeap) Len() int            { return len(h) }\nfunc (h minHeap) Less(i, j int) bool  { return h[i] < h[j] }\nfunc (h minHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *minHeap) Push(x any)         { *h = append(*h, x.(int)) }\nfunc (h *minHeap) Pop() any {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[:n-1]\n    return x\n}\n\ntype MedianStream struct {\n    low  maxHeap\n    high minHeap\n}\n\nfunc NewMedianStream() *MedianStream {\n    return &MedianStream{}\n}\n\nfunc (ms *MedianStream) rebalance() {\n    if ms.low.Len() > ms.high.Len()+1 {\n        heap.Push(&ms.high, heap.Pop(&ms.low))\n    } else if ms.high.Len() > ms.low.Len() {\n        heap.Push(&ms.low, heap.Pop(&ms.high))\n    }\n}\n\nfunc (ms *MedianStream) Add(num int) {\n    if ms.low.Len() == 0 || num <= ms.low[0] {\n        heap.Push(&ms.low, num)\n    } else {\n        heap.Push(&ms.high, num)\n    }\n    ms.rebalance()\n}\n\nfunc (ms *MedianStream) Median() float64 {\n    if ms.low.Len() == ms.high.Len() {\n        return float64(ms.low[0]+ms.high[0]) / 2.0\n    }\n    return float64(ms.low[0])\n}", "assertions": "ms := NewMedianStream()\nms.Add(1)\nms.Add(2)\nif ms.Median() != 1.5 {\n    panic(\"Median incorrect\")\n}\nms.Add(3)\nif ms.Median() != 2 {\n    panic(\"Median incorrect\")\n}", "metadata": {"language": "Go", "function_name": "MedianStream", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.93}}
{"query_id": "synthetic-020", "query_text": "Write a C++ function named `LongestArithmeticSubsequence` that returns the length of the longest arithmetic subsequence in a vector of integers using dynamic programming. Language: C++. Function name: LongestArithmeticSubsequence", "reference_answer": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint LongestArithmeticSubsequence(const vector<int>& nums) {\n    if (nums.size() < 2) return nums.size();\n    int result = 2;\n    vector<unordered_map<int, int>> dp(nums.size());\n    for (size_t i = 0; i < nums.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            long diffLong = static_cast<long>(nums[i]) - nums[j];\n            if (diffLong < INT_MIN || diffLong > INT_MAX) continue;\n            int diff = static_cast<int>(diffLong);\n            int length = dp[j].count(diff) ? dp[j][diff] + 1 : 2;\n            dp[i][diff] = max(dp[i][diff], length);\n            result = max(result, dp[i][diff]);\n        }\n    }\n    return result;\n}", "assertions": "vector<int> v1 = {3, 6, 9, 12};\nif (LongestArithmeticSubsequence(v1) != 4) throw runtime_error(\"Failed\");\nvector<int> v2 = {9, 4, 7, 2, 10};\nif (LongestArithmeticSubsequence(v2) != 3) throw runtime_error(\"Failed\");\nvector<int> v3 = {20, 1, 15, 3, 10, 5, 8};\nif (LongestArithmeticSubsequence(v3) != 4) throw runtime_error(\"Failed\");", "metadata": {"language": "C++", "function_name": "LongestArithmeticSubsequence", "difficulty": "very_advanced", "category": "dynamic_programming", "complexity": 0.9}}
{"query_id": "synthetic-021", "query_text": "Write a Python function named `rotate_linked_list` that rotates a singly linked list to the right by k positions and returns the new head. List nodes contain `val` and `next`. Language: Python. Function name: rotate_linked_list", "reference_answer": "class ListNode:\n    def __init__(self, val: int = 0, next: 'ListNode | None' = None):\n        self.val = val\n        self.next = next\n\ndef rotate_linked_list(head: 'ListNode | None', k: int) -> 'ListNode | None':\n    if not head or not head.next or k == 0:\n        return head\n    tail = head\n    length = 1\n    while tail.next:\n        tail = tail.next\n        length += 1\n    tail.next = head\n    k %= length\n    steps_to_new_tail = length - k - 1\n    new_tail = head\n    for _ in range(steps_to_new_tail):\n        new_tail = new_tail.next\n    new_head = new_tail.next\n    new_tail.next = None\n    return new_head", "assertions": "nodes = [ListNode(i) for i in range(1, 6)]\nfor i in range(4):\n    nodes[i].next = nodes[i + 1]\nrotated = rotate_linked_list(nodes[0], 2)\nvalues = []\nwhile rotated:\n    values.append(rotated.val)\n    rotated = rotated.next\nassert values == [4, 5, 1, 2, 3]", "metadata": {"language": "Python", "function_name": "rotate_linked_list", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-022", "query_text": "Write a Python function named `strongly_connected_components` that returns all strongly connected components of a directed graph using Kosaraju's algorithm. Language: Python. Function name: strongly_connected_components", "reference_answer": "from typing import Dict, List\n\ndef strongly_connected_components(graph: Dict[int, List[int]]) -> List[List[int]]:\n    visited: set[int] = set()\n    order: List[int] = []\n\n    def dfs(node: int) -> None:\n        visited.add(node)\n        for nei in graph.get(node, []):\n            if nei not in visited:\n                dfs(nei)\n        order.append(node)\n\n    for node in graph:\n        if node not in visited:\n            dfs(node)\n\n    transpose: Dict[int, List[int]] = {}\n    for u, neighbors in graph.items():\n        for v in neighbors:\n            transpose.setdefault(v, []).append(u)\n        transpose.setdefault(u, transpose.get(u, []))\n\n    visited.clear()\n    components: List[List[int]] = []\n\n    def dfs_rev(node: int, acc: List[int]) -> None:\n        visited.add(node)\n        acc.append(node)\n        for nei in transpose.get(node, []):\n            if nei not in visited:\n                dfs_rev(nei, acc)\n\n    for node in reversed(order):\n        if node not in visited:\n            comp: List[int] = []\n            dfs_rev(node, comp)\n            components.append(comp)\n    return components", "assertions": "g = {0: [1], 1: [2], 2: [0, 3], 3: [4], 4: []}\ncomps = strongly_connected_components(g)\nassert any(set(comp) == {0, 1, 2} for comp in comps)\nassert any(set(comp) == {3} for comp in comps)", "metadata": {"language": "Python", "function_name": "strongly_connected_components", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.86}}
{"query_id": "synthetic-023", "query_text": "Write a Python function named `set_matrix_zeroes` that given a matrix sets rows and columns to zero if an element is zero, doing it in-place with constant extra space. Language: Python. Function name: set_matrix_zeroes", "reference_answer": "def set_matrix_zeroes(matrix: list[list[int]]) -> list[list[int]]:\n    if not matrix:\n        return matrix\n    rows, cols = len(matrix), len(matrix[0])\n    first_row_zero = any(matrix[0][j] == 0 for j in range(cols))\n    first_col_zero = any(matrix[i][0] == 0 for i in range(rows))\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][j] == 0:\n                matrix[i][0] = matrix[0][j] = 0\n    for i in range(1, rows):\n        if matrix[i][0] == 0:\n            for j in range(cols):\n                matrix[i][j] = 0\n    for j in range(1, cols):\n        if matrix[0][j] == 0:\n            for i in range(rows):\n                matrix[i][j] = 0\n    if first_row_zero:\n        for j in range(cols):\n            matrix[0][j] = 0\n    if first_col_zero:\n        for i in range(rows):\n            matrix[i][0] = 0\n    return matrix", "assertions": "m = [[1,1,1],[1,0,1],[1,1,1]]\nassert set_matrix_zeroes(m) == [[1,0,1],[0,0,0],[1,0,1]]\nassert set_matrix_zeroes([]) == []", "metadata": {"language": "Python", "function_name": "set_matrix_zeroes", "difficulty": "medium", "category": "matrix", "complexity": 0.47}}
{"query_id": "synthetic-024", "query_text": "Write a Python function named `kth_smallest_in_bst` that returns the kth smallest value in a binary search tree using iterative inorder traversal. Language: Python. Function name: kth_smallest_in_bst", "reference_answer": "class TreeNode:\n    def __init__(self, val: int, left: 'TreeNode | None' = None, right: 'TreeNode | None' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef kth_smallest_in_bst(root: 'TreeNode | None', k: int) -> int:\n    stack: list[TreeNode] = []\n    current = root\n    while True:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        k -= 1\n        if k == 0:\n            return current.val\n        current = current.right", "assertions": "root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(6))\nassert kth_smallest_in_bst(root, 1) == 2\nassert kth_smallest_in_bst(root, 3) == 4", "metadata": {"language": "Python", "function_name": "kth_smallest_in_bst", "difficulty": "advanced", "category": "data_structures", "complexity": 0.62}}
{"query_id": "synthetic-025", "query_text": "Write a TypeScript class named `EventEmitter` that supports `on`, `off`, and `emit` methods for registering and triggering event listeners. Language: TypeScript. Function name: EventEmitter", "reference_answer": "type Listener = (...args: any[]) => void;\n\nexport class EventEmitter {\n    private listeners: Map<string, Set<Listener>> = new Map();\n    on(event: string, listener: Listener) {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        this.listeners.get(event)!.add(listener);\n    }\n    off(event: string, listener: Listener) {\n        this.listeners.get(event)?.delete(listener);\n    }\n    emit(event: string, ...args: any[]) {\n        this.listeners.get(event)?.forEach(listener => listener(...args));\n    }\n}", "assertions": "const emitter = new EventEmitter();\nlet called = 0;\nconst handler = () => { called += 1; };\nemitter.on('ping', handler);\nemitter.emit('ping');\nemitter.off('ping', handler);\nemitter.emit('ping');\nif (called !== 1) throw new Error('EventEmitter failed');", "metadata": {"language": "TypeScript", "function_name": "EventEmitter", "difficulty": "medium", "category": "design_patterns", "complexity": 0.4}}
{"query_id": "synthetic-026", "query_text": "Write a TypeScript function named `composeAsync` that composes asynchronous functions right-to-left, returning a new function that resolves sequentially. Language: TypeScript. Function name: composeAsync", "reference_answer": "export function composeAsync<T>(...fns: Array<(arg: T) => Promise<T>>): (input: T) => Promise<T> {\n    return async (input: T) => {\n        let result = input;\n        for (let i = fns.length - 1; i >= 0; i -= 1) {\n            result = await fns[i](result);\n        }\n        return result;\n    };\n}", "assertions": "const addOne = async (n: number) => n + 1;\nconst double = async (n: number) => n * 2;\ncomposeAsync(addOne, double)(3).then(result => {\n    if (result !== 7) throw new Error('composeAsync failed');\n});", "metadata": {"language": "TypeScript", "function_name": "composeAsync", "difficulty": "advanced", "category": "functional_programming", "complexity": 0.6}}
{"query_id": "synthetic-027", "query_text": "Write a TypeScript function named `createPromisePool` that runs at most `concurrency` promises at the same time given an array of async factories, resolving with all results. Language: TypeScript. Function name: createPromisePool", "reference_answer": "export async function createPromisePool<T>(factories: Array<() => Promise<T>>, concurrency: number): Promise<T[]> {\n    const results: T[] = new Array(factories.length);\n    let index = 0;\n    let active = 0;\n    return new Promise((resolve, reject) => {\n        const startNext = () => {\n            if (index === factories.length && active === 0) {\n                resolve(results);\n                return;\n            }\n            while (active < concurrency && index < factories.length) {\n                const current = index;\n                const factory = factories[index++];\n                active += 1;\n                factory()\n                    .then(value => {\n                        results[current] = value;\n                        active -= 1;\n                        startNext();\n                    })\n                    .catch(reject);\n            }\n        };\n        startNext();\n    });\n}", "assertions": "const factories = [\n    () => Promise.resolve(1),\n    () => Promise.resolve(2),\n    () => Promise.resolve(3)\n];\ncreatePromisePool(factories, 2).then(values => {\n    if (values.reduce((a, b) => a + b, 0) !== 6) throw new Error('Pool failed');\n});", "metadata": {"language": "TypeScript", "function_name": "createPromisePool", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.88}}
{"query_id": "synthetic-028", "query_text": "Write a TypeScript function named `diffObjects` that returns the paths where two JSON objects differ, producing an array of dot-delimited strings. Language: TypeScript. Function name: diffObjects", "reference_answer": "type Json = null | boolean | number | string | Json[] | { [key: string]: Json };\n\nexport function diffObjects(a: Json, b: Json, prefix = ''): string[] {\n    if (a === b) return [];\n    if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {\n        return [prefix || 'root'];\n    }\n    const keys = new Set([...Object.keys(a as any), ...Object.keys(b as any)]);\n    const diffs: string[] = [];\n    keys.forEach(key => {\n        const next = prefix ? `${prefix}.${key}` : key;\n        diffs.push(...diffObjects((a as any)[key], (b as any)[key], next));\n    });\n    return diffs;\n}", "assertions": "const a = { a: 1, b: { c: 2 } };\nconst bObj = { a: 1, b: { c: 3 }, d: 4 };\nconst diffs = diffObjects(a, bObj);\nif (!diffs.includes('b.c') || !diffs.includes('d')) throw new Error('diffObjects failed');", "metadata": {"language": "TypeScript", "function_name": "diffObjects", "difficulty": "advanced", "category": "data_processing", "complexity": 0.63}}
{"query_id": "synthetic-029", "query_text": "Write a Go struct named `RollingHash` with methods `Add` and `CurrentHash` implementing a fixed-size rolling hash for lowercase letters using base 26. Language: Go. Function name: RollingHash", "reference_answer": "package main\n\ntype RollingHash struct {\n    base int\n    mod  int\n    size int\n    pow  int\n    hash int\n    queue []int\n}\n\nfunc NewRollingHash(window int, mod int) *RollingHash {\n    pow := 1\n    base := 26\n    for i := 0; i < window-1; i++ {\n        pow = (pow * base) % mod\n    }\n    return &RollingHash{base: base, mod: mod, size: window, pow: pow}\n}\n\nfunc (rh *RollingHash) Add(ch rune) {\n    value := int(ch-'a')\n    if len(rh.queue) == rh.size {\n        removed := rh.queue[0]\n        rh.queue = rh.queue[1:]\n        rh.hash = (rh.hash - removed*rh.pow) % rh.mod\n        if rh.hash < 0 {\n            rh.hash += rh.mod\n        }\n    }\n    rh.queue = append(rh.queue, value)\n    rh.hash = (rh.hash*rh.base + value) % rh.mod\n}\n\nfunc (rh *RollingHash) CurrentHash() int {\n    return rh.hash\n}", "assertions": "rh := NewRollingHash(3, 1_000_003)\nrh.Add('a')\nrh.Add('b')\nrh.Add('c')\nfirst := rh.CurrentHash()\nrh.Add('d')\nsecond := rh.CurrentHash()\nif first == second {\n    panic(\"Rolling hash should change\")\n}", "metadata": {"language": "Go", "function_name": "RollingHash", "difficulty": "medium", "category": "algorithms", "complexity": 0.55}}
{"query_id": "synthetic-030", "query_text": "Write a Kotlin function named `balancedParentheses` that returns true if a string of brackets is balanced using a stack. Language: Kotlin. Function name: balancedParentheses", "reference_answer": "fun balancedParentheses(s: String): Boolean {\n    val stack = ArrayDeque<Char>()\n    val pairs = mapOf(')' to '(', '}' to '{', ']' to '[')\n    for (ch in s) {\n        if (ch in pairs.values) {\n            stack.addLast(ch)\n        } else {\n            val expected = pairs[ch] ?: return false\n            if (stack.removeLastOrNull() != expected) return false\n        }\n    }\n    return stack.isEmpty()\n}", "assertions": "check(balancedParentheses(\"(){}[]\"))\ncheck(!balancedParentheses(\"(]\"))\ncheck(balancedParentheses(\"\"))", "metadata": {"language": "Kotlin", "function_name": "balancedParentheses", "difficulty": "medium", "category": "data_structures", "complexity": 0.42}}
{"query_id": "synthetic-031", "query_text": "Write a Python function named `merge_k_sorted_lists` that merges k sorted linked lists into one sorted list using a min-heap. Nodes contain `val` and `next`. Language: Python. Function name: merge_k_sorted_lists", "reference_answer": "import heapq\nfrom typing import List\n\nclass ListNode:\n    def __init__(self, val: int = 0, next: 'ListNode | None' = None):\n        self.val = val\n        self.next = next\n    def __lt__(self, other: 'ListNode') -> bool:\n        return self.val < other.val\n\ndef merge_k_sorted_lists(lists: List['ListNode | None']) -> 'ListNode | None':\n    heap: list[tuple[int, int, ListNode]] = []\n    for idx, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, idx, node))\n    dummy = ListNode(0)\n    tail = dummy\n    while heap:\n        _, idx, node = heapq.heappop(heap)\n        tail.next = node\n        tail = tail.next\n        if node.next:\n            heapq.heappush(heap, (node.next.val, idx, node.next))\n    return dummy.next", "assertions": "a1 = ListNode(1, ListNode(4, ListNode(5)))\na2 = ListNode(1, ListNode(3, ListNode(4)))\na3 = ListNode(2, ListNode(6))\nmerged = merge_k_sorted_lists([a1, a2, a3])\nvalues = []\nwhile merged:\n    values.append(merged.val)\n    merged = merged.next\nassert values == [1,1,2,3,4,4,5,6]", "metadata": {"language": "Python", "function_name": "merge_k_sorted_lists", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.85}}
{"query_id": "synthetic-032", "query_text": "Write a Python function named `count_palindromic_substrings` that returns the number of palindromic substrings in a string using center expansion. Language: Python. Function name: count_palindromic_substrings", "reference_answer": "def count_palindromic_substrings(s: str) -> int:\n    def expand(left: int, right: int) -> int:\n        count = 0\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n        return count\n    total = 0\n    for i in range(len(s)):\n        total += expand(i, i)\n        total += expand(i, i + 1)\n    return total", "assertions": "assert count_palindromic_substrings('abc') == 3\nassert count_palindromic_substrings('aaa') == 6\nassert count_palindromic_substrings('') == 0", "metadata": {"language": "Python", "function_name": "count_palindromic_substrings", "difficulty": "medium", "category": "string_algorithms", "complexity": 0.41}}
{"query_id": "synthetic-033", "query_text": "Write a Python function named `minimum_window_subsequence` that returns the minimum window in `s` containing `t` as a subsequence using dynamic programming. Language: Python. Function name: minimum_window_subsequence", "reference_answer": "def minimum_window_subsequence(s: str, t: str) -> str:\n    m, n = len(s), len(t)\n    if n == 0:\n        return \"\"\n    dp = [[-1] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    start, length = 0, float('inf')\n    for i in range(1, m + 1):\n        if dp[i][n] != -1:\n            window = i - dp[i][n]\n            if window < length:\n                start = dp[i][n]\n                length = window\n    return \"\" if length == float('inf') else s[start:start + length]", "assertions": "assert minimum_window_subsequence('abcdebdde', 'bde') == 'bcde'\nassert minimum_window_subsequence('abc', 'd') == ''", "metadata": {"language": "Python", "function_name": "minimum_window_subsequence", "difficulty": "very_advanced", "category": "dynamic_programming", "complexity": 0.9}}
{"query_id": "synthetic-034", "query_text": "Write a Python class named `ReservoirSampler` with a method `sample` that returns a random sample of k items from a stream using reservoir sampling. Language: Python. Function name: ReservoirSampler", "reference_answer": "import random\nfrom typing import Iterable, List, TypeVar\nT = TypeVar('T')\n\nclass ReservoirSampler:\n    def __init__(self, k: int):\n        self.k = k\n\n    def sample(self, stream: Iterable[T]) -> List[T]:\n        reservoir: List[T] = []\n        for i, item in enumerate(stream):\n            if i < self.k:\n                reservoir.append(item)\n            else:\n                j = random.randint(0, i)\n                if j < self.k:\n                    reservoir[j] = item\n        return reservoir", "assertions": "sampler = ReservoirSampler(3)\nresult = sampler.sample(range(10))\nassert len(result) == 3", "metadata": {"language": "Python", "function_name": "ReservoirSampler", "difficulty": "advanced", "category": "probabilistic_algorithms", "complexity": 0.64}}
{"query_id": "synthetic-035", "query_text": "Write a TypeScript class named `LRUCache` that implements a fixed-capacity least recently used cache with `get` and `put` in O(1) time using a doubly linked list and map. Language: TypeScript. Function name: LRUCache", "reference_answer": "type Node = { key: number; value: number; prev?: Node; next?: Node };\n\nexport class LRUCache {\n    private map = new Map<number, Node>();\n    private head: Node;\n    private tail: Node;\n    constructor(private capacity: number) {\n        this.head = { key: -1, value: -1 };\n        this.tail = { key: -1, value: -1 };\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n    }\n    private detach(node: Node) {\n        node.prev!.next = node.next;\n        node.next!.prev = node.prev;\n    }\n    private attach(node: Node) {\n        node.next = this.head.next;\n        node.prev = this.head;\n        this.head.next!.prev = node;\n        this.head.next = node;\n    }\n    get(key: number): number {\n        const node = this.map.get(key);\n        if (!node) return -1;\n        this.detach(node);\n        this.attach(node);\n        return node.value;\n    }\n    put(key: number, value: number): void {\n        if (this.map.has(key)) {\n            const node = this.map.get(key)!;\n            node.value = value;\n            this.detach(node);\n            this.attach(node);\n            return;\n        }\n        if (this.map.size === this.capacity) {\n            const lru = this.tail.prev!;\n            this.detach(lru);\n            this.map.delete(lru.key);\n        }\n        const node: Node = { key, value };\n        this.map.set(key, node);\n        this.attach(node);\n    }\n}", "assertions": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\nif (cache.get(1) !== 1) throw new Error('LRU failed');\ncache.put(3, 3);\nif (cache.get(2) !== -1) throw new Error('LRU eviction failed');", "metadata": {"language": "TypeScript", "function_name": "LRUCache", "difficulty": "advanced", "category": "data_structures", "complexity": 0.78}}
{"query_id": "synthetic-036", "query_text": "Write a TypeScript class named `BinaryMinHeap` supporting `insert`, `peek`, and `extractMin` operations for numbers. Language: TypeScript. Function name: BinaryMinHeap", "reference_answer": "export class BinaryMinHeap {\n    private data: number[] = [];\n    insert(value: number) {\n        this.data.push(value);\n        this.bubbleUp(this.data.length - 1);\n    }\n    peek(): number | undefined {\n        return this.data[0];\n    }\n    extractMin(): number | undefined {\n        if (!this.data.length) return undefined;\n        const min = this.data[0];\n        const end = this.data.pop()!;\n        if (this.data.length) {\n            this.data[0] = end;\n            this.bubbleDown(0);\n        }\n        return min;\n    }\n    private bubbleUp(index: number) {\n        while (index > 0) {\n            const parent = Math.floor((index - 1) / 2);\n            if (this.data[parent] <= this.data[index]) break;\n            [this.data[parent], this.data[index]] = [this.data[index], this.data[parent]];\n            index = parent;\n        }\n    }\n    private bubbleDown(index: number) {\n        const length = this.data.length;\n        while (true) {\n            let left = 2 * index + 1;\n            let right = 2 * index + 2;\n            let smallest = index;\n            if (left < length && this.data[left] < this.data[smallest]) smallest = left;\n            if (right < length && this.data[right] < this.data[smallest]) smallest = right;\n            if (smallest === index) break;\n            [this.data[index], this.data[smallest]] = [this.data[smallest], this.data[index]];\n            index = smallest;\n        }\n    }\n}", "assertions": "const heap = new BinaryMinHeap();\nheap.insert(5);\nheap.insert(3);\nheap.insert(7);\nif (heap.extractMin() !== 3) throw new Error('Heap failed');\nif (heap.peek() !== 5) throw new Error('Peek failed');", "metadata": {"language": "TypeScript", "function_name": "BinaryMinHeap", "difficulty": "medium", "category": "data_structures", "complexity": 0.44}}
{"query_id": "synthetic-037", "query_text": "Write a TypeScript function named `createSignal` that implements a minimal reactive signal with `get`, `set`, and `subscribe` methods notifying subscribers on change. Language: TypeScript. Function name: createSignal", "reference_answer": "type Subscriber<T> = (value: T) => void;\n\nexport function createSignal<T>(initial: T) {\n    let value = initial;\n    const subscribers = new Set<Subscriber<T>>();\n    return {\n        get: () => value,\n        set: (next: T) => {\n            if (Object.is(value, next)) return;\n            value = next;\n            subscribers.forEach(fn => fn(value));\n        },\n        subscribe: (fn: Subscriber<T>) => {\n            subscribers.add(fn);\n            fn(value);\n            return () => subscribers.delete(fn);\n        }\n    };\n}", "assertions": "const signal = createSignal(0);\nlet seen: number[] = [];\nconst unsubscribe = signal.subscribe(v => seen.push(v));\nsignal.set(1);\nunsubscribe();\nsignal.set(2);\nif (JSON.stringify(seen) !== JSON.stringify([0, 1])) throw new Error('Signal failed');", "metadata": {"language": "TypeScript", "function_name": "createSignal", "difficulty": "advanced", "category": "reactivity", "complexity": 0.67}}
{"query_id": "synthetic-038", "query_text": "Write a TypeScript function named `applyPatch` that applies a JSON Patch (RFC 6902) operation array to an object supporting `add`, `remove`, and `replace`. Language: TypeScript. Function name: applyPatch", "reference_answer": "type PatchOperation = { op: 'add' | 'remove' | 'replace'; path: string; value?: any };\n\nexport function applyPatch<T extends object>(target: T, ops: PatchOperation[]): T {\n    const getRef = (path: string) => {\n        const segments = path.split('/').slice(1);\n        let parent: any = target;\n        for (let i = 0; i < segments.length - 1; i++) {\n            const key = segments[i];\n            if (!(key in parent)) parent[key] = {};\n            parent = parent[key];\n        }\n        return { parent, key: segments[segments.length - 1] };\n    };\n    ops.forEach(op => {\n        const { parent, key } = getRef(op.path);\n        if (op.op === 'add' || op.op === 'replace') {\n            parent[key] = op.value;\n        } else if (op.op === 'remove') {\n            delete parent[key];\n        }\n    });\n    return target;\n}", "assertions": "const obj = { foo: { bar: 1 } };\napplyPatch(obj, [\n    { op: 'replace', path: '/foo/bar', value: 2 },\n    { op: 'add', path: '/foo/baz', value: 3 }\n]);\nif (obj.foo.bar !== 2 || obj.foo.baz !== 3) throw new Error('Patch failed');", "metadata": {"language": "TypeScript", "function_name": "applyPatch", "difficulty": "very_advanced", "category": "data_processing", "complexity": 0.82}}
{"query_id": "synthetic-039", "query_text": "Write a Go struct named `UnionFind` with `Find`, `Union`, and `Connected` methods implementing union-find with path compression and union by rank. Language: Go. Function name: UnionFind", "reference_answer": "package main\n\ntype UnionFind struct {\n    parent []int\n    rank   []int\n}\n\nfunc NewUnionFind(n int) *UnionFind {\n    parent := make([]int, n)\n    rank := make([]int, n)\n    for i := range parent {\n        parent[i] = i\n    }\n    return &UnionFind{parent: parent, rank: rank}\n}\n\nfunc (uf *UnionFind) Find(x int) int {\n    if uf.parent[x] != x {\n        uf.parent[x] = uf.Find(uf.parent[x])\n    }\n    return uf.parent[x]\n}\n\nfunc (uf *UnionFind) Union(a, b int) {\n    rootA := uf.Find(a)\n    rootB := uf.Find(b)\n    if rootA == rootB {\n        return\n    }\n    if uf.rank[rootA] < uf.rank[rootB] {\n        uf.parent[rootA] = rootB\n    } else if uf.rank[rootA] > uf.rank[rootB] {\n        uf.parent[rootB] = rootA\n    } else {\n        uf.parent[rootB] = rootA\n        uf.rank[rootA]++\n    }\n}\n\nfunc (uf *UnionFind) Connected(a, b int) bool {\n    return uf.Find(a) == uf.Find(b)\n}", "assertions": "uf := NewUnionFind(5)\nuf.Union(0, 1)\nuf.Union(1, 2)\nif !uf.Connected(0, 2) {\n    panic(\"UnionFind failed\")\n}\nif uf.Connected(0, 4) {\n    panic(\"Incorrect connectivity\")\n}", "metadata": {"language": "Go", "function_name": "UnionFind", "difficulty": "advanced", "category": "data_structures", "complexity": 0.6}}
{"query_id": "synthetic-040", "query_text": "Write a Swift function named `topKFrequent` that returns the k most frequent integers from an array using a min-heap. Language: Swift. Function name: topKFrequent", "reference_answer": "import Foundation\n\nfunc topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n    var counts: [Int: Int] = [:]\n    nums.forEach { counts[$0, default: 0] += 1 }\n    var heap: [(Int, Int)] = [] // (frequency, value)\n    func heapifyUp(_ index: Int) {\n        var i = index\n        while i > 0 {\n            let parent = (i - 1) / 2\n            if heap[parent].0 <= heap[i].0 { break }\n            heap.swapAt(parent, i)\n            i = parent\n        }\n    }\n    func heapifyDown(_ index: Int) {\n        var i = index\n        while true {\n            let left = 2 * i + 1\n            let right = 2 * i + 2\n            var smallest = i\n            if left < heap.count && heap[left].0 < heap[smallest].0 { smallest = left }\n            if right < heap.count && heap[right].0 < heap[smallest].0 { smallest = right }\n            if smallest == i { break }\n            heap.swapAt(i, smallest)\n            i = smallest\n        }\n    }\n    for (value, freq) in counts {\n        heap.append((freq, value))\n        heapifyUp(heap.count - 1)\n        if heap.count > k {\n            heap[0] = heap[heap.count - 1]\n            heap.removeLast()\n            heapifyDown(0)\n        }\n    }\n    return heap.map { $0.1 }\n}", "assertions": "let result = topKFrequent([1,1,1,2,2,3], 2)\nassert(result.contains(1) && result.contains(2))\nassert(topKFrequent([], 1).isEmpty)", "metadata": {"language": "Swift", "function_name": "topKFrequent", "difficulty": "advanced", "category": "heap_algorithms", "complexity": 0.66}}
{"query_id": "synthetic-041", "query_text": "Write a Python function named `max_sliding_window` that returns the maximum of each sliding window of size k using a deque for O(n) complexity. Language: Python. Function name: max_sliding_window", "reference_answer": "from collections import deque\n\ndef max_sliding_window(nums: list[int], k: int) -> list[int]:\n    if k == 0 or not nums:\n        return []\n    dq: deque[int] = deque()\n    result: list[int] = []\n    for i, num in enumerate(nums):\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        while dq and nums[dq[-1]] <= num:\n            dq.pop()\n        dq.append(i)\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    return result", "assertions": "assert max_sliding_window([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7]\nassert max_sliding_window([], 3) == []\nassert max_sliding_window([1], 1) == [1]", "metadata": {"language": "Python", "function_name": "max_sliding_window", "difficulty": "advanced", "category": "data_structures", "complexity": 0.63}}
{"query_id": "synthetic-042", "query_text": "Write a Python function named `word_ladder_length` that returns the length of the shortest transformation from beginWord to endWord by changing one letter at a time using BFS. Language: Python. Function name: word_ladder_length", "reference_answer": "from collections import defaultdict, deque\n\ndef word_ladder_length(begin: str, end: str, word_list: list[str]) -> int:\n    word_set = set(word_list)\n    if end not in word_set:\n        return 0\n    combos = defaultdict(list)\n    for word in word_set | {begin}:\n        for i in range(len(word)):\n            combos[word[:i] + '*' + word[i+1:]].append(word)\n    visited = {begin}\n    queue = deque([(begin, 1)])\n    while queue:\n        word, steps = queue.popleft()\n        if word == end:\n            return steps\n        for i in range(len(word)):\n            pattern = word[:i] + '*' + word[i+1:]\n            for nei in combos[pattern]:\n                if nei not in visited:\n                    visited.add(nei)\n                    queue.append((nei, steps + 1))\n            combos[pattern] = []\n    return 0", "assertions": "assert word_ladder_length('hit', 'cog', ['hot','dot','dog','lot','log','cog']) == 5\nassert word_ladder_length('hit', 'hit', ['hit']) == 1\nassert word_ladder_length('hit', 'cog', ['hot','dot']) == 0", "metadata": {"language": "Python", "function_name": "word_ladder_length", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.84}}
{"query_id": "synthetic-043", "query_text": "Write a Python function named `prefix_sum_matrix` that builds a 2D prefix sum matrix enabling O(1) region sum queries via a helper `sum_region`. Language: Python. Function name: prefix_sum_matrix", "reference_answer": "class PrefixSumMatrix:\n    def __init__(self, matrix: list[list[int]]):\n        if not matrix:\n            self.prefix = [[0]]\n            return\n        rows, cols = len(matrix), len(matrix[0])\n        self.prefix = [[0] * (cols + 1) for _ in range(rows + 1)]\n        for r in range(1, rows + 1):\n            for c in range(1, cols + 1):\n                self.prefix[r][c] = (\n                    matrix[r - 1][c - 1]\n                    + self.prefix[r - 1][c]\n                    + self.prefix[r][c - 1]\n                    - self.prefix[r - 1][c - 1]\n                )\n    def sum_region(self, r1: int, c1: int, r2: int, c2: int) -> int:\n        r1 += 1\n        c1 += 1\n        r2 += 1\n        c2 += 1\n        return (\n            self.prefix[r2][c2]\n            - self.prefix[r1 - 1][c2]\n            - self.prefix[r2][c1 - 1]\n            + self.prefix[r1 - 1][c1 - 1]\n        )", "assertions": "matrix = [\n    [3, 0, 1, 4, 2],\n    [5, 6, 3, 2, 1],\n    [1, 2, 0, 1, 5],\n    [4, 1, 0, 1, 7],\n    [1, 0, 3, 0, 5]\n]\nps = PrefixSumMatrix(matrix)\nassert ps.sum_region(2, 1, 4, 3) == 8\nassert ps.sum_region(1, 1, 2, 2) == 11", "metadata": {"language": "Python", "function_name": "prefix_sum_matrix", "difficulty": "medium", "category": "matrix", "complexity": 0.46}}
{"query_id": "synthetic-044", "query_text": "Write a Python class named `Codec` with methods `serialize` and `deserialize` that convert a binary tree to a string and back using level-order traversal. Language: Python. Function name: Codec", "reference_answer": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val: int = 0, left: 'TreeNode | None' = None, right: 'TreeNode | None' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root: 'TreeNode | None') -> str:\n        if not root:\n            return ''\n        queue = deque([root])\n        values: list[str] = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                values.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                values.append('#')\n        return ','.join(values)\n\n    def deserialize(self, data: str) -> 'TreeNode | None':\n        if not data:\n            return None\n        values = data.split(',')\n        root = TreeNode(int(values[0]))\n        queue = deque([root])\n        idx = 1\n        while queue and idx < len(values):\n            node = queue.popleft()\n            if values[idx] != '#':\n                node.left = TreeNode(int(values[idx]))\n                queue.append(node.left)\n            idx += 1\n            if idx < len(values) and values[idx] != '#':\n                node.right = TreeNode(int(values[idx]))\n                queue.append(node.right)\n            idx += 1\n        return root", "assertions": "root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\ncodec = Codec()\nserialized = codec.serialize(root)\nrebuilt = codec.deserialize(serialized)\nassert codec.serialize(rebuilt) == serialized", "metadata": {"language": "Python", "function_name": "Codec", "difficulty": "very_advanced", "category": "serialization", "complexity": 0.87}}
{"query_id": "synthetic-045", "query_text": "Write a TypeScript function named `throttle` that limits a function to execute at most once every `wait` milliseconds, invoking with the latest arguments. Language: TypeScript. Function name: throttle", "reference_answer": "export function throttle<T extends (...args: any[]) => void>(fn: T, wait: number) {\n    let lastCall = 0;\n    let timeout: NodeJS.Timeout | null = null;\n    let latestArgs: Parameters<T> | null = null;\n    const invoke = () => {\n        lastCall = Date.now();\n        timeout = null;\n        if (latestArgs) {\n            fn(...latestArgs);\n            latestArgs = null;\n        }\n    };\n    return (...args: Parameters<T>) => {\n        const now = Date.now();\n        const remaining = wait - (now - lastCall);\n        if (remaining <= 0) {\n            lastCall = now;\n            fn(...args);\n        } else {\n            latestArgs = args;\n            if (!timeout) {\n                timeout = setTimeout(invoke, remaining);\n            }\n        }\n    };\n}", "assertions": "let calls = 0;\nconst throttled = throttle(() => { calls += 1; }, 100);\nthrottled();\nthrottled();\nsetTimeout(() => {\n    if (calls > 2) throw new Error('Throttle failed');\n}, 250);", "metadata": {"language": "TypeScript", "function_name": "throttle", "difficulty": "medium", "category": "concurrency", "complexity": 0.43}}
{"query_id": "synthetic-046", "query_text": "Write a TypeScript function named `deepEqual` that performs a deep structural equality check between two JSON-compatible values. Language: TypeScript. Function name: deepEqual", "reference_answer": "type JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\n\nexport function deepEqual(a: JSONValue, b: JSONValue): boolean {\n    if (a === b) return true;\n    if (typeof a !== typeof b) return false;\n    if (a === null || b === null) return false;\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) return false;\n        return a.every((val, idx) => deepEqual(val, b[idx]));\n    }\n    if (typeof a === 'object' && typeof b === 'object') {\n        const keysA = Object.keys(a as object);\n        const keysB = Object.keys(b as object);\n        if (keysA.length !== keysB.length) return false;\n        return keysA.every(key => deepEqual((a as any)[key], (b as any)[key]));\n    }\n    return false;\n}", "assertions": "if (!deepEqual({ a: 1, b: [2, 3] }, { a: 1, b: [2, 3] })) throw new Error('deepEqual failed');\nif (deepEqual({ a: 1 }, { a: 2 })) throw new Error('deepEqual incorrect');", "metadata": {"language": "TypeScript", "function_name": "deepEqual", "difficulty": "advanced", "category": "data_processing", "complexity": 0.58}}
{"query_id": "synthetic-047", "query_text": "Write a TypeScript function named `batchRequests` that takes an array of URLs and fetches them in batches of size `batchSize`, returning responses in order. Language: TypeScript. Function name: batchRequests", "reference_answer": "export async function batchRequests(urls: string[], batchSize: number): Promise<Response[]> {\n    const results: Response[] = new Array(urls.length);\n    let index = 0;\n    while (index < urls.length) {\n        const chunk = urls.slice(index, index + batchSize);\n        const responses = await Promise.all(chunk.map((url) => fetch(url)));\n        for (let i = 0; i < responses.length; i++) {\n            results[index + i] = responses[i];\n        }\n        index += batchSize;\n    }\n    return results;\n}", "assertions": "const fakeFetch = async (url: string) => ({ url } as Response);\n(globalThis as any).fetch = fakeFetch;\nbatchRequests(['a','b','c'], 2).then(res => {\n    if (res[0].url !== 'a' || res[2].url !== 'c') throw new Error('Batch failed');\n});", "metadata": {"language": "TypeScript", "function_name": "batchRequests", "difficulty": "advanced", "category": "networking", "complexity": 0.62}}
{"query_id": "synthetic-048", "query_text": "Write a TypeScript function named `createStateMachine` that builds a deterministic finite automaton given states, transitions, and actions, returning an object with `dispatch` and `state`. Language: TypeScript. Function name: createStateMachine", "reference_answer": "type Transition<S extends string, E extends string> = {\n    from: S;\n    event: E;\n    to: S;\n    action?: () => void;\n};\n\nexport function createStateMachine<S extends string, E extends string>(initial: S, transitions: Transition<S, E>[]) {\n    const map = new Map<string, Transition<S, E>>();\n    transitions.forEach(t => {\n        map.set(`${t.from}:${t.event}`, t);\n    });\n    let current = initial;\n    return {\n        get state() {\n            return current;\n        },\n        dispatch(event: E) {\n            const key = `${current}:${event}`;\n            const transition = map.get(key);\n            if (!transition) throw new Error('Invalid transition');\n            transition.action?.();\n            current = transition.to;\n            return current;\n        }\n    };\n}", "assertions": "const machine = createStateMachine('idle', [\n    { from: 'idle', event: 'start', to: 'running' },\n    { from: 'running', event: 'stop', to: 'idle' }\n]);\nif (machine.dispatch('start') !== 'running') throw new Error('State machine failed');\nif (machine.dispatch('stop') !== 'idle') throw new Error('State machine failed');", "metadata": {"language": "TypeScript", "function_name": "createStateMachine", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.81}}
{"query_id": "synthetic-049", "query_text": "Write a Rust function named `sliding_window_max` that returns the maximum for each window of size k over a vector using a deque. Language: Rust. Function name: sliding_window_max", "reference_answer": "use std::collections::VecDeque;\n\npub fn sliding_window_max(nums: &[i32], k: usize) -> Vec<i32> {\n    if k == 0 || nums.is_empty() {\n        return Vec::new();\n    }\n    let mut dq: VecDeque<usize> = VecDeque::new();\n    let mut result = Vec::with_capacity(nums.len().saturating_sub(k) + 1);\n    for (i, &num) in nums.iter().enumerate() {\n        if let Some(&front) = dq.front() {\n            if front + k <= i {\n                dq.pop_front();\n            }\n        }\n        while let Some(&back) = dq.back() {\n            if nums[back] <= num {\n                dq.pop_back();\n            } else {\n                break;\n            }\n        }\n        dq.push_back(i);\n        if i + 1 >= k {\n            result.push(nums[*dq.front().unwrap()]);\n        }\n    }\n    result\n}", "assertions": "assert_eq!(sliding_window_max(&[1,3,-1,-3,5,3,6,7], 3), vec![3,3,5,5,6,7]);\nassert!(sliding_window_max(&[], 3).is_empty());", "metadata": {"language": "Rust", "function_name": "sliding_window_max", "difficulty": "advanced", "category": "data_structures", "complexity": 0.69}}
{"query_id": "synthetic-050", "query_text": "Write a JavaScript function named `groupBy` that groups array elements by the provided iteratee function, returning an object of arrays. Language: JavaScript. Function name: groupBy", "reference_answer": "function groupBy(collection, iteratee) {\n    return collection.reduce((acc, item) => {\n        const key = iteratee(item);\n        if (!acc[key]) acc[key] = [];\n        acc[key].push(item);\n        return acc;\n    }, {});\n}", "assertions": "const grouped = groupBy([1,2,3,4], n => (n % 2 === 0 ? 'even' : 'odd'));\nif (grouped.even.length !== 2 || grouped.odd.length !== 2) throw new Error('groupBy failed');", "metadata": {"language": "JavaScript", "function_name": "groupBy", "difficulty": "medium", "category": "data_processing", "complexity": 0.38}}
{"query_id": "synthetic-051", "query_text": "Write a Python function named `vertical_order_traversal` that returns the vertical order traversal of a binary tree using BFS with column indices. Language: Python. Function name: vertical_order_traversal", "reference_answer": "from collections import deque, defaultdict\n\nclass TreeNode:\n    def __init__(self, val: int = 0, left: 'TreeNode | None' = None, right: 'TreeNode | None' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef vertical_order_traversal(root: 'TreeNode | None') -> list[list[int]]:\n    if not root:\n        return []\n    column_table: dict[int, list[int]] = defaultdict(list)\n    queue = deque([(root, 0)])\n    min_col = max_col = 0\n    while queue:\n        node, col = queue.popleft()\n        column_table[col].append(node.val)\n        min_col = min(min_col, col)\n        max_col = max(max_col, col)\n        if node.left:\n            queue.append((node.left, col - 1))\n        if node.right:\n            queue.append((node.right, col + 1))\n    return [column_table[c] for c in range(min_col, max_col + 1)]", "assertions": "root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\nassert vertical_order_traversal(root) == [[9], [3, 15], [20], [7]]\nassert vertical_order_traversal(None) == []", "metadata": {"language": "Python", "function_name": "vertical_order_traversal", "difficulty": "advanced", "category": "tree_algorithms", "complexity": 0.66}}
{"query_id": "synthetic-052", "query_text": "Write a Python class named `BitwiseTrie` that supports `insert` and `max_xor` to find the maximum XOR of a number with previously inserted numbers. Language: Python. Function name: BitwiseTrie", "reference_answer": "class TrieNode:\n    def __init__(self):\n        self.children: dict[int, 'TrieNode'] = {}\n\nclass BitwiseTrie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num: int) -> None:\n        node = self.root\n        for i in reversed(range(32)):\n            bit = (num >> i) & 1\n            node = node.children.setdefault(bit, TrieNode())\n\n    def max_xor(self, num: int) -> int:\n        node = self.root\n        xor = 0\n        for i in reversed(range(32)):\n            bit = (num >> i) & 1\n            toggled = 1 - bit\n            if toggled in node.children:\n                xor |= 1 << i\n                node = node.children[toggled]\n            else:\n                node = node.children.get(bit, node)\n        return xor", "assertions": "trie = BitwiseTrie()\nfor num in [3, 10, 5, 25, 2, 8]:\n    trie.insert(num)\nassert trie.max_xor(5) == 28", "metadata": {"language": "Python", "function_name": "BitwiseTrie", "difficulty": "very_advanced", "category": "bit_manipulation", "complexity": 0.88}}
{"query_id": "synthetic-053", "query_text": "Write a Python function named `longest_increasing_path` that returns the length of the longest increasing path in a matrix using DFS with memoization. Language: Python. Function name: longest_increasing_path", "reference_answer": "from functools import lru_cache\n\ndef longest_increasing_path(matrix: list[list[int]]) -> int:\n    if not matrix:\n        return 0\n    rows, cols = len(matrix), len(matrix[0])\n    directions = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    @lru_cache(maxsize=None)\n    def dfs(r: int, c: int) -> int:\n        best = 1\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and matrix[nr][nc] > matrix[r][c]:\n                best = max(best, 1 + dfs(nr, nc))\n        return best\n\n    return max(dfs(r, c) for r in range(rows) for c in range(cols))", "assertions": "grid = [\n    [9,9,4],\n    [6,6,8],\n    [2,1,1]\n]\nassert longest_increasing_path(grid) == 4\nassert longest_increasing_path([]) == 0", "metadata": {"language": "Python", "function_name": "longest_increasing_path", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.83}}
{"query_id": "synthetic-054", "query_text": "Write a Python function named `stock_span` that computes the stock span for each day using a monotonic stack. Language: Python. Function name: stock_span", "reference_answer": "def stock_span(prices: list[int]) -> list[int]:\n    stack: list[tuple[int, int]] = []  # (price, span)\n    result: list[int] = []\n    for price in prices:\n        span = 1\n        while stack and stack[-1][0] <= price:\n            span += stack.pop()[1]\n        stack.append((price, span))\n        result.append(span)\n    return result", "assertions": "assert stock_span([100,80,60,70,60,75,85]) == [1,1,1,2,1,4,6]\nassert stock_span([]) == []", "metadata": {"language": "Python", "function_name": "stock_span", "difficulty": "medium", "category": "stack", "complexity": 0.37}}
{"query_id": "synthetic-055", "query_text": "Write a TypeScript function named `partition` that partitions an array in-place around a pivot predicate, returning the pivot index. Language: TypeScript. Function name: partition", "reference_answer": "export function partition<T>(arr: T[], predicate: (value: T) => boolean): number {\n    let left = 0;\n    for (let right = 0; right < arr.length; right++) {\n        if (predicate(arr[right])) {\n            [arr[left], arr[right]] = [arr[right], arr[left]];\n            left += 1;\n        }\n    }\n    return left;\n}", "assertions": "const nums = [3,1,4,2];\nconst idx = partition(nums, n => n % 2 === 0);\nif (idx !== 2 || nums.slice(0,2).some(n => n % 2 !== 0)) throw new Error('partition failed');", "metadata": {"language": "TypeScript", "function_name": "partition", "difficulty": "medium", "category": "algorithms", "complexity": 0.36}}
{"query_id": "synthetic-056", "query_text": "Write a TypeScript function named `mergeIntervals` that merges overlapping intervals and returns a sorted array. Language: TypeScript. Function name: mergeIntervals", "reference_answer": "export function mergeIntervals(intervals: Array<[number, number]>): Array<[number, number]> {\n    if (!intervals.length) return [];\n    intervals.sort((a, b) => a[0] - b[0]);\n    const merged: Array<[number, number]> = [intervals[0]];\n    for (let i = 1; i < intervals.length; i++) {\n        const [start, end] = intervals[i];\n        const last = merged[merged.length - 1];\n        if (start <= last[1]) {\n            last[1] = Math.max(last[1], end);\n        } else {\n            merged.push([start, end]);\n        }\n    }\n    return merged;\n}", "assertions": "const merged = mergeIntervals([[1,3],[2,6],[8,10],[15,18]]);\nif (JSON.stringify(merged) !== JSON.stringify([[1,6],[8,10],[15,18]])) throw new Error('merge failed');", "metadata": {"language": "TypeScript", "function_name": "mergeIntervals", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-057", "query_text": "Write a TypeScript function named `asyncQueue` that ensures asynchronous tasks execute sequentially even if triggered concurrently. Language: TypeScript. Function name: asyncQueue", "reference_answer": "export function asyncQueue() {\n    let chain = Promise.resolve();\n    return async function enqueue<T>(task: () => Promise<T>): Promise<T> {\n        chain = chain.then(task, task);\n        return chain;\n    };\n}", "assertions": "const enqueue = asyncQueue();\nlet order: number[] = [];\nenqueue(async () => { order.push(1); return 1; });\nenqueue(async () => { order.push(2); return 2; });\nsetTimeout(() => {\n    if (JSON.stringify(order) !== JSON.stringify([1,2])) throw new Error('asyncQueue failed');\n}, 100);", "metadata": {"language": "TypeScript", "function_name": "asyncQueue", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-058", "query_text": "Write a TypeScript function named `paginate` that slices an array into pages of given size and returns metadata (currentPage, totalPages, items). Language: TypeScript. Function name: paginate", "reference_answer": "export function paginate<T>(items: T[], page: number, pageSize: number) {\n    const totalPages = Math.ceil(items.length / pageSize) || 1;\n    const current = Math.min(Math.max(page, 1), totalPages);\n    const start = (current - 1) * pageSize;\n    const slice = items.slice(start, start + pageSize);\n    return { currentPage: current, totalPages, items: slice };\n}", "assertions": "const page = paginate([1,2,3,4,5], 2, 2);\nif (page.currentPage !== 2 || page.totalPages !== 3 || page.items[0] !== 3) throw new Error('paginate failed');", "metadata": {"language": "TypeScript", "function_name": "paginate", "difficulty": "medium", "category": "data_processing", "complexity": 0.32}}
{"query_id": "synthetic-059", "query_text": "Write a Go struct named `TokenBucket` implementing a token bucket rate limiter with `Allow` that returns true if a request can proceed. Language: Go. Function name: TokenBucket", "reference_answer": "package main\n\nimport (\n    \"time\"\n)\n\ntype TokenBucket struct {\n    capacity int\n    tokens   float64\n    rate     float64\n    lastRefill time.Time\n}\n\nfunc NewTokenBucket(capacity int, rate float64) *TokenBucket {\n    return &TokenBucket{capacity: capacity, tokens: float64(capacity), rate: rate, lastRefill: time.Now()}\n}\n\nfunc (tb *TokenBucket) refill() {\n    now := time.Now()\n    elapsed := now.Sub(tb.lastRefill).Seconds()\n    tb.tokens = min(float64(tb.capacity), tb.tokens+elapsed*tb.rate)\n    tb.lastRefill = now\n}\n\nfunc (tb *TokenBucket) Allow() bool {\n    tb.refill()\n    if tb.tokens >= 1 {\n        tb.tokens -= 1\n        return true\n    }\n    return false\n}\n\nfunc min(a, b float64) float64 {\n    if a < b {\n        return a\n    }\n    return b\n}", "assertions": "tb := NewTokenBucket(2, 10)\nif !tb.Allow() || !tb.Allow() {\n    panic(\"Token bucket should allow initial requests\")\n}", "metadata": {"language": "Go", "function_name": "TokenBucket", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-060", "query_text": "Write a Ruby function named `topological_sort` that performs topological sorting on a DAG represented as a hash of arrays. Language: Ruby. Function name: topological_sort", "reference_answer": "def topological_sort(graph)\n  indegree = Hash.new(0)\n  graph.each do |node, neighbors|\n    indegree[node] ||= 0\n    neighbors.each { |neighbor| indegree[neighbor] += 1 }\n  end\n  queue = indegree.select { |_, deg| deg.zero? }.map { |node, _| node }\n  order = []\n  until queue.empty?\n    node = queue.shift\n    order << node\n    graph[node]&.each do |neighbor|\n      indegree[neighbor] -= 1\n      queue << neighbor if indegree[neighbor].zero?\n    end\n  end\n  raise 'Cycle detected' if order.length != indegree.length\n  order\nend", "assertions": "graph = {\n  'a' => ['c'],\n  'b' => ['c', 'd'],\n  'c' => ['e'],\n  'd' => ['f'],\n  'e' => ['f'],\n  'f' => []\n}\nresult = topological_sort(graph)\nraise 'Failed' unless result.length == 6", "metadata": {"language": "Ruby", "function_name": "topological_sort", "difficulty": "advanced", "category": "graph_algorithms", "complexity": 0.68}}
{"query_id": "synthetic-061", "query_text": "Write a Python function named `queue_with_stacks` that implements a queue using two stacks supporting `enqueue` and `dequeue`. Return the dequeued value for `dequeue`. Language: Python. Function name: queue_with_stacks", "reference_answer": "class QueueWithStacks:\n    def __init__(self):\n        self.in_stack: list[int] = []\n        self.out_stack: list[int] = []\n    def enqueue(self, value: int) -> None:\n        self.in_stack.append(value)\n    def dequeue(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        if not self.out_stack:\n            raise IndexError('empty queue')\n        return self.out_stack.pop()", "assertions": "q = QueueWithStacks()\nq.enqueue(1)\nq.enqueue(2)\nassert q.dequeue() == 1\nq.enqueue(3)\nassert q.dequeue() == 2\nassert q.dequeue() == 3", "metadata": {"language": "Python", "function_name": "queue_with_stacks", "difficulty": "medium", "category": "data_structures", "complexity": 0.33}}
{"query_id": "synthetic-062", "query_text": "Write a Python function named `palindrome_partition_min_cut` that returns the minimum cuts needed to partition a string into palindromes using DP. Language: Python. Function name: palindrome_partition_min_cut", "reference_answer": "def palindrome_partition_min_cut(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [0] * n\n    pal = [[False] * n for _ in range(n)]\n    for end in range(n):\n        cut = end\n        for start in range(end + 1):\n            if s[start] == s[end] and (end - start <= 1 or pal[start + 1][end - 1]):\n                pal[start][end] = True\n                cut = 0 if start == 0 else min(cut, dp[start - 1] + 1)\n        dp[end] = cut\n    return dp[-1]", "assertions": "assert palindrome_partition_min_cut('aab') == 1\nassert palindrome_partition_min_cut('a') == 0\nassert palindrome_partition_min_cut('abccbc') == 2", "metadata": {"language": "Python", "function_name": "palindrome_partition_min_cut", "difficulty": "very_advanced", "category": "dynamic_programming", "complexity": 0.82}}
{"query_id": "synthetic-063", "query_text": "Write a Python function named `maximal_rectangle` that finds the area of the largest rectangle containing only 1s in a binary matrix. Language: Python. Function name: maximal_rectangle", "reference_answer": "def maximal_rectangle(matrix: list[list[str]]) -> int:\n    if not matrix:\n        return 0\n    cols = len(matrix[0])\n    heights = [0] * cols\n    best = 0\n    for row in matrix:\n        for c in range(cols):\n            heights[c] = heights[c] + 1 if row[c] == '1' else 0\n        stack: list[int] = []\n        for i in range(cols + 1):\n            h = heights[i] if i < cols else 0\n            while stack and h < heights[stack[-1]]:\n                height = heights[stack.pop()]\n                left = stack[-1] if stack else -1\n                width = i - left - 1\n                best = max(best, height * width)\n            stack.append(i)\n    return best", "assertions": "m = [\n    ['1','0','1','0','0'],\n    ['1','0','1','1','1'],\n    ['1','1','1','1','1'],\n    ['1','0','0','1','0']\n]\nassert maximal_rectangle(m) == 6\nassert maximal_rectangle([]) == 0", "metadata": {"language": "Python", "function_name": "maximal_rectangle", "difficulty": "very_advanced", "category": "matrix", "complexity": 0.9}}
{"query_id": "synthetic-064", "query_text": "Write a Python function named `longest_valid_parentheses` that returns the length of the longest valid parentheses substring using stack and dp. Language: Python. Function name: longest_valid_parentheses", "reference_answer": "def longest_valid_parentheses(s: str) -> int:\n    stack = [-1]\n    best = 0\n    for i, ch in enumerate(s):\n        if ch == '(': \n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                best = max(best, i - stack[-1])\n    return best", "assertions": "assert longest_valid_parentheses(')()())') == 4\nassert longest_valid_parentheses('') == 0\nassert longest_valid_parentheses('()(()') == 2", "metadata": {"language": "Python", "function_name": "longest_valid_parentheses", "difficulty": "advanced", "category": "stack", "complexity": 0.6}}
{"query_id": "synthetic-065", "query_text": "Write a TypeScript function named `priorityThrottle` that schedules tasks but ensures higher priority tasks preempt queued lower priority tasks. Language: TypeScript. Function name: priorityThrottle", "reference_answer": "type Task<T> = { priority: number; fn: () => Promise<T>; resolve: (value: T) => void; reject: (reason?: any) => void };\n\nexport function priorityThrottle<T>(concurrency: number) {\n    const queue: Task<T>[] = [];\n    let active = 0;\n    const runNext = () => {\n        if (active >= concurrency || queue.length === 0) return;\n        queue.sort((a, b) => b.priority - a.priority);\n        const task = queue.shift()!;\n        active += 1;\n        task.fn()\n            .then(value => task.resolve(value))\n            .catch(task.reject)\n            .finally(() => {\n                active -= 1;\n                runNext();\n            });\n    };\n    return (fn: () => Promise<T>, priority: number) => new Promise<T>((resolve, reject) => {\n        queue.push({ priority, fn, resolve, reject });\n        runNext();\n    });\n}", "assertions": "let order: number[] = [];\nconst schedule = priorityThrottle<number>(1);\nschedule(() => Promise.resolve(1).then(v => { order.push(v); return v; }), 1);\nschedule(() => Promise.resolve(2).then(v => { order.push(v); return v; }), 10);\nsetTimeout(() => {\n    if (order[0] !== 2) throw new Error('priorityThrottle failed');\n}, 50);", "metadata": {"language": "TypeScript", "function_name": "priorityThrottle", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.9}}
{"query_id": "synthetic-066", "query_text": "Write a TypeScript function named `binarySearchTreeIterator` that returns an iterator object with `next` and `hasNext` traversing a BST in-order without recursion. Language: TypeScript. Function name: binarySearchTreeIterator", "reference_answer": "type Node = { val: number; left?: Node; right?: Node };\n\nexport function binarySearchTreeIterator(root?: Node) {\n    const stack: Node[] = [];\n    let current = root;\n    const pushLeft = () => {\n        while (current) {\n            stack.push(current);\n            current = current.left;\n        }\n    };\n    pushLeft();\n    return {\n        next(): number {\n            if (!stack.length) throw new Error('No elements');\n            const node = stack.pop()!;\n            current = node.right;\n            pushLeft();\n            return node.val;\n        },\n        hasNext(): boolean {\n            return stack.length > 0;\n        }\n    };\n}", "assertions": "const iterator = binarySearchTreeIterator({ val: 2, left: { val: 1 }, right: { val: 3 } });\nif (!iterator.hasNext() || iterator.next() !== 1) throw new Error('Iterator failed');", "metadata": {"language": "TypeScript", "function_name": "binarySearchTreeIterator", "difficulty": "advanced", "category": "data_structures", "complexity": 0.68}}
{"query_id": "synthetic-067", "query_text": "Write a TypeScript function named `memoizeAsync` that memoizes async functions, caching in-flight promises to avoid duplicate calls. Language: TypeScript. Function name: memoizeAsync", "reference_answer": "export function memoizeAsync<T extends (...args: any[]) => Promise<any>>(fn: T): T {\n    const cache = new Map<string, Promise<any>>();\n    return (async (...args: Parameters<T>) => {\n        const key = JSON.stringify(args);\n        if (!cache.has(key)) {\n            cache.set(key, fn(...args).finally(() => cache.delete(key)));\n        }\n        return cache.get(key)!;\n    }) as T;\n}", "assertions": "let calls = 0;\nconst slow = async (n: number) => { calls += 1; return n * 2; };\nconst memo = memoizeAsync(slow);\nPromise.all([memo(2), memo(2)]).then(values => {\n    if (calls !== 1 || values[0] !== 4) throw new Error('memoizeAsync failed');\n});", "metadata": {"language": "TypeScript", "function_name": "memoizeAsync", "difficulty": "advanced", "category": "concurrency", "complexity": 0.69}}
{"query_id": "synthetic-068", "query_text": "Write a TypeScript function named `objectDiff` that returns added, removed, and updated keys between two flat objects. Language: TypeScript. Function name: objectDiff", "reference_answer": "type DiffResult = { added: string[]; removed: string[]; updated: string[] };\n\nexport function objectDiff(a: Record<string, any>, b: Record<string, any>): DiffResult {\n    const added: string[] = [];\n    const removed: string[] = [];\n    const updated: string[] = [];\n    const keys = new Set([...Object.keys(a), ...Object.keys(b)]);\n    keys.forEach(key => {\n        if (!(key in a)) added.push(key);\n        else if (!(key in b)) removed.push(key);\n        else if (a[key] !== b[key]) updated.push(key);\n    });\n    return { added, removed, updated };\n}", "assertions": "const diff = objectDiff({ a: 1, b: 2 }, { b: 3, c: 4 });\nif (!diff.added.includes('c') || !diff.removed.includes('a') || !diff.updated.includes('b')) throw new Error('objectDiff failed');", "metadata": {"language": "TypeScript", "function_name": "objectDiff", "difficulty": "medium", "category": "data_processing", "complexity": 0.35}}
{"query_id": "synthetic-069", "query_text": "Write a Go function named `SlidingMedian` that maintains the median of a sliding window over integers using two heaps. Language: Go. Function name: SlidingMedian", "reference_answer": "package main\n\nimport (\n    \"container/heap\"\n)\n\ntype maxHeap []int\nfunc (h maxHeap) Len() int { return len(h) }\nfunc (h maxHeap) Less(i, j int) bool { return h[i] > h[j] }\nfunc (h maxHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\nfunc (h *maxHeap) Push(x any) { *h = append(*h, x.(int)) }\nfunc (h *maxHeap) Pop() any {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[:n-1]\n    return x\n}\n\ntype minHeap []int\nfunc (h minHeap) Len() int { return len(h) }\nfunc (h minHeap) Less(i, j int) bool { return h[i] < h[j] }\nfunc (h minHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }\nfunc (h *minHeap) Push(x any) { *h = append(*h, x.(int)) }\nfunc (h *minHeap) Pop() any {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[:n-1]\n    return x\n}\n\nfunc SlidingMedian(nums []int, k int) []float64 {\n    if k == 0 {\n        return nil\n    }\n    low := &maxHeap{}\n    high := &minHeap{}\n    heap.Init(low)\n    heap.Init(high)\n    result := make([]float64, 0, len(nums)-k+1)\n    for i, num := range nums {\n        heap.Push(low, num)\n        heap.Push(high, -heap.Pop(low).(int))\n        if high.Len() > low.Len() {\n            heap.Push(low, -(heap.Pop(high).(int)))\n        }\n        if i >= k-1 {\n            if k%2 == 0 {\n                median := float64((*low)[0]-(*high)[0]) / 2.0\n                result = append(result, median)\n            } else {\n                result = append(result, float64((*low)[0]))\n            }\n            toRemove := nums[i-k+1]\n            // Note: For brevity, removal logic is omitted; assume window slide occurs via rebuild (acceptable for small k)\n            low = &maxHeap{}\n            high = &minHeap{}\n            heap.Init(low)\n            heap.Init(high)\n            for _, val := range nums[i-k+2 : i+1] {\n                heap.Push(low, val)\n                heap.Push(high, -heap.Pop(low).(int))\n                if high.Len() > low.Len() {\n                    heap.Push(low, -(heap.Pop(high).(int)))\n                }\n            }\n        }\n    }\n    return result\n}", "assertions": "_ = SlidingMedian([]int{1,2,3,4,5}, 3)", "metadata": {"language": "Go", "function_name": "SlidingMedian", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.94}}
{"query_id": "synthetic-070", "query_text": "Write a Scala function named `maxSubArray` that implements Kadane's algorithm returning the maximum subarray sum. Language: Scala. Function name: maxSubArray", "reference_answer": "def maxSubArray(nums: Array[Int]): Int = {\n  if (nums.isEmpty) return 0\n  var current = nums(0)\n  var best = nums(0)\n  for (i <- 1 until nums.length) {\n    current = math.max(nums(i), current + nums(i))\n    best = math.max(best, current)\n  }\n  best\n}", "assertions": "assert(maxSubArray(Array(-2,1,-3,4,-1,2,1,-5,4)) == 6)\nassert(maxSubArray(Array()) == 0)", "metadata": {"language": "Scala", "function_name": "maxSubArray", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-071", "query_text": "Write a Python class named `AutoComplete` that builds a prefix trie from words and returns top suggestions for a prefix sorted lexicographically. Language: Python. Function name: AutoComplete", "reference_answer": "class TrieNode:\n    def __init__(self):\n        self.children: dict[str, TrieNode] = {}\n        self.is_word = False\n\nclass AutoComplete:\n    def __init__(self, words: list[str]):\n        self.root = TrieNode()\n        for word in words:\n            self.insert(word)\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            node = node.children.setdefault(ch, TrieNode())\n        node.is_word = True\n    def lookup(self, prefix: str, limit: int = 5) -> list[str]:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return []\n            node = node.children[ch]\n        result: list[str] = []\n        def dfs(current: TrieNode, path: str) -> None:\n            if len(result) >= limit:\n                return\n            if current.is_word:\n                result.append(path)\n            for ch in sorted(current.children.keys()):\n                dfs(current.children[ch], path + ch)\n        dfs(node, prefix)\n        return result", "assertions": "ac = AutoComplete(['apple', 'app', 'apex', 'banana'])\nassert ac.lookup('ap', 3) == ['apex', 'app', 'apple']\nassert ac.lookup('z') == []", "metadata": {"language": "Python", "function_name": "AutoComplete", "difficulty": "advanced", "category": "trie", "complexity": 0.67}}
{"query_id": "synthetic-072", "query_text": "Write a Python function named `detect_cycle_directed` that detects a cycle in a directed graph using DFS colors. Language: Python. Function name: detect_cycle_directed", "reference_answer": "def detect_cycle_directed(graph: dict[int, list[int]]) -> bool:\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = {node: WHITE for node in graph}\n\n    def dfs(node: int) -> bool:\n        color[node] = GRAY\n        for nei in graph.get(node, []):\n            if color.get(nei, WHITE) == WHITE:\n                if dfs(nei):\n                    return True\n            elif color[nei] == GRAY:\n                return True\n        color[node] = BLACK\n        return False\n\n    for node in graph:\n        if color[node] == WHITE and dfs(node):\n            return True\n    return False", "assertions": "g1 = {0:[1],1:[2],2:[0]}\ng2 = {0:[1],1:[2],2:[]}\nassert detect_cycle_directed(g1) is True\nassert detect_cycle_directed(g2) is False", "metadata": {"language": "Python", "function_name": "detect_cycle_directed", "difficulty": "medium", "category": "graph_algorithms", "complexity": 0.48}}
{"query_id": "synthetic-073", "query_text": "Write a Python function named `median_two_sorted_arrays` that computes the median of two sorted arrays in O(log(min(n,m))) time using binary search. Language: Python. Function name: median_two_sorted_arrays", "reference_answer": "def median_two_sorted_arrays(nums1: list[int], nums2: list[int]) -> float:\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    imin, imax, half = 0, m, (m + n + 1) // 2\n    while imin <= imax:\n        i = (imin + imax) // 2\n        j = half - i\n        if i < m and nums2[j - 1] > nums1[i]:\n            imin = i + 1\n        elif i > 0 and nums1[i - 1] > nums2[j]:\n            imax = i - 1\n        else:\n            if i == 0:\n                max_left = nums2[j - 1]\n            elif j == 0:\n                max_left = nums1[i - 1]\n            else:\n                max_left = max(nums1[i - 1], nums2[j - 1])\n            if (m + n) % 2 == 1:\n                return float(max_left)\n            if i == m:\n                min_right = nums2[j]\n            elif j == n:\n                min_right = nums1[i]\n            else:\n                min_right = min(nums1[i], nums2[j])\n            return (max_left + min_right) / 2.0\n    raise ValueError('Invalid input')", "assertions": "assert median_two_sorted_arrays([1,3], [2]) == 2.0\nassert median_two_sorted_arrays([1,2], [3,4]) == 2.5", "metadata": {"language": "Python", "function_name": "median_two_sorted_arrays", "difficulty": "very_advanced", "category": "binary_search", "complexity": 0.91}}
{"query_id": "synthetic-074", "query_text": "Write a Python class named `WeightedPicker` that picks an index based on weights using prefix sums and binary search. Language: Python. Function name: WeightedPicker", "reference_answer": "import bisect\nimport random\n\nclass WeightedPicker:\n    def __init__(self, weights: list[int]):\n        total = 0\n        self.prefix: list[int] = []\n        for w in weights:\n            total += w\n            self.prefix.append(total)\n        self.total = total\n    def pick_index(self) -> int:\n        r = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix, r)", "assertions": "wp = WeightedPicker([1,3,6])\nidx = wp.pick_index()\nassert 0 <= idx < 3", "metadata": {"language": "Python", "function_name": "WeightedPicker", "difficulty": "advanced", "category": "probabilistic_algorithms", "complexity": 0.59}}
{"query_id": "synthetic-075", "query_text": "Write a TypeScript function named `curry` that transforms a function of N arguments into a chain of unary functions until all arguments are provided. Language: TypeScript. Function name: curry", "reference_answer": "export function curry<T extends (...args: any[]) => any>(fn: T): any {\n    const curried = (...args: any[]): any => {\n        if (args.length >= fn.length) {\n            return fn(...args);\n        }\n        return (...next: any[]) => curried(...args, ...next);\n    };\n    return curried;\n}", "assertions": "const add = (a: number, b: number, c: number) => a + b + c;\nconst curried = curry(add);\nif (curried(1)(2)(3) !== 6) throw new Error('curry failed');", "metadata": {"language": "TypeScript", "function_name": "curry", "difficulty": "advanced", "category": "functional_programming", "complexity": 0.61}}
{"query_id": "synthetic-076", "query_text": "Write a TypeScript function named `timeoutPromise` that wraps a promise and rejects if it does not settle within the specified milliseconds. Language: TypeScript. Function name: timeoutPromise", "reference_answer": "export function timeoutPromise<T>(promise: Promise<T>, ms: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n        const timer = setTimeout(() => reject(new Error('Timeout')), ms);\n        promise\n            .then(value => {\n                clearTimeout(timer);\n                resolve(value);\n            })\n            .catch(err => {\n                clearTimeout(timer);\n                reject(err);\n            });\n    });\n}", "assertions": "const slow = new Promise(resolve => setTimeout(() => resolve(42), 20));\ntimeoutPromise(slow, 50).then(value => {\n    if (value !== 42) throw new Error('timeoutPromise failed');\n});", "metadata": {"language": "TypeScript", "function_name": "timeoutPromise", "difficulty": "medium", "category": "concurrency", "complexity": 0.39}}
{"query_id": "synthetic-077", "query_text": "Write a TypeScript class named `BinaryTreeCodec` that serializes a binary tree to a string and deserializes it back using pre-order traversal. Language: TypeScript. Function name: BinaryTreeCodec", "reference_answer": "type TreeNode = { val: number; left?: TreeNode; right?: TreeNode } | null;\n\nexport class BinaryTreeCodec {\n    serialize(root: TreeNode): string {\n        const result: string[] = [];\n        const dfs = (node: TreeNode) => {\n            if (!node) {\n                result.push('#');\n                return;\n            }\n            result.push(node.val.toString());\n            dfs(node.left ?? null);\n            dfs(node.right ?? null);\n        };\n        dfs(root);\n        return result.join(',');\n    }\n    deserialize(data: string): TreeNode {\n        const values = data.split(',');\n        let idx = 0;\n        const dfs = (): TreeNode => {\n            const val = values[idx++];\n            if (val === '#' || val === '') return null;\n            const node: TreeNode = { val: Number(val) };\n            node.left = dfs();\n            node.right = dfs();\n            return node;\n        };\n        return dfs();\n    }\n}", "assertions": "const codec = new BinaryTreeCodec();\nconst tree = { val: 1, left: { val: 2 }, right: { val: 3 } };\nconst text = codec.serialize(tree);\nconst rebuilt = codec.deserialize(text);\nif (!rebuilt || rebuilt.val !== 1) throw new Error('BinaryTreeCodec failed');", "metadata": {"language": "TypeScript", "function_name": "BinaryTreeCodec", "difficulty": "very_advanced", "category": "serialization", "complexity": 0.86}}
{"query_id": "synthetic-078", "query_text": "Write a TypeScript class named `AsyncLRU` that caches async results with eviction, exposing `get(key, loader)` where loader fetches the value. Language: TypeScript. Function name: AsyncLRU", "reference_answer": "export class AsyncLRU<K, V> {\n    private map = new Map<K, Promise<V>>();\n    constructor(private capacity: number) {}\n    async get(key: K, loader: () => Promise<V>): Promise<V> {\n        if (this.map.has(key)) {\n            const value = this.map.get(key)!;\n            this.map.delete(key);\n            this.map.set(key, value);\n            return value;\n        }\n        const promise = loader();\n        this.map.set(key, promise);\n        if (this.map.size > this.capacity) {\n            const firstKey = this.map.keys().next().value;\n            this.map.delete(firstKey);\n        }\n        return promise;\n    }\n}", "assertions": "const cache = new AsyncLRU<string, number>(1);\ncache.get('a', async () => 5).then(val => {\n    if (val !== 5) throw new Error('AsyncLRU failed');\n});", "metadata": {"language": "TypeScript", "function_name": "AsyncLRU", "difficulty": "very_advanced", "category": "caching", "complexity": 0.87}}
{"query_id": "synthetic-079", "query_text": "Write a Rust struct named `NumMatrix` that precomputes 2D prefix sums and exposes `sum_region` for rectangle sums. Language: Rust. Function name: NumMatrix", "reference_answer": "pub struct NumMatrix {\n    prefix: Vec<Vec<i32>>,\n}\n\nimpl NumMatrix {\n    pub fn new(matrix: Vec<Vec<i32>>) -> Self {\n        let rows = matrix.len();\n        let cols = if rows == 0 { 0 } else { matrix[0].len() };\n        let mut prefix = vec![vec![0; cols + 1]; rows + 1];\n        for r in 1..=rows {\n            for c in 1..=cols {\n                prefix[r][c] = matrix[r - 1][c - 1]\n                    + prefix[r - 1][c]\n                    + prefix[r][c - 1]\n                    - prefix[r - 1][c - 1];\n            }\n        }\n        Self { prefix }\n    }\n    pub fn sum_region(&self, r1: usize, c1: usize, r2: usize, c2: usize) -> i32 {\n        let (r1, c1, r2, c2) = (r1 + 1, c1 + 1, r2 + 1, c2 + 1);\n        self.prefix[r2][c2]\n            - self.prefix[r1 - 1][c2]\n            - self.prefix[r2][c1 - 1]\n            + self.prefix[r1 - 1][c1 - 1]\n    }\n}", "assertions": "let matrix = NumMatrix::new(vec![vec![3,0,1], vec![5,6,3]]);\nassert_eq!(matrix.sum_region(0,0,1,1), 14);", "metadata": {"language": "Rust", "function_name": "NumMatrix", "difficulty": "advanced", "category": "matrix", "complexity": 0.7}}
{"query_id": "synthetic-080", "query_text": "Write a PHP function named `twoSumSorted` that finds two indices in a sorted array whose values sum to a target using two pointers (1-indexed). Language: PHP. Function name: twoSumSorted", "reference_answer": "<?php\nfunction twoSumSorted(array $numbers, int $target): array {\n    $left = 0;\n    $right = count($numbers) - 1;\n    while ($left < $right) {\n        $sum = $numbers[$left] + $numbers[$right];\n        if ($sum === $target) {\n            return [$left + 1, $right + 1];\n        }\n        if ($sum < $target) {\n            $left++;\n        } else {\n            $right--;\n        }\n    }\n    return [-1, -1];\n}\n?>", "assertions": "<?php\n$result = twoSumSorted([2,7,11,15], 9);\nif ($result[0] !== 1 || $result[1] !== 2) { throw new Exception('Failed'); }\n?>", "metadata": {"language": "PHP", "function_name": "twoSumSorted", "difficulty": "medium", "category": "two_pointers", "complexity": 0.34}}
{"query_id": "synthetic-081", "query_text": "Write a Python function named `spiral_traverse` that returns all elements of a matrix in spiral order. Language: Python. Function name: spiral_traverse", "reference_answer": "def spiral_traverse(matrix: list[list[int]]) -> list[int]:\n    if not matrix:\n        return []\n    res: list[int] = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1):\n            res.append(matrix[top][c])\n        top += 1\n        for r in range(top, bottom + 1):\n            res.append(matrix[r][right])\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1):\n                res.append(matrix[bottom][c])\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1):\n                res.append(matrix[r][left])\n            left += 1\n    return res", "assertions": "assert spiral_traverse([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]\nassert spiral_traverse([]) == []", "metadata": {"language": "Python", "function_name": "spiral_traverse", "difficulty": "medium", "category": "matrix", "complexity": 0.36}}
{"query_id": "synthetic-082", "query_text": "Write a Python function named `merge_sorted_streams` that merges multiple sorted iterators using a heap and yields values lazily. Language: Python. Function name: merge_sorted_streams", "reference_answer": "import heapq\nfrom typing import Iterator, Iterable\n\ndef merge_sorted_streams(streams: Iterable[Iterator[int]]) -> Iterator[int]:\n    heap = []\n    for idx, it in enumerate(streams):\n        try:\n            value = next(it)\n            heapq.heappush(heap, (value, idx, it))\n        except StopIteration:\n            continue\n    while heap:\n        value, idx, it = heapq.heappop(heap)\n        yield value\n        try:\n            nxt = next(it)\n            heapq.heappush(heap, (nxt, idx, it))\n        except StopIteration:\n            pass", "assertions": "s1 = iter([1,4,7])\ns2 = iter([2,5,8])\ns3 = iter([3,6,9])\nassert list(merge_sorted_streams([s1, s2, s3])) == list(range(1, 10))", "metadata": {"language": "Python", "function_name": "merge_sorted_streams", "difficulty": "advanced", "category": "data_streams", "complexity": 0.7}}
{"query_id": "synthetic-083", "query_text": "Write a Python function named `largest_bst_subtree` that returns the size of the largest BST in a binary tree. Language: Python. Function name: largest_bst_subtree", "reference_answer": "class TreeNode:\n    def __init__(self, val: int, left: 'TreeNode | None' = None, right: 'TreeNode | None' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largest_bst_subtree(root: 'TreeNode | None') -> int:\n    best = 0\n\n    def helper(node: 'TreeNode | None') -> tuple[bool, int, int, int]:\n        nonlocal best\n        if not node:\n            return True, 0, float('inf'), float('-inf')\n        left_is_bst, left_size, left_min, left_max = helper(node.left)\n        right_is_bst, right_size, right_min, right_max = helper(node.right)\n        if left_is_bst and right_is_bst and left_max < node.val < right_min:\n            size = left_size + right_size + 1\n            best = max(best, size)\n            return True, size, min(left_min, node.val), max(right_max, node.val)\n        return False, 0, 0, 0\n    helper(root)\n    return best", "assertions": "root = TreeNode(10, TreeNode(5, TreeNode(1), TreeNode(8)), TreeNode(15, None, TreeNode(7)))\nassert largest_bst_subtree(root) == 3", "metadata": {"language": "Python", "function_name": "largest_bst_subtree", "difficulty": "very_advanced", "category": "tree_algorithms", "complexity": 0.85}}
{"query_id": "synthetic-084", "query_text": "Write a Python function named `sudoku_solver` that solves a 9x9 Sudoku board in-place using backtracking. Language: Python. Function name: sudoku_solver", "reference_answer": "def sudoku_solver(board: list[list[str]]) -> bool:\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    empties = []\n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == '.':\n                empties.append((r, c))\n            else:\n                rows[r].add(val)\n                cols[c].add(val)\n                boxes[(r // 3) * 3 + c // 3].add(val)\n\n    def backtrack(idx: int) -> bool:\n        if idx == len(empties):\n            return True\n        r, c = empties[idx]\n        b = (r // 3) * 3 + c // 3\n        for digit in map(str, range(1, 10)):\n            if digit not in rows[r] and digit not in cols[c] and digit not in boxes[b]:\n                board[r][c] = digit\n                rows[r].add(digit)\n                cols[c].add(digit)\n                boxes[b].add(digit)\n                if backtrack(idx + 1):\n                    return True\n                rows[r].remove(digit)\n                cols[c].remove(digit)\n                boxes[b].remove(digit)\n        board[r][c] = '.'\n        return False\n    return backtrack(0)", "assertions": "board = [list(\"53..7....\"),list(\"6..195...\"),list(\".98....6.\"),list(\"8...6...3\"),list(\"4..8.3..1\"),list(\"7...2...6\"),list(\".6....28.\"),list(\"...419..5\"),list(\"....8..79\")]\nassert sudoku_solver(board)", "metadata": {"language": "Python", "function_name": "sudoku_solver", "difficulty": "very_advanced", "category": "backtracking", "complexity": 0.93}}
{"query_id": "synthetic-085", "query_text": "Write a TypeScript function named `topologicalLevels` that returns nodes by level (distance from sources) in a DAG using Kahn's algorithm. Language: TypeScript. Function name: topologicalLevels", "reference_answer": "export function topologicalLevels(graph: Record<string, string[]>): string[][] {\n    const indegree: Record<string, number> = {};\n    Object.keys(graph).forEach(node => {\n        indegree[node] = indegree[node] ?? 0;\n        graph[node].forEach(neighbor => {\n            indegree[neighbor] = (indegree[neighbor] ?? 0) + 1;\n        });\n    });\n    let current = Object.keys(indegree).filter(node => indegree[node] === 0);\n    const levels: string[][] = [];\n    while (current.length) {\n        levels.push(current);\n        const next: string[] = [];\n        current.forEach(node => {\n            graph[node]?.forEach(neighbor => {\n                indegree[neighbor] -= 1;\n                if (indegree[neighbor] === 0) {\n                    next.push(neighbor);\n                }\n            });\n        });\n        current = next;\n    }\n    return levels;\n}", "assertions": "const levels = topologicalLevels({ a: ['c'], b: ['c'], c: ['d'], d: [] });\nif (levels.length !== 3) throw new Error('topologicalLevels failed');", "metadata": {"language": "TypeScript", "function_name": "topologicalLevels", "difficulty": "advanced", "category": "graph_algorithms", "complexity": 0.64}}
{"query_id": "synthetic-086", "query_text": "Write a TypeScript function named `eventLoopDelay` that measures the event loop delay by scheduling a timer and returning the observed delay in milliseconds. Language: TypeScript. Function name: eventLoopDelay", "reference_answer": "export async function eventLoopDelay(intervalMs = 100): Promise<number> {\n    const start = Date.now();\n    await new Promise<void>(resolve => setTimeout(resolve, intervalMs));\n    return Date.now() - start - intervalMs;\n}", "assertions": "eventLoopDelay(10).then(delay => {\n    if (typeof delay !== 'number') throw new Error('eventLoopDelay failed');\n});", "metadata": {"language": "TypeScript", "function_name": "eventLoopDelay", "difficulty": "medium", "category": "monitoring", "complexity": 0.31}}
{"query_id": "synthetic-087", "query_text": "Write a TypeScript function named `resolveInSeries` that takes an array of async factories and resolves them sequentially, collecting results. Language: TypeScript. Function name: resolveInSeries", "reference_answer": "export async function resolveInSeries<T>(factories: Array<() => Promise<T>>): Promise<T[]> {\n    const results: T[] = [];\n    for (const factory of factories) {\n        results.push(await factory());\n    }\n    return results;\n}", "assertions": "resolveInSeries([\n    () => Promise.resolve(1),\n    () => Promise.resolve(2)\n]).then(res => {\n    if (res[1] !== 2) throw new Error('resolveInSeries failed');\n});", "metadata": {"language": "TypeScript", "function_name": "resolveInSeries", "difficulty": "medium", "category": "concurrency", "complexity": 0.33}}
{"query_id": "synthetic-088", "query_text": "Write a TypeScript function named `immutableMerge` that deeply merges two objects without mutating inputs, preferring values from the second object. Language: TypeScript. Function name: immutableMerge", "reference_answer": "type Plain = { [key: string]: any };\n\nexport function immutableMerge<A extends Plain, B extends Plain>(a: A, b: B): A & B {\n    const result: Plain = Array.isArray(a) ? [...a] : { ...a };\n    Object.keys(b).forEach(key => {\n        const value = b[key];\n        if (value && typeof value === 'object' && !Array.isArray(value)) {\n            result[key] = immutableMerge(result[key] || {}, value);\n        } else if (Array.isArray(value)) {\n            result[key] = [...value];\n        } else {\n            result[key] = value;\n        }\n    });\n    return result as A & B;\n}", "assertions": "const merged = immutableMerge({ a: { b: 1 } }, { a: { c: 2 } });\nif (merged.a.c !== 2 || merged.a.b !== 1) throw new Error('immutableMerge failed');", "metadata": {"language": "TypeScript", "function_name": "immutableMerge", "difficulty": "advanced", "category": "data_processing", "complexity": 0.55}}
{"query_id": "synthetic-089", "query_text": "Write a Go struct named `SegmentTree` that supports range sum queries and point updates over an array of ints. Language: Go. Function name: SegmentTree", "reference_answer": "package main\n\ntype SegmentTree struct {\n    tree []int\n    size int\n}\n\nfunc NewSegmentTree(nums []int) *SegmentTree {\n    size := 1\n    for size < len(nums) {\n        size <<= 1\n    }\n    tree := make([]int, 2*size)\n    for i, num := range nums {\n        tree[size+i] = num\n    }\n    for i := size - 1; i > 0; i-- {\n        tree[i] = tree[2*i] + tree[2*i+1]\n    }\n    return &SegmentTree{tree: tree, size: size}\n}\n\nfunc (st *SegmentTree) Update(index int, value int) {\n    pos := st.size + index\n    st.tree[pos] = value\n    for pos > 1 {\n        pos /= 2\n        st.tree[pos] = st.tree[2*pos] + st.tree[2*pos+1]\n    }\n}\n\nfunc (st *SegmentTree) RangeSum(left, right int) int {\n    left += st.size\n    right += st.size\n    sum := 0\n    for left <= right {\n        if left%2 == 1 {\n            sum += st.tree[left]\n            left++\n        }\n        if right%2 == 0 {\n            sum += st.tree[right]\n            right--\n        }\n        left /= 2\n        right /= 2\n    }\n    return sum\n}", "assertions": "st := NewSegmentTree([]int{1,3,5})\nif st.RangeSum(0,2) != 9 {\n    panic(\"SegmentTree failed\")\n}\nst.Update(1, 2)\nif st.RangeSum(0,2) != 8 {\n    panic(\"SegmentTree update failed\")\n}", "metadata": {"language": "Go", "function_name": "SegmentTree", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.91}}
{"query_id": "synthetic-090", "query_text": "Write a C# method named `IsAnagram` that checks whether two strings are anagrams using a frequency dictionary. Language: C#. Function name: IsAnagram", "reference_answer": "using System.Collections.Generic;\n\npublic static class StringAlgorithms {\n    public static bool IsAnagram(string a, string b) {\n        if (a.Length != b.Length) return false;\n        var counts = new Dictionary<char, int>();\n        foreach (var ch in a) {\n            counts[ch] = counts.TryGetValue(ch, out var val) ? val + 1 : 1;\n        }\n        foreach (var ch in b) {\n            if (!counts.ContainsKey(ch)) return false;\n            counts[ch] -= 1;\n            if (counts[ch] == 0) counts.Remove(ch);\n        }\n        return counts.Count == 0;\n    }\n}", "assertions": "if (!StringAlgorithms.IsAnagram(\"listen\", \"silent\")) throw new System.Exception(\"Failed\");\nif (StringAlgorithms.IsAnagram(\"abc\", \"abd\")) throw new System.Exception(\"Failed\");", "metadata": {"language": "C#", "function_name": "IsAnagram", "difficulty": "medium", "category": "string_algorithms", "complexity": 0.4}}
{"query_id": "synthetic-091", "query_text": "Write a Python function named `min_meeting_rooms` that returns the minimum number of meeting rooms required for a list of intervals using a sweep line. Language: Python. Function name: min_meeting_rooms", "reference_answer": "def min_meeting_rooms(intervals: list[tuple[int, int]]) -> int:\n    if not intervals:\n        return 0\n    starts = sorted(i[0] for i in intervals)\n    ends = sorted(i[1] for i in intervals)\n    s = e = 0\n    rooms = best = 0\n    while s < len(starts):\n        if starts[s] < ends[e]:\n            rooms += 1\n            best = max(best, rooms)\n            s += 1\n        else:\n            rooms -= 1\n            e += 1\n    return best", "assertions": "assert min_meeting_rooms([(0,30),(5,10),(15,20)]) == 2\nassert min_meeting_rooms([]) == 0", "metadata": {"language": "Python", "function_name": "min_meeting_rooms", "difficulty": "advanced", "category": "scheduling", "complexity": 0.6}}
{"query_id": "synthetic-092", "query_text": "Write a Python function named `trap_rain_water` that returns how much rainwater can be trapped between bars using two pointers. Language: Python. Function name: trap_rain_water", "reference_answer": "def trap_rain_water(heights: list[int]) -> int:\n    left, right = 0, len(heights) - 1\n    left_max = right_max = 0\n    trapped = 0\n    while left < right:\n        if heights[left] < heights[right]:\n            if heights[left] >= left_max:\n                left_max = heights[left]\n            else:\n                trapped += left_max - heights[left]\n            left += 1\n        else:\n            if heights[right] >= right_max:\n                right_max = heights[right]\n            else:\n                trapped += right_max - heights[right]\n            right -= 1\n    return trapped", "assertions": "assert trap_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]) == 6\nassert trap_rain_water([]) == 0", "metadata": {"language": "Python", "function_name": "trap_rain_water", "difficulty": "advanced", "category": "two_pointers", "complexity": 0.61}}
{"query_id": "synthetic-093", "query_text": "Write a Python class named `RandomizedSet` supporting `insert`, `remove`, and `get_random` in average O(1) time using a list and hash map. Language: Python. Function name: RandomizedSet", "reference_answer": "import random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.values: list[int] = []\n        self.index: dict[int, int] = {}\n    def insert(self, val: int) -> bool:\n        if val in self.index:\n            return False\n        self.index[val] = len(self.values)\n        self.values.append(val)\n        return True\n    def remove(self, val: int) -> bool:\n        if val not in self.index:\n            return False\n        idx = self.index[val]\n        last = self.values[-1]\n        self.values[idx] = last\n        self.index[last] = idx\n        self.values.pop()\n        del self.index[val]\n        return True\n    def get_random(self) -> int:\n        return random.choice(self.values)", "assertions": "rs = RandomizedSet()\nassert rs.insert(1)\nassert not rs.insert(1)\nassert rs.remove(1)\nrs.insert(2)\nassert rs.get_random() == 2", "metadata": {"language": "Python", "function_name": "RandomizedSet", "difficulty": "advanced", "category": "data_structures", "complexity": 0.65}}
{"query_id": "synthetic-094", "query_text": "Write a Python function named `alien_order` that finds a valid character ordering from a sorted list of words in an alien language using topological sorting. Language: Python. Function name: alien_order", "reference_answer": "from collections import defaultdict, deque\n\ndef alien_order(words: list[str]) -> str:\n    graph = defaultdict(set)\n    indegree = {ch: 0 for word in words for ch in word}\n    for w1, w2 in zip(words, words[1:]):\n        min_len = min(len(w1), len(w2))\n        if w1[:min_len] == w2[:min_len] and len(w1) > len(w2):\n            return ''\n        for c1, c2 in zip(w1, w2):\n            if c1 != c2:\n                if c2 not in graph[c1]:\n                    graph[c1].add(c2)\n                    indegree[c2] += 1\n                break\n    queue = deque([ch for ch, deg in indegree.items() if deg == 0])\n    order = []\n    while queue:\n        ch = queue.popleft()\n        order.append(ch)\n        for nei in graph[ch]:\n            indegree[nei] -= 1\n            if indegree[nei] == 0:\n                queue.append(nei)\n    return ''.join(order) if len(order) == len(indegree) else ''", "assertions": "assert alien_order(['wrt','wrf','er','ett','rftt']) in ('wertf',)\nassert alien_order(['z','x','z']) == ''", "metadata": {"language": "Python", "function_name": "alien_order", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.88}}
{"query_id": "synthetic-095", "query_text": "Write a TypeScript function named `pipe` that composes functions left-to-right, passing the result of each to the next. Language: TypeScript. Function name: pipe", "reference_answer": "export function pipe<T>(value: T, ...fns: Array<(arg: T) => T>): T {\n    return fns.reduce((acc, fn) => fn(acc), value);\n}", "assertions": "const result = pipe(2, x => x + 2, x => x * 3);\nif (result !== 12) throw new Error('pipe failed');", "metadata": {"language": "TypeScript", "function_name": "pipe", "difficulty": "medium", "category": "functional_programming", "complexity": 0.3}}
{"query_id": "synthetic-096", "query_text": "Write a TypeScript function named `createMutex` that returns `lock` and `unlock` functions ensuring exclusive async access. Language: TypeScript. Function name: createMutex", "reference_answer": "export function createMutex() {\n    let locked = false;\n    const waiters: Array<() => void> = [];\n    const acquire = () => new Promise<void>(resolve => {\n        if (!locked) {\n            locked = true;\n            resolve();\n        } else {\n            waiters.push(() => {\n                locked = true;\n                resolve();\n            });\n        }\n    });\n    const release = () => {\n        if (waiters.length) {\n            const next = waiters.shift()!;\n            next();\n        } else {\n            locked = false;\n        }\n    };\n    return { lock: acquire, unlock: release };\n}", "assertions": "const mutex = createMutex();\nmutex.lock().then(() => {\n    mutex.unlock();\n});", "metadata": {"language": "TypeScript", "function_name": "createMutex", "difficulty": "advanced", "category": "concurrency", "complexity": 0.72}}
{"query_id": "synthetic-097", "query_text": "Write a TypeScript function named `fuzzyMatch` that performs case-insensitive subsequence matching returning true if all characters appear in order. Language: TypeScript. Function name: fuzzyMatch", "reference_answer": "export function fuzzyMatch(pattern: string, text: string): boolean {\n    pattern = pattern.toLowerCase();\n    text = text.toLowerCase();\n    let i = 0;\n    for (const ch of text) {\n        if (ch === pattern[i]) {\n            i += 1;\n            if (i === pattern.length) return true;\n        }\n    }\n    return pattern.length === 0;\n}", "assertions": "if (!fuzzyMatch('abc', 'a_b_c')) throw new Error('fuzzyMatch failed');\nif (fuzzyMatch('abc', 'ac')) throw new Error('fuzzyMatch incorrect');", "metadata": {"language": "TypeScript", "function_name": "fuzzyMatch", "difficulty": "medium", "category": "string_algorithms", "complexity": 0.34}}
{"query_id": "synthetic-098", "query_text": "Write a TypeScript function named `mergeStreams` that merges multiple async iterables into one async iterable emitting items as they arrive. Language: TypeScript. Function name: mergeStreams", "reference_answer": "export async function* mergeStreams<T>(streams: AsyncIterable<T>[]): AsyncGenerator<T> {\n    const readers = streams.map(stream => stream[Symbol.asyncIterator]());\n    const pending = readers.map(async iterator => ({ iterator, result: await iterator.next() }));\n    while (pending.length) {\n        const settled = await Promise.race(pending);\n        const index = pending.indexOf(settled);\n        if (settled.result.done) {\n            pending.splice(index, 1);\n            continue;\n        }\n        yield settled.result.value;\n        pending[index] = settled.iterator.next().then(result => ({ iterator: settled.iterator, result }));\n    }\n}", "assertions": "async function* gen(values: number[]) {\n    for (const value of values) {\n        yield value;\n    }\n}\n(async () => {\n    const result: number[] = [];\n    for await (const val of mergeStreams([gen([1,3]), gen([2,4])])) {\n        result.push(val);\n    }\n    if (result.length !== 4) throw new Error('mergeStreams failed');\n})();", "metadata": {"language": "TypeScript", "function_name": "mergeStreams", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.9}}
{"query_id": "synthetic-099", "query_text": "Write a Rust function named `top_k_frequent` that returns the k most frequent integers from a slice using a hashmap and heap. Language: Rust. Function name: top_k_frequent", "reference_answer": "use std::cmp::Reverse;\nuse std::collections::{BinaryHeap, HashMap};\n\npub fn top_k_frequent(nums: &[i32], k: usize) -> Vec<i32> {\n    let mut counts = HashMap::new();\n    for &num in nums {\n        *counts.entry(num).or_insert(0) += 1;\n    }\n    let mut heap: BinaryHeap<(Reverse<i32>, i32)> = BinaryHeap::new();\n    for (&num, &freq) in &counts {\n        heap.push((Reverse(freq), num));\n        if heap.len() > k {\n            heap.pop();\n        }\n    }\n    heap.into_iter().map(|(_, num)| num).collect()\n}", "assertions": "let mut result = top_k_frequent(&[1,1,1,2,2,3], 2);\nresult.sort();\nassert_eq!(result, vec![1,2]);", "metadata": {"language": "Rust", "function_name": "top_k_frequent", "difficulty": "advanced", "category": "heap_algorithms", "complexity": 0.68}}
{"query_id": "synthetic-100", "query_text": "Write a Haskell function named `longestCommonPrefix` that returns the longest common prefix of a list of strings. Language: Haskell. Function name: longestCommonPrefix", "reference_answer": "module Prefix where\n\nlongestCommonPrefix :: [String] -> String\nlongestCommonPrefix [] = \"\"\nlongestCommonPrefix strs = foldl common (head strs) (tail strs)\n  where\n    common acc str = map fst $ takeWhile (uncurry (==)) $ zip acc str", "assertions": "module Test where\nimport Prefix\nmain = do\n  if longestCommonPrefix [\"flower\",\"flow\",\"flight\"] /= \"fl\" then error \"fail\" else return ()", "metadata": {"language": "Haskell", "function_name": "longestCommonPrefix", "difficulty": "medium", "category": "string_algorithms", "complexity": 0.37}}
