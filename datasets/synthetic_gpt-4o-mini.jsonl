{"query_id": "synthetic-001", "query_text": "Write a Python function named `find_gcd` that takes two integers and returns their greatest common divisor using the Euclidean algorithm. Language: Python. Function name: find_gcd", "reference_answer": "def find_gcd(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a", "assertions": "assert find_gcd(48, 18) == 6\nassert find_gcd(54, 24) == 6\nassert find_gcd(101, 10) == 1\nassert find_gcd(0, 5) == 5\nassert find_gcd(5, 0) == 5", "metadata": {"language": "Python", "function_name": "find_gcd", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-002", "query_text": "Write a Python function named `merge_sorted_arrays` that merges two sorted arrays into a single sorted array. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i = j = 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([], [1]) == [1]\nassert merge_sorted_arrays([1], []) == [1]\nassert merge_sorted_arrays([], []) == []\nassert merge_sorted_arrays([1, 4], [2, 3]) == [1, 2, 3, 4]", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-003", "query_text": "Write a TypeScript function named `isAnagram` that checks if two strings are anagrams of each other. Language: TypeScript. Function name: isAnagram", "reference_answer": "function isAnagram(str1: string, str2: string): boolean {\n    const normalize = (s: string) => s.split('').sort().join('');\n    return normalize(str1) === normalize(str2);\n}", "assertions": "if (isAnagram('listen', 'silent') !== true) throw new Error('Failed')\nif (isAnagram('hello', 'world') !== false) throw new Error('Failed')\nif (isAnagram('', '') !== true) throw new Error('Failed')\nif (isAnagram('a', 'a') !== true) throw new Error('Failed')\nif (isAnagram('triangle', 'integral') !== true) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "isAnagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-004", "query_text": "Write a TypeScript function named `fibonacci` that returns the nth Fibonacci number using memoization. Language: TypeScript. Function name: fibonacci", "reference_answer": "function fibonacci(n: number, memo: {[key: number]: number} = {}): number {\n    if (n <= 1) return n;\n    if (memo[n]) return memo[n];\n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}", "assertions": "if (fibonacci(0) !== 0) throw new Error('Failed')\nif (fibonacci(1) !== 1) throw new Error('Failed')\nif (fibonacci(5) !== 5) throw new Error('Failed')\nif (fibonacci(10) !== 55) throw new Error('Failed')\nif (fibonacci(20) !== 6765) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "fibonacci", "difficulty": "advanced", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-005", "query_text": "Write a Go function named `reverseWords` that takes a string and returns a string with the words in reverse order. Language: Go. Function name: reverseWords", "reference_answer": "package main\nimport \"strings\"\n\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {\n        words[i], words[j] = words[j], words[i]\n    }\n    return strings.Join(words, \" \")\n}", "assertions": "if reverseWords(\"Hello World\") != \"World Hello\" { panic(\"Failed\") }\nif reverseWords(\"Go is fun\") != \"fun is Go\" { panic(\"Failed\") }\nif reverseWords(\"\") != \"\" { panic(\"Failed\") }\nif reverseWords(\"single\") != \"single\" { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "reverseWords", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-006", "query_text": "Write a Go function named `countPrimes` that returns the number of prime numbers less than a given integer n. Language: Go. Function name: countPrimes", "reference_answer": "package main\n\nfunc countPrimes(n int) int {\n    if n <= 2 {\n        return 0\n    }\n    isPrime := make([]bool, n)\n    for i := 2; i < n; i++ {\n        isPrime[i] = true\n    }\n    for i := 2; i*i < n; i++ {\n        if isPrime[i] {\n            for j := i*i; j < n; j += i {\n                isPrime[j] = false\n            }\n        }\n    }\n    count := 0\n    for _, prime := range isPrime[2:] {\n        if prime {\n            count++\n        }\n    }\n    return count\n}", "assertions": "if countPrimes(10) != 4 { panic(\"Failed\") }\nif countPrimes(0) != 0 { panic(\"Failed\") }\nif countPrimes(2) != 0 { panic(\"Failed\") }\nif countPrimes(20) != 8 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "countPrimes", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-007", "query_text": "Write a Rust function named `max_subarray_sum` that finds the maximum sum of a contiguous subarray within a one-dimensional array of numbers. Language: Rust. Function name: max_subarray_sum", "reference_answer": "fn max_subarray_sum(nums: Vec<i32>) -> i32 {\n    let mut max_sum = nums[0];\n    let mut current_sum = nums[0];\n    for &num in &nums[1..] {\n        current_sum = std::cmp::max(num, current_sum + num);\n        max_sum = std::cmp::max(max_sum, current_sum);\n    }\n    max_sum\n}", "assertions": "assert_eq!(max_subarray_sum(vec![-2,1,-3,4,-1,2,1,-5,4]), 6);\nassert_eq!(max_subarray_sum(vec![1]), 1);\nassert_eq!(max_subarray_sum(vec![5,4,-1,7,8]), 23);\nassert_eq!(max_subarray_sum(vec![-1,-2,-3,-4]), -1);", "metadata": {"language": "Rust", "function_name": "max_subarray_sum", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-008", "query_text": "Write a Rust function named `string_to_int` that converts a string to an integer, handling potential errors gracefully. Language: Rust. Function name: string_to_int", "reference_answer": "fn string_to_int(s: &str) -> Result<i32, std::num::ParseIntError> {\n    s.trim().parse::<i32>()\n}", "assertions": "assert_eq!(string_to_int(\"123\"), Ok(123));\nassert_eq!(string_to_int(\"  -45  \"), Ok(-45));\nassert!(string_to_int(\"abc\").is_err());\nassert_eq!(string_to_int(\"   \"), Ok(0));", "metadata": {"language": "Rust", "function_name": "string_to_int", "difficulty": "advanced", "category": "error_handling", "complexity": 0.6}}
{"query_id": "synthetic-009", "query_text": "Write a Java function named `findMin` that finds the minimum element in a rotated sorted array. Language: Java. Function name: findMin", "reference_answer": "public class Solution {\n    public int findMin(int[] nums) {\n        int left = 0, right = nums.length - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return nums[left];\n    }\n}", "assertions": "Solution solution = new Solution();\nassert solution.findMin(new int[]{3, 4, 5, 1, 2}) == 1;\nassert solution.findMin(new int[]{4, 5, 6, 7, 0, 1, 2}) == 0;\nassert solution.findMin(new int[]{1}) == 1;\nassert solution.findMin(new int[]{1, 2, 3, 4, 5}) == 1;", "metadata": {"language": "Java", "function_name": "findMin", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-010", "query_text": "Write a JavaScript function named `debounce` that creates a debounce function to limit the rate at which a function can fire. Language: JavaScript. Function name: debounce", "reference_answer": "function debounce(fn, delay) {\n    let timeout;\n    return function() {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => fn.apply(this, arguments), delay);\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst debouncedIncrement = debounce(increment, 100);\ndebouncedIncrement();\ndebouncedIncrement();\ndebouncedIncrement();\nsetTimeout(() => {\n    assert(counter === 1);\n}, 150);", "metadata": {"language": "JavaScript", "function_name": "debounce", "difficulty": "medium", "category": "design_patterns", "complexity": 0.5}}
{"query_id": "synthetic-011", "query_text": "Write a Python function named `merge_sorted_arrays` that takes two sorted arrays and merges them into a single sorted array. The function should handle empty arrays. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    sorted_array = []\n    i, j = 0, 0\n    \n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            sorted_array.append(arr1[i])\n            i += 1\n        else:\n            sorted_array.append(arr2[j])\n            j += 1\n    \n    sorted_array.extend(arr1[i:])\n    sorted_array.extend(arr2[j:])\n    return sorted_array", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_arrays([5, 10], []) == [5, 10]\nassert merge_sorted_arrays([], []) == []\nassert merge_sorted_arrays([1, 2], [0]) == [0, 1, 2]", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-012", "query_text": "Write a TypeScript function named `isAnagram` that takes two strings and determines if they are anagrams of each other. Ignore spaces and capitalization. Language: TypeScript. Function name: isAnagram", "reference_answer": "function isAnagram(str1: string, str2: string): boolean {\n    const normalize = (str: string) => str.replace(/\\s+/g, '').toLowerCase().split('').sort().join('');\n    return normalize(str1) === normalize(str2);\n}", "assertions": "if (isAnagram('listen', 'silent') !== true) throw new Error('Failed')\nif (isAnagram('triangle', 'integral') !== true) throw new Error('Failed')\nif (isAnagram('apple', 'pale') !== false) throw new Error('Failed')\nif (isAnagram('A gentleman', 'Elegant man') !== true) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "isAnagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-013", "query_text": "Write a Go function named `fibonacci` that returns the n-th Fibonacci number. The function should handle n = 0 by returning 0. Language: Go. Function name: fibonacci", "reference_answer": "package main\n\nfunc fibonacci(n int) int {\n    if n <= 0 {\n        return 0\n    }\n    if n == 1 {\n        return 1\n    }\n    return fibonacci(n-1) + fibonacci(n-2)\n}", "assertions": "if fibonacci(0) != 0 { panic('Failed') }\nif fibonacci(1) != 1 { panic('Failed') }\nif fibonacci(5) != 5 { panic('Failed') }\nif fibonacci(10) != 55 { panic('Failed') }", "metadata": {"language": "Go", "function_name": "fibonacci", "difficulty": "advanced", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-014", "query_text": "Write a TypeScript function named `flattenArray` that takes an array of nested arrays and flattens it into a single array. The function should handle mixed types. Language: TypeScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr: any[]): any[] {\n    return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten), []);\n}", "assertions": "if (JSON.stringify(flattenArray([1, [2, [3]], 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed')\nif (JSON.stringify(flattenArray([1, 2, [3, 4], 5])) !== JSON.stringify([1, 2, 3, 4, 5])) throw new Error('Failed')\nif (JSON.stringify(flattenArray([[1], [2], [3]])) !== JSON.stringify([1, 2, 3])) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "flattenArray", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-015", "query_text": "Write a Rust function named `binary_search` that takes a sorted array of integers and a target integer, and returns the index of the target in the array or -1 if not found. Language: Rust. Function name: binary_search", "reference_answer": "fn binary_search(arr: &[i32], target: i32) -> i32 {\n    let mut left = 0;\n    let mut right = arr.len() as i32 - 1;\n    while left <= right {\n        let mid = left + (right - left) / 2;\n        if arr[mid as usize] == target {\n            return mid;\n        } else if arr[mid as usize] < target {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    -1\n}", "assertions": "assert_eq!(binary_search(&[1, 2, 3, 4, 5], 3), 2);\nassert_eq!(binary_search(&[1, 2, 3, 4, 5], 6), -1);\nassert_eq!(binary_search(&[], 3), -1);\nassert_eq!(binary_search(&[1, 2, 3], 1), 0);", "metadata": {"language": "Rust", "function_name": "binary_search", "difficulty": "advanced", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-016", "query_text": "Write a Python function named `generate_primes` that generates a list of prime numbers up to a given limit. The function should handle limits below 2 by returning an empty list. Language: Python. Function name: generate_primes", "reference_answer": "def generate_primes(limit: int) -> list:\n    primes = []\n    for num in range(2, limit + 1):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes", "assertions": "assert generate_primes(10) == [2, 3, 5, 7]\nassert generate_primes(0) == []\nassert generate_primes(1) == []\nassert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19]", "metadata": {"language": "Python", "function_name": "generate_primes", "difficulty": "medium", "category": "algorithms", "complexity": 0.55}}
{"query_id": "synthetic-017", "query_text": "Write a JavaScript function named `debounce` that creates a debounced version of a given function, which delays its execution until after a specified time has elapsed since the last time it was invoked. Language: JavaScript. Function name: debounce", "reference_answer": "function debounce(func, wait) {\n    let timeout;\n    return function(...args) {\n        const context = this;\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(context, args), wait);\n    };\n}", "assertions": "let count = 0;\nconst increment = debounce(() => count++, 100);\nincrement();\nincrement();\nsetTimeout(() => {\n    assert(count === 1);\n}, 200);", "metadata": {"language": "JavaScript", "function_name": "debounce", "difficulty": "very_advanced", "category": "design_patterns", "complexity": 0.8}}
{"query_id": "synthetic-018", "query_text": "Write a Go function named `countVowels` that takes a string and returns the count of vowels in it. The function should handle empty strings. Language: Go. Function name: countVowels", "reference_answer": "package main\n\nfunc countVowels(s string) int {\n    count := 0\n    for _, char := range s {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'A' || char == 'E' || char == 'I' || char == 'O' || char == 'U' {\n            count++\n        }\n    }\n    return count\n}", "assertions": "if countVowels('hello') != 2 { panic('Failed') }\nif countVowels('') != 0 { panic('Failed') }\nif countVowels('AEIOU') != 5 { panic('Failed') }", "metadata": {"language": "Go", "function_name": "countVowels", "difficulty": "medium", "category": "string_processing", "complexity": 0.5}}
{"query_id": "synthetic-019", "query_text": "Write a TypeScript function named `removeDuplicates` that takes an array and returns a new array with duplicate values removed. Maintain the order of elements. Language: TypeScript. Function name: removeDuplicates", "reference_answer": "function removeDuplicates(arr: any[]): any[] {\n    return Array.from(new Set(arr));\n}", "assertions": "if (JSON.stringify(removeDuplicates([1, 2, 2, 3, 4, 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed')\nif (JSON.stringify(removeDuplicates(['a', 'b', 'a', 'c'])) !== JSON.stringify(['a', 'b', 'c'])) throw new Error('Failed')\nif (JSON.stringify(removeDuplicates([])) !== JSON.stringify([])) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "removeDuplicates", "difficulty": "medium", "category": "data_structures", "complexity": 0.3}}
{"query_id": "synthetic-020", "query_text": "Write a Python function named `merge_sorted_arrays` that takes two sorted arrays and merges them into a single sorted array. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3]\nassert merge_sorted_arrays([], []) == []", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-021", "query_text": "Write a TypeScript function named `isAnagram` that takes two strings and returns true if they are anagrams of each other, and false otherwise. Language: TypeScript. Function name: isAnagram", "reference_answer": "function isAnagram(str1: string, str2: string): boolean {\n    const sortedStr1 = str1.split('').sort().join('');\n    const sortedStr2 = str2.split('').sort().join('');\n    return sortedStr1 === sortedStr2;\n}", "assertions": "if (isAnagram(\"listen\", \"silent\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"hello\", \"world\") !== false) throw new Error(\"Failed\")\nif (isAnagram(\"rat\", \"tar\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"evil\", \"vile\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"angel\", \"glean\") !== true) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "isAnagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-022", "query_text": "Write a Go function named `reverseWords` that takes a sentence (string) and reverses the order of the words in it while preserving spaces. Language: Go. Function name: reverseWords", "reference_answer": "package main\nimport (\"strings\")\nfunc reverseWords(s string) string {\n    words := strings.Fields(s)\n    reversed := \"\"\n    for i := len(words) - 1; i >= 0; i-- {\n        if i != len(words) - 1 {\n            reversed += \" \"\n        }\n        reversed += words[i]\n    }\n    return reversed\n}", "assertions": "if reverseWords(\"Hello World\") != \"World Hello\" { panic(\"Failed\") }\nif reverseWords(\"  Spaces in  between  \") != \"between in  Spaces  \" { panic(\"Failed\") }\nif reverseWords(\"Go Lang\") != \"Lang Go\" { panic(\"Failed\") }\nif reverseWords(\"SingleWord\") != \"SingleWord\" { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "reverseWords", "difficulty": "medium", "category": "strings", "complexity": 0.5}}
{"query_id": "synthetic-023", "query_text": "Write a Rust function named `fibonacci` that takes a number n and returns the nth Fibonacci number. Language: Rust. Function name: fibonacci", "reference_answer": "fn fibonacci(n: u32) -> u32 {\n    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n    a\n}", "assertions": "assert_eq!(fibonacci(0), 0);\nassert_eq!(fibonacci(1), 1);\nassert_eq!(fibonacci(5), 5);\nassert_eq!(fibonacci(10), 55);", "metadata": {"language": "Rust", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-024", "query_text": "Write a Python function named `find_missing_number` that takes a list of integers from 0 to n and returns the missing number. Language: Python. Function name: find_missing_number", "reference_answer": "def find_missing_number(nums):\n    n = len(nums)\n    total = n * (n + 1) // 2\n    return total - sum(nums)", "assertions": "assert find_missing_number([0, 1, 2, 3, 5]) == 4\nassert find_missing_number([1, 2, 3]) == 0\nassert find_missing_number([0]) == 1\nassert find_missing_number([0, 2]) == 1", "metadata": {"language": "Python", "function_name": "find_missing_number", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-025", "query_text": "Write a TypeScript function named `flattenArray` that takes an array of nested arrays and flattens it into a single array. Language: TypeScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr: any[]): any[] {\n    return arr.reduce((flat, next) => flat.concat(Array.isArray(next) ? flattenArray(next) : next), []);\n}", "assertions": "if (JSON.stringify(flattenArray([1, [2, [3, 4]], 5])) !== JSON.stringify([1, 2, 3, 4, 5])) throw new Error(\"Failed\")\nif (JSON.stringify(flattenArray([1, 2, 3])) !== JSON.stringify([1, 2, 3])) throw new Error(\"Failed\")\nif (JSON.stringify(flattenArray([[1], [2], [3]])) !== JSON.stringify([1, 2, 3])) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "flattenArray", "difficulty": "advanced", "category": "arrays", "complexity": 0.6}}
{"query_id": "synthetic-026", "query_text": "Write a Go function named `sumEvenNumbers` that takes a slice of integers and returns the sum of all even numbers in that slice. Language: Go. Function name: sumEvenNumbers", "reference_answer": "package main\nfunc sumEvenNumbers(numbers []int) int {\n    sum := 0\n    for _, num := range numbers {\n        if num % 2 == 0 {\n            sum += num\n        }\n    }\n    return sum\n}", "assertions": "if sumEvenNumbers([]int{1, 2, 3, 4}) != 6 { panic(\"Failed\") }\nif sumEvenNumbers([]int{5, 7, 13}) != 0 { panic(\"Failed\") }\nif sumEvenNumbers([]int{2, 4, 6, 8}) != 20 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "sumEvenNumbers", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-027", "query_text": "Write a Python function named `longest_common_prefix` that takes an array of strings and returns the longest common prefix among the strings. Language: Python. Function name: longest_common_prefix", "reference_answer": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    prefix = strs[0]\n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix", "assertions": "assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"a\", \"b\", \"c\"]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inter\"", "metadata": {"language": "Python", "function_name": "longest_common_prefix", "difficulty": "advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-028", "query_text": "Write a Rust function named `twoSum` that takes an array of integers and a target integer, and returns the indices of the two numbers that add up to the target. Language: Rust. Function name: twoSum", "reference_answer": "fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n    let mut map = std::collections::HashMap::new();\n    for (i, &num) in nums.iter().enumerate() {\n        let complement = target - num;\n        if map.contains_key(&complement) {\n            return vec![*map.get(&complement).unwrap(), i as i32];\n        }\n        map.insert(num, i);\n    }\n    vec![]\n}", "assertions": "assert_eq!(two_sum(vec![2, 7, 11, 15], 9), vec![0, 1]);\nassert_eq!(two_sum(vec![3, 2, 4], 6), vec![1, 2]);\nassert_eq!(two_sum(vec![3, 3], 6), vec![0, 1]);", "metadata": {"language": "Rust", "function_name": "twoSum", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-029", "query_text": "Write a Python function named `flatten_dictionary` that takes a nested dictionary and returns a flat dictionary with concatenated keys. The function should handle any level of nesting. Language: Python. Function name: flatten_dictionary", "reference_answer": "def flatten_dictionary(d, parent_key='', sep='_'):\n    items = {}\n    for k, v in d.items():\n        new_key = f'{parent_key}{sep}{k}' if parent_key else k\n        if isinstance(v, dict):\n            items.update(flatten_dictionary(v, new_key, sep=sep))\n        else:\n            items[new_key] = v\n    return items", "assertions": "assert flatten_dictionary({'a': 1, 'b': {'c': 2}}) == {'a': 1, 'b_c': 2}\nassert flatten_dictionary({'x': {'y': {'z': 3}}}) == {'x_y_z': 3}\nassert flatten_dictionary({}) == {}\nassert flatten_dictionary({'level1': {'level2': {'level3': 42}}}) == {'level1_level2_level3': 42}\nassert flatten_dictionary({'a': {'b': 2, 'c': 3}, 'd': 4}) == {'a_b': 2, 'a_c': 3, 'd': 4}", "metadata": {"language": "Python", "function_name": "flatten_dictionary", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-030", "query_text": "Write a TypeScript function named `sortArray` that takes an array of numbers and returns a new array sorted in ascending order. The function should handle negative numbers and duplicates. Language: TypeScript. Function name: sortArray", "reference_answer": "function sortArray(arr: number[]): number[] {\n    return arr.slice().sort((a, b) => a - b);\n}", "assertions": "if (sortArray([3, 2, 1]) !== [1, 2, 3]) throw new Error(\"Failed\");\nif (sortArray([-1, -3, 2]) !== [-3, -1, 2]) throw new Error(\"Failed\");\nif (sortArray([3, 3, 1]) !== [1, 3, 3]) throw new Error(\"Failed\");\nif (sortArray([2, 2, 2]) !== [2, 2, 2]) throw new Error(\"Failed\");\nif (sortArray([]) !== []) throw new Error(\"Failed\");", "metadata": {"language": "TypeScript", "function_name": "sortArray", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-031", "query_text": "Write a Go function named `isAnagram` that checks if two strings are anagrams of each other. The function should ignore spaces and letter case. Language: Go. Function name: isAnagram", "reference_answer": "package main\n\nimport (\"sort\")\n\nfunc isAnagram(s1, s2 string) bool {\n    clean := func(s string) string {\n        s = strings.ReplaceAll(s, \" \", \"\")\n        return strings.ToLower(s)\n    }\n    return sorted(clean(s1)) == sorted(clean(s2))\n}\n\nfunc sorted(s string) string {\n    runes := []rune(s)\n    sort.Slice(runes, func(i, j int) bool {\n        return runes[i] < runes[j]\n    })\n    return string(runes)\n}", "assertions": "if !isAnagram(\"listen\", \"silent\") { panic(\"Failed\") }\nif isAnagram(\"hello\", \"world\") { panic(\"Failed\") }\nif !isAnagram(\"A gentleman\", \"Elegant man\") { panic(\"Failed\") }\nif isAnagram(\"Test\", \"Taste\") { panic(\"Failed\") }\nif !isAnagram(\"rat\", \"car\") { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "isAnagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-032", "query_text": "Write a Rust function named `fibonacci` that returns the nth Fibonacci number. The function should handle invalid inputs gracefully. Language: Rust. Function name: fibonacci", "reference_answer": "fn fibonacci(n: u32) -> Option<u32> {\n    if n == 0 {\n        return Some(0);\n    } else if n == 1 {\n        return Some(1);\n    }\n    let (mut a, mut b) = (0, 1);\n    for _ in 2..=n {\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n    Some(b)\n}", "assertions": "assert_eq!(fibonacci(0), Some(0));\nassert_eq!(fibonacci(1), Some(1));\nassert_eq!(fibonacci(5), Some(5));\nassert_eq!(fibonacci(10), Some(55));\nassert_eq!(fibonacci(20), Some(6765));", "metadata": {"language": "Rust", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-033", "query_text": "Write a Python function named `merge_sorted_arrays` that takes two sorted arrays and returns a merged sorted array. The function should handle arrays of different lengths. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([1], [2, 3]) == [1, 2, 3]\nassert merge_sorted_arrays([], [1, 4, 5]) == [1, 4, 5]\nassert merge_sorted_arrays([0, 2], []) == [0, 2]\nassert merge_sorted_arrays([], []) == []", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-034", "query_text": "Write a TypeScript function named `countVowels` that counts the vowels in a given string ignoring case. Language: TypeScript. Function name: countVowels", "reference_answer": "function countVowels(str: string): number {\n    return (str.match(/[aeiou]/gi) || []).length;\n}", "assertions": "if (countVowels(\"hello\") !== 2) throw new Error(\"Failed\");\nif (countVowels(\"HELLO\") !== 2) throw new Error(\"Failed\");\nif (countVowels(\"xyz\") !== 0) throw new Error(\"Failed\");\nif (countVowels(\"\") !== 0) throw new Error(\"Failed\");\nif (countVowels(\"abc ABC\") !== 3) throw new Error(\"Failed\");", "metadata": {"language": "TypeScript", "function_name": "countVowels", "difficulty": "medium", "category": "strings", "complexity": 0.2}}
{"query_id": "synthetic-035", "query_text": "Write a Go function named `reverseString` that reverses a given string. The function should handle edge cases like empty strings and single-character strings. Language: Go. Function name: reverseString", "reference_answer": "package main\n\nfunc reverseString(s string) string {\n    r := []rune(s)\n    for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n        r[i], r[j] = r[j], r[i]\n    }\n    return string(r)\n}", "assertions": "if reverseString(\"hello\") != \"olleh\" { panic(\"Failed\") }\nif reverseString(\"\") != \"\" { panic(\"Failed\") }\nif reverseString(\"a\") != \"a\" { panic(\"Failed\") }\nif reverseString(\"abc\") != \"cba\" { panic(\"Failed\") }\nif reverseString(\"Go\") != \"oG\" { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "reverseString", "difficulty": "medium", "category": "strings", "complexity": 0.3}}
{"query_id": "synthetic-036", "query_text": "Write a Rust function named `sum` that takes a vector of integers and returns their sum. The function should return 0 for an empty vector. Language: Rust. Function name: sum", "reference_answer": "fn sum(nums: Vec<i32>) -> i32 {\n    nums.iter().sum()\n}", "assertions": "assert_eq!(sum(vec![1, 2, 3]), 6);\nassert_eq!(sum(vec![]), 0);\nassert_eq!(sum(vec![-1, -1, -1]), -3);\nassert_eq!(sum(vec![100, 200]), 300);\nassert_eq!(sum(vec![1]), 1);", "metadata": {"language": "Rust", "function_name": "sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-037", "query_text": "Write a Python function named `merge_sorted_arrays` that takes two sorted arrays and merges them into a single sorted array. The function should return the new merged array. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3]\nassert merge_sorted_arrays([], []) == []\nassert merge_sorted_arrays([5, 10], [1, 2, 3]) == [1, 2, 3, 5, 10]", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-038", "query_text": "Write a TypeScript function named `deepClone` that takes an object and returns a deep copy of that object. The function should correctly handle nested objects. Language: TypeScript. Function name: deepClone", "reference_answer": "function deepClone(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}", "assertions": "const original = { a: 1, b: { c: 2 } };\nconst clone = deepClone(original);\nif (clone.a !== original.a || clone.b.c !== original.b.c) throw new Error('Failed');\noriginal.b.c = 3;\nif (clone.b.c === original.b.c) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "deepClone", "difficulty": "medium", "category": "design_patterns", "complexity": 0.4}}
{"query_id": "synthetic-039", "query_text": "Write a Go function named `find_duplicate` that takes a slice of integers and returns a slice of duplicates found in that slice. Language: Go. Function name: find_duplicate", "reference_answer": "package main\n\nfunc find_duplicate(nums []int) []int {\n    m := make(map[int]int)\n    duplicates := []int{}\n    for _, num := range nums {\n        m[num]++\n        if m[num] == 2 {\n            duplicates = append(duplicates, num)\n        }\n    }\n    return duplicates\n}", "assertions": "if len(find_duplicate([]int{1, 2, 3, 1, 2})) != 2 { panic(\"Failed\") }\nif len(find_duplicate([]int{1, 1, 1, 2, 2, 3})) != 2 { panic(\"Failed\") }\nif len(find_duplicate([]int{1, 2, 3})) != 0 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "find_duplicate", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-040", "query_text": "Write a Rust function named `is_anagram` that takes two strings and returns true if they are anagrams of each other, or false otherwise. Language: Rust. Function name: is_anagram", "reference_answer": "fn is_anagram(s1: &str, s2: &str) -> bool {\n    let mut s1_chars: Vec<_> = s1.chars().collect();\n    let mut s2_chars: Vec<_> = s2.chars().collect();\n    s1_chars.sort();\n    s2_chars.sort();\n    s1_chars == s2_chars\n}", "assertions": "assert_eq!(is_anagram(\"listen\", \"silent\"), true);\nassert_eq!(is_anagram(\"hello\", \"world\"), false);\nassert_eq!(is_anagram(\"anagram\", \"nagaram\"), true);", "metadata": {"language": "Rust", "function_name": "is_anagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-041", "query_text": "Write a TypeScript function named `flattenArray` that takes a nested array and returns a single-level array consisting of all the elements. Language: TypeScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr: any[]): any[] {\n    return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten), []);\n}", "assertions": "if (JSON.stringify(flattenArray([1, [2, [3, 4]], 5])) !== JSON.stringify([1, 2, 3, 4, 5])) throw new Error('Failed');\nif (JSON.stringify(flattenArray([[1], [2], [3]])) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "flattenArray", "difficulty": "advanced", "category": "data_structures", "complexity": 0.6}}
{"query_id": "synthetic-042", "query_text": "Write a Python function named `count_vowels` that takes a string and returns the count of vowels (a, e, i, o, u) in that string. The function should be case insensitive. Language: Python. Function name: count_vowels", "reference_answer": "def count_vowels(s: str) -> int:\n    return sum(1 for char in s.lower() if char in 'aeiou')", "assertions": "assert count_vowels(\"Hello World\") == 3\nassert count_vowels(\"Simplify\") == 3\nassert count_vowels(\"\") == 0\nassert count_vowels(\"Python\") == 1", "metadata": {"language": "Python", "function_name": "count_vowels", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-043", "query_text": "Write a Go function named `max_subarray_sum` that takes a slice of integers and returns the maximum sum of any contiguous subarray. Language: Go. Function name: max_subarray_sum", "reference_answer": "package main\n\nfunc max_subarray_sum(nums []int) int {\n    max_sum := nums[0]\n    current_sum := nums[0]\n    for _, num := range nums[1:] {\n        current_sum = max(num, current_sum+num)\n        max_sum = max(max_sum, current_sum)\n    }\n    return max_sum\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}", "assertions": "if max_subarray_sum([]int{1, -2, 3, 4, -1, 2, 1, -5, 4}) != 10 { panic(\"Failed\") }\nif max_subarray_sum([]int{-1, -2, -3}) != -1 { panic(\"Failed\") }\nif max_subarray_sum([]int{5, 4, -1, 7, 8}) != 23 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "max_subarray_sum", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-044", "query_text": "Write a TypeScript function named `throttle` that implements a throttle function, which only allows a function to be called a specified number of times in a given time frame. Language: TypeScript. Function name: throttle", "reference_answer": "function throttle(fn: Function, limit: number) {\n    let lastFn;\n    let lastRan;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (!lastRan) {\n            fn.apply(context, args);\n            lastRan = Date.now();\n        } else {\n            clearTimeout(lastFn);\n            lastFn = setTimeout(() => {\n                if ((Date.now() - lastRan) >= limit) {\n                    fn.apply(context, args);\n                    lastRan = Date.now();\n                }\n            }, limit - (Date.now() - lastRan));\n        }\n    };\n}", "assertions": "let count = 0;\nconst increment = throttle(() => count++ , 100);\nincrement();\nsetTimeout(() => { increment(); }, 50);\nsetTimeout(() => { increment(); }, 150);\nsetTimeout(() => { if (count !== 2) throw new Error('Failed'); }, 200);", "metadata": {"language": "TypeScript", "function_name": "throttle", "difficulty": "very_advanced", "category": "asynchronous", "complexity": 0.9}}
{"query_id": "synthetic-045", "query_text": "Write a Rust function named `reverse_string` that takes a string slice and returns it reversed as a new string. Language: Rust. Function name: reverse_string", "reference_answer": "fn reverse_string(s: &str) -> String {\n    s.chars().rev().collect()\n}", "assertions": "assert_eq!(reverse_string(\"hello\"), \"olleh\");\nassert_eq!(reverse_string(\"racecar\"), \"racecar\");\nassert_eq!(reverse_string(\"Rust\"), \"tsuR\");", "metadata": {"language": "Rust", "function_name": "reverse_string", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-046", "query_text": "Write a Python function named `reverse_words` that takes a string sentence and returns the sentence with each word reversed but the order of words preserved. Language: Python. Function name: reverse_words", "reference_answer": "def reverse_words(sentence: str) -> str:\n    return ' '.join(word[::-1] for word in sentence.split())", "assertions": "assert reverse_words(\"Hello World\") == \"olleH dlroW\"\nassert reverse_words(\"Python programming\") == \"nohtyP gnimmargorp\"\nassert reverse_words(\"Coding is fun\") == \"gnidiC si nuf\"\nassert reverse_words(\"\") == \"\"\nassert reverse_words(\"A B C\") == \"A B C\"", "metadata": {"language": "Python", "function_name": "reverse_words", "difficulty": "medium", "category": "strings", "complexity": 0.4}}
{"query_id": "synthetic-047", "query_text": "Write a TypeScript function named `countVowels` that takes a string and returns the number of vowels in it. Language: TypeScript. Function name: countVowels", "reference_answer": "function countVowels(str: string): number {\n    return (str.match(/[aeiou]/gi) || []).length;\n}", "assertions": "if (countVowels(\"Hello World\") !== 3) throw new Error(\"Failed\")\nif (countVowels(\"Programming\") !== 3) throw new Error(\"Failed\")\nif (countVowels(\"sky\") !== 0) throw new Error(\"Failed\")\nif (countVowels(\"\") !== 0) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "countVowels", "difficulty": "medium", "category": "strings", "complexity": 0.3}}
{"query_id": "synthetic-048", "query_text": "Write a Go function named `isAnagram` that determines if two strings are anagrams of each other. Language: Go. Function name: isAnagram", "reference_answer": "package main\n\nimport \"sort\"\n\nfunc isAnagram(s1 string, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n    s1Slice := []rune(s1)\n    s2Slice := []rune(s2)\n    sort.Slice(s1Slice, func(i, j int) bool { return s1Slice[i] < s1Slice[j] })\n    sort.Slice(s2Slice, func(i, j int) bool { return s2Slice[i] < s2Slice[j] })\n    return string(s1Slice) == string(s2Slice)\n}", "assertions": "if isAnagram(\"listen\", \"silent\") != true { panic(\"Failed\") }\nif isAnagram(\"hello\", \"world\") != false { panic(\"Failed\") }\nif isAnagram(\"triangle\", \"integral\") != true { panic(\"Failed\") }\nif isAnagram(\"abc\", \"cba\") != true { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "isAnagram", "difficulty": "medium", "category": "strings", "complexity": 0.5}}
{"query_id": "synthetic-049", "query_text": "Write a Rust function named `fib` that returns the `n`-th Fibonacci number. Language: Rust. Function name: fib", "reference_answer": "fn fib(n: u32) -> u32 {\n    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n    a\n}", "assertions": "assert_eq!(fib(0), 0);\nassert_eq!(fib(1), 1);\nassert_eq!(fib(2), 1);\nassert_eq!(fib(10), 55);\nassert_eq!(fib(20), 6765);", "metadata": {"language": "Rust", "function_name": "fib", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-050", "query_text": "Write a Java function named `maxElement` that returns the largest element in an array of integers. Language: Java. Function name: maxElement", "reference_answer": "public static int maxElement(int[] arr) {\n    int max = arr[0];\n    for (int num : arr) {\n        if (num > max) {\n            max = num;\n        }\n    }\n    return max;\n}", "assertions": "if (maxElement(new int[]{3, 5, 7, 2}) != 7) throw new Error(\"Failed\")\nif (maxElement(new int[]{-1, -2, -3}) != -1) throw new Error(\"Failed\")\nif (maxElement(new int[]{10}) != 10) throw new Error(\"Failed\")\nif (maxElement(new int[]{}) != null) throw new Error(\"Failed\")", "metadata": {"language": "Java", "function_name": "maxElement", "difficulty": "medium", "category": "arrays", "complexity": 0.5}}
{"query_id": "synthetic-051", "query_text": "Write a TypeScript function named `mergeSortedArrays` that merges two sorted arrays into one sorted array. Language: TypeScript. Function name: mergeSortedArrays", "reference_answer": "function mergeSortedArrays(arr1: number[], arr2: number[]): number[] {\n    let merged: number[] = [];\n    let i = 0, j = 0;\n\n    while (i < arr1.length && j < arr2.length) {\n        if (arr1[i] < arr2[j]) {\n            merged.push(arr1[i]);\n            i++;\n        } else {\n            merged.push(arr2[j]);\n            j++;\n        }\n    }\n    return merged.concat(arr1.slice(i)).concat(arr2.slice(j));\n}", "assertions": "if (!arraysEqual(mergeSortedArrays([1, 3, 5], [2, 4, 6]), [1, 2, 3, 4, 5, 6])) throw new Error(\"Failed\")\nif (!arraysEqual(mergeSortedArrays([1, 2], [3, 4, 5]), [1, 2, 3, 4, 5])) throw new Error(\"Failed\")\nif (!arraysEqual(mergeSortedArrays([], [1, 2, 3]), [1, 2, 3])) throw new Error(\"Failed\")\nif (!arraysEqual(mergeSortedArrays([], []), [])) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "mergeSortedArrays", "difficulty": "advanced", "category": "arrays", "complexity": 0.6}}
{"query_id": "synthetic-052", "query_text": "Write a Go function named `sumSlice` that returns the sum of a slice of integers. Language: Go. Function name: sumSlice", "reference_answer": "package main\n\nfunc sumSlice(numbers []int) int {\n    sum := 0\n    for _, num := range numbers {\n        sum += num\n    }\n    return sum\n}", "assertions": "if sumSlice([]int{1, 2, 3, 4}) != 10 { panic(\"Failed\") }\nif sumSlice([]int{}) != 0 { panic(\"Failed\") }\nif sumSlice([]int{-1, -2, -3}) != -6 { panic(\"Failed\") }\nif sumSlice([]int{0}) != 0 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "sumSlice", "difficulty": "medium", "category": "arrays", "complexity": 0.3}}
{"query_id": "synthetic-053", "query_text": "Write a Python function named `longest_common_prefix` that takes a list of strings and returns the longest common prefix. Language: Python. Function name: longest_common_prefix", "reference_answer": "def longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    prefix = strs[0]\n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    return prefix", "assertions": "assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\nassert longest_common_prefix([]) == \"\"", "metadata": {"language": "Python", "function_name": "longest_common_prefix", "difficulty": "advanced", "category": "strings", "complexity": 0.7}}
{"query_id": "synthetic-054", "query_text": "Write a Python function named `merge_sorted_lists` that takes two sorted lists and merges them into a single sorted list. Language: Python. Function name: merge_sorted_lists", "reference_answer": "def merge_sorted_lists(list1, list2):\n    merged_list = []\n    i, j = 0, 0\n\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n\n    while i < len(list1):\n        merged_list.append(list1[i])\n        i += 1\n\n    while j < len(list2):\n        merged_list.append(list2[j])\n        j += 1\n\n    return merged_list", "assertions": "assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_lists([], [1]) == [1]\nassert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3]\nassert merge_sorted_lists([], []) == []\nassert merge_sorted_lists([5, 10], [1, 2, 3]) == [1, 2, 3, 5, 10]", "metadata": {"language": "Python", "function_name": "merge_sorted_lists", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-055", "query_text": "Write a TypeScript function named `is_anagram` that takes two strings and returns true if they are anagrams of each other, and false otherwise. Language: TypeScript. Function name: is_anagram", "reference_answer": "function is_anagram(str1: string, str2: string): boolean {\n    const normalizedStr1 = str1.toLowerCase().split('').sort().join('');\n    const normalizedStr2 = str2.toLowerCase().split('').sort().join('');\n    return normalizedStr1 === normalizedStr2;\n}", "assertions": "if (is_anagram('listen', 'silent') !== true) throw new Error('Failed')\nif (is_anagram('hello', 'world') !== false) throw new Error('Failed')\nif (is_anagram('Triangle', 'Integral') !== true) throw new Error('Failed')\nif (is_anagram('apple', 'pale') !== false) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "is_anagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-056", "query_text": "Write a Go function named `reverse_string` that takes a string and returns it reversed. Language: Go. Function name: reverse_string", "reference_answer": "func reverse_string(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}", "assertions": "if reverse_string('hello') != 'olleh' { panic('Failed') }\nif reverse_string('abc') != 'cba' { panic('Failed') }\nif reverse_string('') != '' { panic('Failed') }\nif reverse_string('A') != 'A' { panic('Failed') }", "metadata": {"language": "Go", "function_name": "reverse_string", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-057", "query_text": "Write a Rust function named `fibonacci` that takes an integer n and returns the nth Fibonacci number. Language: Rust. Function name: fibonacci", "reference_answer": "fn fibonacci(n: u32) -> u32 {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}", "assertions": "assert_eq!(fibonacci(0), 0);\nassert_eq!(fibonacci(1), 1);\nassert_eq!(fibonacci(2), 1);\nassert_eq!(fibonacci(10), 55);", "metadata": {"language": "Rust", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-058", "query_text": "Write a Python function named `count_vowels` that takes a string and returns the count of vowels in it. Language: Python. Function name: count_vowels", "reference_answer": "def count_vowels(s: str) -> int:\n    return sum(1 for char in s.lower() if char in 'aeiou')", "assertions": "assert count_vowels('hello') == 2\nassert count_vowels('xyz') == 0\nassert count_vowels('AEIOUaeiou') == 10\nassert count_vowels('Python') == 1", "metadata": {"language": "Python", "function_name": "count_vowels", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-059", "query_text": "Write a TypeScript function named `flatten_array` that takes a nested array and returns a flattened version of it. Language: TypeScript. Function name: flatten_array", "reference_answer": "function flatten_array(arr: any[]): any[] {\n    return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flatten_array(toFlatten) : toFlatten), []);\n}", "assertions": "if (JSON.stringify(flatten_array([1, [2, 3], [[4]]])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed')\nif (JSON.stringify(flatten_array([])) !== JSON.stringify([])) throw new Error('Failed')\nif (JSON.stringify(flatten_array([1, 2, [3, 4, [5]], 6])) !== JSON.stringify([1, 2, 3, 4, 5, 6])) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "flatten_array", "difficulty": "advanced", "category": "data_structures", "complexity": 0.6}}
{"query_id": "synthetic-060", "query_text": "Write a Go function named `find_gcd` that takes two integers and returns their greatest common divisor. Language: Go. Function name: find_gcd", "reference_answer": "func find_gcd(a int, b int) int {\n    if b == 0 {\n        return a\n    }\n    return find_gcd(b, a%b)\n}", "assertions": "if find_gcd(48, 18) != 6 { panic('Failed') }\nif find_gcd(100, 25) != 25 { panic('Failed') }\nif find_gcd(17, 19) != 1 { panic('Failed') }", "metadata": {"language": "Go", "function_name": "find_gcd", "difficulty": "advanced", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-061", "query_text": "Write a Rust function named `is_prime` that takes an integer and returns true if it is a prime number, and false otherwise. Language: Rust. Function name: is_prime", "reference_answer": "fn is_prime(n: u32) -> bool {\n    if n < 2 {\n        return false;\n    }\n    for i in 2..=((n as f64).sqrt() as u32) {\n        if n % i == 0 {\n            return false;\n        }\n    }\n    true\n}", "assertions": "assert_eq!(is_prime(2), true);\nassert_eq!(is_prime(4), false);\nassert_eq!(is_prime(13), true);\nassert_eq!(is_prime(1), false);", "metadata": {"language": "Rust", "function_name": "is_prime", "difficulty": "advanced", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-062", "query_text": "Write a TypeScript function named `debounce` that creates a debounced version of a function. Language: TypeScript. Function name: debounce", "reference_answer": "function debounce(func: Function, wait: number) {\n    let timeout: NodeJS.Timeout;\n    return function(...args: any[]) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n}", "assertions": "let callCount = 0;\nconst debouncedFunc = debounce(() => { callCount++; }, 100);\ndebouncedFunc();\ndebouncedFunc();\nsetTimeout(() => { if (callCount !== 1) throw new Error('Failed') }, 200);", "metadata": {"language": "TypeScript", "function_name": "debounce", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.8}}
{"query_id": "synthetic-063", "query_text": "Write a Python function named `merge_sorted_arrays` that takes two sorted arrays and merges them into a single sorted array. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([], [2, 4]) == [2, 4]\nassert merge_sorted_arrays([1, 2], [3, 4, 5]) == [1, 2, 3, 4, 5]\nassert merge_sorted_arrays([5], []) == [5]\nassert merge_sorted_arrays([], []) == []\nassert merge_sorted_arrays([1, 2, 3], [0, 4, 5]) == [0, 1, 2, 3, 4, 5]", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-064", "query_text": "Write a TypeScript function named `find_unique_numbers` that takes an array of numbers and returns a new array containing only the numbers that appear exactly once. Language: TypeScript. Function name: find_unique_numbers", "reference_answer": "function find_unique_numbers(nums: number[]): number[] {\n    const count: { [key: number]: number } = {};\n    nums.forEach(num => {\n        count[num] = (count[num] || 0) + 1;\n    });\n    return Object.keys(count).filter(num => count[+num] === 1).map(Number);\n}", "assertions": "if (find_unique_numbers([4, 5, 6, 4, 6]) !== [5]) throw new Error(\"Failed\")\nif (JSON.stringify(find_unique_numbers([1, 1, 2, 2, 3, 4])) !== JSON.stringify([3, 4])) throw new Error(\"Failed\")\nif (JSON.stringify(find_unique_numbers([8, 8, 9])) !== JSON.stringify([9])) throw new Error(\"Failed\")\nif (JSON.stringify(find_unique_numbers([])) !== JSON.stringify([])) throw new Error(\"Failed\")\nif (JSON.stringify(find_unique_numbers([7, 7, 10, 10, 11, 12])) !== JSON.stringify([11, 12])) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "find_unique_numbers", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-065", "query_text": "Write a Go function named `is_anagram` that checks if two strings are anagrams of each other. Language: Go. Function name: is_anagram", "reference_answer": "package main\n\nimport \"sort\"\n\nfunc is_anagram(s1, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n    s1Slice := []rune(s1)\n    s2Slice := []rune(s2)\n    sort.Slice(s1Slice, func(i, j int) bool {\n        return s1Slice[i] < s1Slice[j]\n    })\n    sort.Slice(s2Slice, func(i, j int) bool {\n        return s2Slice[i] < s2Slice[j]\n    })\n    return string(s1Slice) == string(s2Slice)\n}", "assertions": "if is_anagram(\"listen\", \"silent\") != true { panic(\"Failed\") }\nif is_anagram(\"hello\", \"world\") != false { panic(\"Failed\") }\nif is_anagram(\"triangle\", \"integral\") != true { panic(\"Failed\") }\nif is_anagram(\"a\", \"a\") != true { panic(\"Failed\") }\nif is_anagram(\"\", \"\") != true { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "is_anagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-066", "query_text": "Write a Rust function named `calculate_gcd` that computes the greatest common divisor of two integers using Euclid's algorithm. Language: Rust. Function name: calculate_gcd", "reference_answer": "fn calculate_gcd(a: u32, b: u32) -> u32 {\n    if b == 0 {\n        a\n    } else {\n        calculate_gcd(b, a % b)\n    }\n}", "assertions": "assert_eq!(calculate_gcd(48, 18), 6);\nassert_eq!(calculate_gcd(101, 103), 1);\nassert_eq!(calculate_gcd(56, 98), 14);\nassert_eq!(calculate_gcd(0, 5), 5);\nassert_eq!(calculate_gcd(5, 0), 5);", "metadata": {"language": "Rust", "function_name": "calculate_gcd", "difficulty": "advanced", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-067", "query_text": "Write a Python function named `longest_common_prefix` that finds the longest common prefix string amongst an array of strings. Language: Python. Function name: longest_common_prefix", "reference_answer": "def longest_common_prefix(strs):\n    if not strs:\n        return ''\n    prefix = strs[0]\n    for s in strs[1:]:\n        while s[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]\n    return prefix", "assertions": "assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longest_common_prefix([\"a\", \"a\", \"a\"]) == \"a\"\nassert longest_common_prefix([]) == \"\"\nassert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"", "metadata": {"language": "Python", "function_name": "longest_common_prefix", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-068", "query_text": "Write a TypeScript function named `flattenArray` that flattens a multidimensional array into a single array. Language: TypeScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr: any[]): any[] {\n    return arr.reduce((flat: any[], toFlatten: any) => {\n        return flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten);\n    }, []);\n}", "assertions": "if (JSON.stringify(flattenArray([1, [2], [3, [4]]])) !== JSON.stringify([1, 2, 3, 4])) throw new Error(\"Failed\")\nif (JSON.stringify(flattenArray([[1, 2], [3, 4]])) !== JSON.stringify([1, 2, 3, 4])) throw new Error(\"Failed\")\nif (JSON.stringify(flattenArray([])) !== JSON.stringify([])) throw new Error(\"Failed\")\nif (JSON.stringify(flattenArray([[[1], [2]], 3])) !== JSON.stringify([1, 2, 3])) throw new Error(\"Failed\")\nif (JSON.stringify(flattenArray([5])) !== JSON.stringify([5])) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "flattenArray", "difficulty": "advanced", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-069", "query_text": "Write a Go function named `calculate_factorial` that calculates the factorial of a number using recursion. Language: Go. Function name: calculate_factorial", "reference_answer": "package main\n\nfunc calculate_factorial(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return n * calculate_factorial(n-1)\n}", "assertions": "if calculate_factorial(5) != 120 { panic(\"Failed\") }\nif calculate_factorial(0) != 1 { panic(\"Failed\") }\nif calculate_factorial(1) != 1 { panic(\"Failed\") }\nif calculate_factorial(3) != 6 { panic(\"Failed\") }\nif calculate_factorial(4) != 24 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "calculate_factorial", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-070", "query_text": "Write a Rust function named `reverse_string` that takes a string and returns it reversed. Language: Rust. Function name: reverse_string", "reference_answer": "fn reverse_string(s: &str) -> String {\n    s.chars().rev().collect()\n}", "assertions": "assert_eq!(reverse_string(\"hello\"), \"olleh\");\nassert_eq!(reverse_string(\"Rust\"), \"tsuR\");\nassert_eq!(reverse_string(\"\"), \"\");\nassert_eq!(reverse_string(\"12345\"), \"54321\");\nassert_eq!(reverse_string(\"abcdefg\"), \"gfedcba\");", "metadata": {"language": "Rust", "function_name": "reverse_string", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-071", "query_text": "Write a Python function named `merge_sorted_arrays` that takes two sorted arrays and merges them into a single sorted array. The function should handle cases where any of the arrays are empty. Language: Python. Function name: merge_sorted_arrays", "reference_answer": "def merge_sorted_arrays(arr1, arr2):\n    merged = []\n    i, j = 0, 0\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    merged.extend(arr1[i:])\n    merged.extend(arr2[j:])\n    return merged", "assertions": "assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_arrays([4, 5, 6], []) == [4, 5, 6]\nassert merge_sorted_arrays([], []) == []\nassert merge_sorted_arrays([1, 2], [3]) == [1, 2, 3]", "metadata": {"language": "Python", "function_name": "merge_sorted_arrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-072", "query_text": "Write a TypeScript function named `capitalizeWords` that takes a string and returns the string with the first letter of each word capitalized. The function should handle edge cases like extra spaces. Language: TypeScript. Function name: capitalizeWords", "reference_answer": "function capitalizeWords(str: string): string {\n    return str\n        .split(' ')\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(' ');\n}", "assertions": "if (capitalizeWords(\"hello world\") !== \"Hello World\") throw new Error(\"Failed\")\nif (capitalizeWords(\"  leading spaces\") !== \"  Leading Spaces\") throw new Error(\"Failed\")\nif (capitalizeWords(\"multiple   spaces\") !== \"Multiple   Spaces\") throw new Error(\"Failed\")\nif (capitalizeWords(\"single\") !== \"Single\") throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "capitalizeWords", "difficulty": "medium", "category": "strings", "complexity": 0.4}}
{"query_id": "synthetic-073", "query_text": "Write a Go function named `sumSlice` that takes a slice of integers and returns their sum. The function should handle empty slices. Language: Go. Function name: sumSlice", "reference_answer": "package main\n\nfunc sumSlice(nums []int) int {\n    sum := 0\n    for _, num := range nums {\n        sum += num\n    }\n    return sum\n}", "assertions": "if sumSlice([]int{1, 2, 3, 4}) != 10 { panic(\"Failed\") }\nif sumSlice([]int{}) != 0 { panic(\"Failed\") }\nif sumSlice([]int{-1, -2, -3}) != -6 { panic(\"Failed\") }\nif sumSlice([]int{10, 0, 2}) != 12 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "sumSlice", "difficulty": "medium", "category": "math", "complexity": 0.3}}
{"query_id": "synthetic-074", "query_text": "Write a Rust function named `reverse_string` that takes a string and returns it reversed. The function should handle single character strings and empty strings. Language: Rust. Function name: reverse_string", "reference_answer": "fn reverse_string(s: &str) -> String {\n    s.chars().rev().collect::<String>()\n}", "assertions": "assert_eq!(reverse_string(\"hello\"), \"olleh\");\nassert_eq!(reverse_string(\"a\"), \"a\");\nassert_eq!(reverse_string(\"\"), \"\");\nassert_eq!(reverse_string(\"racecar\"), \"racecar\");", "metadata": {"language": "Rust", "function_name": "reverse_string", "difficulty": "medium", "category": "strings", "complexity": 0.2}}
{"query_id": "synthetic-075", "query_text": "Write a Python function named `fibonacci` that takes a number n and returns the nth Fibonacci number. The function should handle edge cases like n = 0 and n = 1. Language: Python. Function name: fibonacci", "reference_answer": "def fibonacci(n):\n    if n < 0:\n        raise ValueError(\"Negative arguments are not allowed\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "assertions": "assert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(5) == 5\nassert fibonacci(10) == 55", "metadata": {"language": "Python", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-076", "query_text": "Write a TypeScript function named `isAnagram` that takes two strings and determines if they are anagrams of each other. The function should ignore case and handle spaces. Language: TypeScript. Function name: isAnagram", "reference_answer": "function isAnagram(str1: string, str2: string): boolean {\n    const normalize = (str: string) => str.replace(/\\s/g, '').toLowerCase().split('').sort().join('');\n    return normalize(str1) === normalize(str2);\n}", "assertions": "if (!isAnagram(\"listen\", \"silent\")) throw new Error(\"Failed\")\nif (isAnagram(\"Triangle\", \"Integral\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"Not Anagram\", \"Anagram Not\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"hello\", \"world\") !== false) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "isAnagram", "difficulty": "medium", "category": "strings", "complexity": 0.5}}
{"query_id": "synthetic-077", "query_text": "Write a Go function named `find_max` that takes a slice of integers and returns the maximum value. The function should handle edge cases like an empty slice. Language: Go. Function name: find_max", "reference_answer": "package main\n\nimport \"math\"\n\nfunc find_max(nums []int) int {\n    if len(nums) == 0 {\n        return math.MinInt\n    }\n    max := nums[0]\n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n    }\n    return max\n}", "assertions": "if find_max([]int{1, 2, 3}) != 3 { panic(\"Failed\") }\nif find_max([]int{-1, -2, -3}) != -1 { panic(\"Failed\") }\nif find_max([]int{}) != math.MinInt { panic(\"Failed\") }\nif find_max([]int{7, 5, 6}) != 7 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "find_max", "difficulty": "advanced", "category": "math", "complexity": 0.4}}
{"query_id": "synthetic-078", "query_text": "Write a Rust function named `count_vowels` that takes a string and returns the number of vowels in it. The function should handle edge cases with punctuation and capital letters. Language: Rust. Function name: count_vowels", "reference_answer": "fn count_vowels(s: &str) -> usize {\n    s.chars().filter(|&c| \"aeiouAEIOU\".contains(c)).count()\n}", "assertions": "assert_eq!(count_vowels(\"hello world\"), 3);\nassert_eq!(count_vowels(\"AEIOU\"), 5);\nassert_eq!(count_vowels(\"rhythm\"), 0);\nassert_eq!(count_vowels(\"This is a test.\"), 4);", "metadata": {"language": "Rust", "function_name": "count_vowels", "difficulty": "medium", "category": "strings", "complexity": 0.3}}
{"query_id": "synthetic-079", "query_text": "Write a TypeScript function named `sortArray` that takes an array of numbers and returns a new array sorted in ascending order without using built-in sort methods. Language: TypeScript. Function name: sortArray", "reference_answer": "function sortArray(arr: number[]): number[] {\n    for (let i = 0; i < arr.length; i++) {\n        for (let j = i + 1; j < arr.length; j++) {\n            if (arr[i] > arr[j]) {\n                [arr[i], arr[j]] = [arr[j], arr[i]];\n            }\n        }\n    }\n    return arr;\n}", "assertions": "if (JSON.stringify(sortArray([3, 1, 2])) !== JSON.stringify([1, 2, 3])) throw new Error(\"Failed\")\nif (JSON.stringify(sortArray([])) !== JSON.stringify([])) throw new Error(\"Failed\")\nif (JSON.stringify(sortArray([1])) !== JSON.stringify([1])) throw new Error(\"Failed\")\nif (JSON.stringify(sortArray([5, 3, 8, 1])) !== JSON.stringify([1, 3, 5, 8])) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "sortArray", "difficulty": "advanced", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-080", "query_text": "Write a Python function named `merge_sorted_lists` that takes two sorted lists and merges them into a single sorted list. The function should handle both lists being empty. Language: Python. Function name: merge_sorted_lists", "reference_answer": "def merge_sorted_lists(list1, list2):\n    merged_list = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n    merged_list.extend(list1[i:])\n    merged_list.extend(list2[j:])\n    return merged_list", "assertions": "assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_lists([], [2, 4, 6]) == [2, 4, 6]\nassert merge_sorted_lists([1, 3, 5], []) == [1, 3, 5]\nassert merge_sorted_lists([], []) == []\nassert merge_sorted_lists([0], [0]) == [0, 0]", "metadata": {"language": "Python", "function_name": "merge_sorted_lists", "difficulty": "medium", "category": "algorithms", "complexity": 0.25}}
{"query_id": "synthetic-081", "query_text": "Write a TypeScript function named `countVowels` that takes a string and returns the count of vowels (a, e, i, o, u). The function should handle uppercase vowels as well. Language: TypeScript. Function name: countVowels", "reference_answer": "function countVowels(str: string): number {\n    const vowels = 'aeiouAEIOU';\n    return str.split('').filter(char => vowels.includes(char)).length;\n}", "assertions": "if (countVowels('Hello World') !== 3) throw new Error('Failed')\nif (countVowels('Programming') !== 3) throw new Error('Failed')\nif (countVowels('') !== 0) throw new Error('Failed')\nif (countVowels('xyz') !== 0) throw new Error('Failed')\nif (countVowels('AEIOUaeiou') !== 10) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "countVowels", "difficulty": "medium", "category": "strings", "complexity": 0.2}}
{"query_id": "synthetic-082", "query_text": "Write a Go function named `reverseString` that takes a string and returns its reverse. The function should return an empty string when given an empty string. Language: Go. Function name: reverseString", "reference_answer": "package main\n\nfunc reverseString(s string) string {\n    runes := []rune(s)\n    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n        runes[i], runes[j] = runes[j], runes[i]\n    }\n    return string(runes)\n}", "assertions": "if reverseString('hello') != 'olleh' { panic('Failed') }\nif reverseString('') != '' { panic('Failed') }\nif reverseString('abcd') != 'dcba' { panic('Failed') }\nif reverseString('racecar') != 'racecar' { panic('Failed') }\nif reverseString('A man a plan a canal Panama') != 'amanaP lanac a nalp a namA' { panic('Failed') }", "metadata": {"language": "Go", "function_name": "reverseString", "difficulty": "medium", "category": "strings", "complexity": 0.3}}
{"query_id": "synthetic-083", "query_text": "Write a Rust function named `is_anagram` that checks if two strings are anagrams of each other. The function should ignore case and whitespace. Language: Rust. Function name: is_anagram", "reference_answer": "fn is_anagram(s1: &str, s2: &str) -> bool {\n    let s1_cleaned: String = s1.chars().filter(|c| !c.is_whitespace()).collect::<String>().to_lowercase();\n    let s2_cleaned: String = s2.chars().filter(|c| !c.is_whitespace()).collect::<String>().to_lowercase();\n    let mut s1_chars: Vec<char> = s1_cleaned.chars().collect();\n    let mut s2_chars: Vec<char> = s2_cleaned.chars().collect();\n    s1_chars.sort();\n    s2_chars.sort();\n    s1_chars == s2_chars\n}", "assertions": "assert_eq!(is_anagram(\"listen\", \"silent\"), true);\nassert_eq!(is_anagram(\"hello\", \"world\"), false);\nassert_eq!(is_anagram(\"A gentleman\", \"Elegant man\"), true);\nassert_eq!(is_anagram(\"anagram\", \"nagaram\"), true);\nassert_eq!(is_anagram(\"rat\", \"car\"), false);", "metadata": {"language": "Rust", "function_name": "is_anagram", "difficulty": "medium", "category": "strings", "complexity": 0.4}}
{"query_id": "synthetic-084", "query_text": "Write a JavaScript function named `fibonacci` that takes an integer n and returns the nth Fibonacci number. The function should handle negative inputs by returning -1. Language: JavaScript. Function name: fibonacci", "reference_answer": "function fibonacci(n) {\n    if (n < 0) return -1;\n    let a = 0, b = 1;\n    for (let i = 0; i < n; i++) {\n        [a, b] = [b, a + b];\n    }\n    return a;\n}", "assertions": "if (fibonacci(0) !== 0) throw new Error('Failed')\nif (fibonacci(1) !== 1) throw new Error('Failed')\nif (fibonacci(5) !== 5) throw new Error('Failed')\nif (fibonacci(10) !== 55) throw new Error('Failed')\nif (fibonacci(-1) !== -1) throw new Error('Failed')", "metadata": {"language": "JavaScript", "function_name": "fibonacci", "difficulty": "medium", "category": "math", "complexity": 0.3}}
{"query_id": "synthetic-085", "query_text": "Write a TypeScript function named `flattenArray` that takes a nested array and flattens it into a single-dimensional array. Language: TypeScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr: any[]): any[] {\n    return arr.reduce((flat, toFlatten) => {\n        return flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten);\n    }, []);\n}", "assertions": "if (JSON.stringify(flattenArray([1, [2, [3, 4]], 5])) !== JSON.stringify([1, 2, 3, 4, 5])) throw new Error('Failed')\nif (JSON.stringify(flattenArray([])) !== JSON.stringify([])) throw new Error('Failed')\nif (JSON.stringify(flattenArray([[1, 2], [3, 4]])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed')\nif (JSON.stringify(flattenArray([1, [2, 3], 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed')\nif (JSON.stringify(flattenArray([[[]]])) !== JSON.stringify([])) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "flattenArray", "difficulty": "advanced", "category": "arrays", "complexity": 0.5}}
{"query_id": "synthetic-086", "query_text": "Write a Python function named `calculate_mean` that takes a list of numbers and returns the mean of the list. The function should handle empty lists by returning 0. Language: Python. Function name: calculate_mean", "reference_answer": "def calculate_mean(numbers):\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)", "assertions": "assert calculate_mean([1, 2, 3, 4, 5]) == 3.0\nassert calculate_mean([]) == 0\nassert calculate_mean([10, 20, 30]) == 20.0\nassert calculate_mean([1.5, 2.5, 3.0]) == 2.0\nassert calculate_mean([-1, 0, 1]) == 0.0", "metadata": {"language": "Python", "function_name": "calculate_mean", "difficulty": "medium", "category": "math", "complexity": 0.2}}
{"query_id": "synthetic-087", "query_text": "Write a Java function named `isPalindrome` that checks if the given string is a palindrome. The function should return false for non-string inputs. Language: Java. Function name: isPalindrome", "reference_answer": "public class Palindrome {\n    public static boolean isPalindrome(Object obj) {\n        if (!(obj instanceof String)) {\n            return false;\n        }\n        String str = (String) obj;\n        String reversed = new StringBuilder(str).reverse().toString();\n        return str.equals(reversed);\n    }\n}", "assertions": "assert isPalindrome(\"racecar\") == true;\nassert isPalindrome(\"hello\") == false;\nassert isPalindrome(123) == false;\nassert isPalindrome(null) == false;\nassert isPalindrome(\"A man a plan a canal Panama\") == false;", "metadata": {"language": "Java", "function_name": "isPalindrome", "difficulty": "medium", "category": "strings", "complexity": 0.4}}
{"query_id": "synthetic-088", "query_text": "Write a C++ function named `find_maximum` that takes a vector of integers and returns the maximum value. The function should return `INT_MIN` for empty vectors. Language: C++. Function name: find_maximum", "reference_answer": "#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\nint find_maximum(vector<int>& nums) {\n    if (nums.empty()) return INT_MIN;\n    int max_val = nums[0];\n    for(int i = 1; i < nums.size(); i++) {\n        if(nums[i] > max_val) {\n            max_val = nums[i];\n        }\n    }\n    return max_val;\n}", "assertions": "assert find_maximum({1, 2, 3, 4, 5}) == 5;\nassert find_maximum({-1, -2, -3}) == -1;\nassert find_maximum({}) == INT_MIN;\nassert find_maximum({100, 200, 300}) == 300;\nassert find_maximum({0}) == 0;", "metadata": {"language": "C++", "function_name": "find_maximum", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-089", "query_text": "Write a Python function named `merge_intervals` that takes a list of intervals and merges any overlapping intervals into one. The function should handle edge cases like empty lists. Language: Python. Function name: merge_intervals", "reference_answer": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last_merged = merged[-1]\n        if current[0] <= last_merged[1]:\n            last_merged[1] = max(last_merged[1], current[1])\n        else:\n            merged.append(current)\n    return merged", "assertions": "assert merge_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\nassert merge_intervals([[1,4],[4,5]]) == [[1,5]]\nassert merge_intervals([]) == []\nassert merge_intervals([[1,2],[3,4],[5,6]]) == [[1,2],[3,4],[5,6]]\nassert merge_intervals([[1,3],[2,4],[5,7],[6,8]]) == [[1,4],[5,8]]", "metadata": {"language": "Python", "function_name": "merge_intervals", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-090", "query_text": "Write a TypeScript function named `isAnagram` that determines if two strings are anagrams of each other. The function should handle edge cases like empty strings. Language: TypeScript. Function name: isAnagram", "reference_answer": "function isAnagram(str1: string, str2: string): boolean {\n    const normalize = (str: string) => str.split('').sort().join('');\n    return normalize(str1) === normalize(str2);\n}", "assertions": "if (isAnagram(\"listen\", \"silent\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"hello\", \"world\") !== false) throw new Error(\"Failed\")\nif (isAnagram(\"\", \"\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"a\", \"a\") !== true) throw new Error(\"Failed\")\nif (isAnagram(\"rat\", \"car\") !== false) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "isAnagram", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-091", "query_text": "Write a Go function named `rotateSlice` that rotates a slice of integers to the right by k positions. Handle cases where k is greater than the length of the slice. Language: Go. Function name: rotateSlice", "reference_answer": "package main\n\nfunc rotateSlice(nums []int, k int) []int {\n    n := len(nums)\n    if n == 0 {\n        return nums\n    }\n    k = k % n\n    return append(nums[n-k:], nums[:n-k]...)\n}", "assertions": "if rotateSlice([]int{1,2,3,4,5}, 2) != []int{4,5,1,2,3} { panic(\"Failed\") }\nif rotateSlice([]int{1,2,3,4,5}, 5) != []int{1,2,3,4,5} { panic(\"Failed\") }\nif rotateSlice([]int{}, 1) != []int{} { panic(\"Failed\") }\nif rotateSlice([]int{1}, 1) != []int{1} { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "rotateSlice", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-092", "query_text": "Write a Rust function named `unique_numbers` that takes a vector of integers and returns a new vector with only the unique numbers. The function should handle cases with no input or all duplicates. Language: Rust. Function name: unique_numbers", "reference_answer": "fn unique_numbers(nums: Vec<i32>) -> Vec<i32> {\n    let mut unique = std::collections::HashSet::new();\n    nums.into_iter().filter(|x| unique.insert(*x)).collect()\n}", "assertions": "assert_eq!(unique_numbers(vec![1,2,3,1,2]), vec![1,2,3]);\nassert_eq!(unique_numbers(vec![]), vec![]);\nassert_eq!(unique_numbers(vec![5,5,5]), vec![5]);\nassert_eq!(unique_numbers(vec![1,2,3,4]), vec![1,2,3,4]);", "metadata": {"language": "Rust", "function_name": "unique_numbers", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-093", "query_text": "Write a Python function named `count_occurrences` that counts the number of occurrences of each element in a list. The function should handle edge cases like empty lists. Language: Python. Function name: count_occurrences", "reference_answer": "from collections import Counter\n\ndef count_occurrences(lst):\n    return dict(Counter(lst))", "assertions": "assert count_occurrences([1,2,2,3]) == {1: 1, 2: 2, 3: 1}\nassert count_occurrences([]) == {}\nassert count_occurrences([\"a\",\"b\",\"a\"]) == {\"a\": 2, \"b\": 1}\nassert count_occurrences([True, False, True]) == {True: 2, False: 1}", "metadata": {"language": "Python", "function_name": "count_occurrences", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-094", "query_text": "Write a TypeScript function named `mergeSortedArrays` that merges two sorted arrays into one sorted array. Handle edge cases with empty arrays. Language: TypeScript. Function name: mergeSortedArrays", "reference_answer": "function mergeSortedArrays(arr1: number[], arr2: number[]): number[] {\n    let merged: number[] = [];\n    let i = 0, j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        if (arr1[i] < arr2[j]) {\n            merged.push(arr1[i]);\n            i++;\n        } else {\n            merged.push(arr2[j]);\n            j++;\n        }\n    }\n    return merged.concat(arr1.slice(i)).concat(arr2.slice(j));\n}", "assertions": "if (JSON.stringify(mergeSortedArrays([1,3,5],[2,4,6])) !== JSON.stringify([1,2,3,4,5,6])) throw new Error(\"Failed\")\nif (JSON.stringify(mergeSortedArrays([],[2,4,6])) !== JSON.stringify([2,4,6])) throw new Error(\"Failed\")\nif (JSON.stringify(mergeSortedArrays([1,3,5],[])) !== JSON.stringify([1,3,5])) throw new Error(\"Failed\")\nif (JSON.stringify(mergeSortedArrays([],[])) !== JSON.stringify([])) throw new Error(\"Failed\")", "metadata": {"language": "TypeScript", "function_name": "mergeSortedArrays", "difficulty": "medium", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-095", "query_text": "Write a Go function named `containsDuplicate` that checks if an array contains any duplicates. Handle edge cases with empty arrays or single elements. Language: Go. Function name: containsDuplicate", "reference_answer": "package main\n\nfunc containsDuplicate(nums []int) bool {\n    seen := make(map[int]bool)\n    for _, num := range nums {\n        if seen[num] {\n            return true\n        }\n        seen[num] = true\n    }\n    return false\n}", "assertions": "if containsDuplicate([]int{1,2,3,1}) != true { panic(\"Failed\") }\nif containsDuplicate([]int{1,2,3,4}) != false { panic(\"Failed\") }\nif containsDuplicate([]int{}) != false { panic(\"Failed\") }\nif containsDuplicate([]int{5}) != false { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "containsDuplicate", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-096", "query_text": "Write a Rust function named `fibonacci` that returns the nth Fibonacci number. Handle edge cases for n less than 0. Language: Rust. Function name: fibonacci", "reference_answer": "fn fibonacci(n: i32) -> i32 {\n    if n < 0 {\n        panic!(\"Negative input!\");\n    }\n    let (mut a, mut b) = (0, 1);\n    for _ in 0..n {\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n    a\n}", "assertions": "assert_eq!(fibonacci(0), 0);\nassert_eq!(fibonacci(1), 1);\nassert_eq!(fibonacci(5), 5);\nassert_eq!(fibonacci(10), 55);", "metadata": {"language": "Rust", "function_name": "fibonacci", "difficulty": "advanced", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-097", "query_text": "Write a Python function named `fibonacci` that takes a non-negative integer n and returns the nth Fibonacci number. Language: Python. Function name: fibonacci", "reference_answer": "def fibonacci(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "assertions": "assert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(10) == 55", "metadata": {"language": "Python", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-098", "query_text": "Write a TypeScript function named `countVowels` that takes a string and returns the number of vowels in it. Language: TypeScript. Function name: countVowels", "reference_answer": "function countVowels(s: string): number {\n    const vowels = 'aeiouAEIOU';\n    let count = 0;\n    for (let char of s) {\n        if (vowels.includes(char)) {\n            count++;\n        }\n    }\n    return count;\n}", "assertions": "if (countVowels('hello') !== 2) throw new Error('Failed')\nif (countVowels('xyz') !== 0) throw new Error('Failed')\nif (countVowels('aeiou') !== 5) throw new Error('Failed')\nif (countVowels('AEIoU') !== 5) throw new Error('Failed')", "metadata": {"language": "TypeScript", "function_name": "countVowels", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-099", "query_text": "Write a Go function named `mergeSortedArrays` that takes two sorted arrays and merges them into a single sorted array. Language: Go. Function name: mergeSortedArrays", "reference_answer": "package main\n\nfunc mergeSortedArrays(arr1 []int, arr2 []int) []int {\n    merged := make([]int, 0, len(arr1)+len(arr2))\n    i, j := 0, 0\n    for i < len(arr1) && j < len(arr2) {\n        if arr1[i] < arr2[j] {\n            merged = append(merged, arr1[i])\n            i++\n        } else {\n            merged = append(merged, arr2[j])\n            j++\n        }\n    }\n    merged = append(merged, arr1[i:]...)\n    merged = append(merged, arr2[j:]...)\n    return merged\n}", "assertions": "if len(mergeSortedArrays([]int{1, 3, 5}, []int{2, 4, 6})) != 6 { panic('Failed') }\nif len(mergeSortedArrays([]int{}, []int{2, 4, 6})) != 3 { panic('Failed') }\nif len(mergeSortedArrays([]int{1, 2}, []int{})) != 2 { panic('Failed') }", "metadata": {"language": "Go", "function_name": "mergeSortedArrays", "difficulty": "advanced", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-100", "query_text": "Write a Rust function named `is_anagram` that checks if two strings are anagrams of each other. Language: Rust. Function name: is_anagram", "reference_answer": "fn is_anagram(s1: &str, s2: &str) -> bool {\n    let mut chars1: Vec<char> = s1.chars().collect();\n    let mut chars2: Vec<char> = s2.chars().collect();\n    chars1.sort();\n    chars2.sort();\n    chars1 == chars2\n}", "assertions": "assert_eq!(is_anagram(\"listen\", \"silent\"), true);\nassert_eq!(is_anagram(\"hello\", \"world\"), false);\nassert_eq!(is_anagram(\"triangle\", \"integral\"), true);\nassert_eq!(is_anagram(\"\",\"\"), true);", "metadata": {"language": "Rust", "function_name": "is_anagram", "difficulty": "medium", "category": "strings", "complexity": 0.4}}
