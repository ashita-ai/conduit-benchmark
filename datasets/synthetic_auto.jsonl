{"query_id": "synthetic-001", "query_text": "Write a Python function named `two_sum` that takes an array of integers and a target sum, and returns indices of the two numbers that add up to the target. Language: Python. Function name: two_sum", "reference_answer": "def two_sum(nums: list[int], target: int) -> list[int]:\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n    return []", "assertions": "assert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 2, 4], 6) == [1, 2]\nassert two_sum([3, 3], 6) == [0, 1]\nassert two_sum([1, 2, 3], 10) == []", "metadata": {"language": "Python", "function_name": "two_sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-002", "query_text": "Write a Python function named `is_valid_parentheses` that checks if a string containing only parentheses characters is valid. Valid means every opening parenthesis has a corresponding closing parenthesis. Language: Python. Function name: is_valid_parentheses", "reference_answer": "def is_valid_parentheses(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return not stack", "assertions": "assert is_valid_parentheses(\"()\") == True\nassert is_valid_parentheses(\"()[]{}\") == True\nassert is_valid_parentheses(\"(]\") == False\nassert is_valid_parentheses(\"([)]\") == False\nassert is_valid_parentheses(\"{[]}\") == True\nassert is_valid_parentheses(\"\") == True", "metadata": {"language": "Python", "function_name": "is_valid_parentheses", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-003", "query_text": "Write a Python function named `merge_intervals` that takes a list of intervals and merges all overlapping intervals. Each interval is a list of two integers. Language: Python. Function name: merge_intervals", "reference_answer": "def merge_intervals(intervals: list[list[int]]) -> list[list[int]]:\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        if current[0] <= merged[-1][1]:\n            merged[-1] = [merged[-1][0], max(merged[-1][1], current[1])]\n        else:\n            merged.append(current)\n    return merged", "assertions": "assert merge_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\nassert merge_intervals([[1,4],[4,5]]) == [[1,5]]\nassert merge_intervals([]) == []\nassert merge_intervals([[1,2]]) == [[1,2]]", "metadata": {"language": "Python", "function_name": "merge_intervals", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-004", "query_text": "Write a TypeScript function named `reverseString` that reverses a string. Language: TypeScript. Function name: reverseString", "reference_answer": "function reverseString(s: string): string {\n    return s.split('').reverse().join('');\n}", "assertions": "if (reverseString('hello') !== 'olleh') throw new Error('Failed');\nif (reverseString('world') !== 'dlrow') throw new Error('Failed');\nif (reverseString('') !== '') throw new Error('Failed');\nif (reverseString('a') !== 'a') throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "reverseString", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.2}}
{"query_id": "synthetic-005", "query_text": "Write a TypeScript function named `findMax` that finds the maximum number in an array. Language: TypeScript. Function name: findMax", "reference_answer": "function findMax(nums: number[]): number | null {\n    if (nums.length === 0) return null;\n    return Math.max(...nums);\n}", "assertions": "if (findMax([1, 5, 3, 9, 2]) !== 9) throw new Error('Failed');\nif (findMax([10]) !== 10) throw new Error('Failed');\nif (findMax([]) !== null) throw new Error('Failed');\nif (findMax([-5, -2, -10]) !== -2) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "findMax", "difficulty": "medium", "category": "algorithms", "complexity": 0.25}}
{"query_id": "synthetic-006", "query_text": "Write a TypeScript function named `isPalindrome` that checks if a string is a palindrome. Language: TypeScript. Function name: isPalindrome", "reference_answer": "function isPalindrome(s: string): boolean {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return cleaned === cleaned.split('').reverse().join('');\n}", "assertions": "if (isPalindrome('racecar') !== true) throw new Error('Failed');\nif (isPalindrome('hello') !== false) throw new Error('Failed');\nif (isPalindrome('A man a plan a canal Panama') !== true) throw new Error('Failed');\nif (isPalindrome('') !== true) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "isPalindrome", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-007", "query_text": "Write a Python function named `binary_search` that performs binary search on a sorted list and returns the index of the target, or -1 if not found. Language: Python. Function name: binary_search", "reference_answer": "def binary_search(arr: list[int], target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "assertions": "assert binary_search([1, 2, 3, 4, 5], 3) == 2\nassert binary_search([1, 2, 3, 4, 5], 1) == 0\nassert binary_search([1, 2, 3, 4, 5], 5) == 4\nassert binary_search([1, 2, 3, 4, 5], 6) == -1\nassert binary_search([], 1) == -1", "metadata": {"language": "Python", "function_name": "binary_search", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-008", "query_text": "Write a Python function named `fibonacci` that calculates the nth Fibonacci number using memoization. Language: Python. Function name: fibonacci", "reference_answer": "def fibonacci(n: int, memo: dict[int, int] = None) -> int:\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]", "assertions": "assert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(5) == 5\nassert fibonacci(10) == 55\nassert fibonacci(15) == 610", "metadata": {"language": "Python", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-009", "query_text": "Write a TypeScript function named `groupBy` that groups array elements by a key function. Language: TypeScript. Function name: groupBy", "reference_answer": "function groupBy<T>(arr: T[], keyFn: (item: T) => string): Record<string, T[]> {\n    return arr.reduce((groups, item) => {\n        const key = keyFn(item);\n        if (!groups[key]) groups[key] = [];\n        groups[key].push(item);\n        return groups;\n    }, {} as Record<string, T[]>);\n}", "assertions": "const result1 = groupBy([1, 2, 3, 4, 5, 6], n => n % 2 === 0 ? 'even' : 'odd');\nif (result1['even'].length !== 3 || result1['odd'].length !== 3) throw new Error('Failed');\nconst result2 = groupBy(['apple', 'banana', 'apricot'], s => s[0]);\nif (result2['a'].length !== 2 || result2['b'].length !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "groupBy", "difficulty": "medium", "category": "data_structures", "complexity": 0.55}}
{"query_id": "synthetic-010", "query_text": "Write a Go function named `Sum` that calculates the sum of integers in a slice. Language: Go. Function name: Sum", "reference_answer": "package main\n\nfunc Sum(nums []int) int {\n\ttotal := 0\n\tfor _, num := range nums {\n\t\ttotal += num\n\t}\n\treturn total\n}", "assertions": "if Sum([]int{1, 2, 3, 4, 5}) != 15 { panic(\"Failed\") }\nif Sum([]int{}) != 0 { panic(\"Failed\") }\nif Sum([]int{-1, -2, -3}) != -6 { panic(\"Failed\") }\nif Sum([]int{100}) != 100 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Sum", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-011", "query_text": "Write a Go function named `Contains` that checks if a slice contains a value. Language: Go. Function name: Contains", "reference_answer": "package main\n\nfunc Contains(nums []int, target int) bool {\n\tfor _, num := range nums {\n\t\tif num == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}", "assertions": "if Contains([]int{1, 2, 3, 4, 5}, 3) != true { panic(\"Failed\") }\nif Contains([]int{1, 2, 3, 4, 5}, 6) != false { panic(\"Failed\") }\nif Contains([]int{}, 1) != false { panic(\"Failed\") }\nif Contains([]int{10}, 10) != true { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Contains", "difficulty": "medium", "category": "algorithms", "complexity": 0.25}}
{"query_id": "synthetic-012", "query_text": "Write a Rust function named `sum_vec` that calculates the sum of integers in a vector. Language: Rust. Function name: sum_vec", "reference_answer": "pub fn sum_vec(nums: &[i32]) -> i32 {\n    nums.iter().sum()\n}", "assertions": "assert_eq!(sum_vec(&[1, 2, 3, 4, 5]), 15);\nassert_eq!(sum_vec(&[]), 0);\nassert_eq!(sum_vec(&[-1, -2, -3]), -6);\nassert_eq!(sum_vec(&[100]), 100);", "metadata": {"language": "Rust", "function_name": "sum_vec", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-013", "query_text": "Write a Rust function named `contains` that checks if a vector contains a value. Language: Rust. Function name: contains", "reference_answer": "pub fn contains(nums: &[i32], target: i32) -> bool {\n    nums.iter().any(|&x| x == target)\n}", "assertions": "assert_eq!(contains(&[1, 2, 3, 4, 5], 3), true);\nassert_eq!(contains(&[1, 2, 3, 4, 5], 6), false);\nassert_eq!(contains(&[], 1), false);\nassert_eq!(contains(&[10], 10), true);", "metadata": {"language": "Rust", "function_name": "contains", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-014", "query_text": "Write a Java function named `factorial` that calculates the factorial of a number. Language: Java. Function name: factorial", "reference_answer": "public class Solution {\n    public static long factorial(int n) {\n        if (n <= 1) return 1;\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}", "assertions": "if (Solution.factorial(0) != 1) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(1) != 1) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(5) != 120) throw new RuntimeException(\"Failed\");\nif (Solution.factorial(10) != 3628800) throw new RuntimeException(\"Failed\");", "metadata": {"language": "Java", "function_name": "factorial", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-015", "query_text": "Write a JavaScript function named `flattenArray` that flattens a nested array. Language: JavaScript. Function name: flattenArray", "reference_answer": "function flattenArray(arr) {\n    return arr.flat(Infinity);\n}", "assertions": "const result1 = flattenArray([1, [2, [3, 4], 5], 6]);\nif (JSON.stringify(result1) !== JSON.stringify([1, 2, 3, 4, 5, 6])) throw new Error('Failed');\nconst result2 = flattenArray([1, 2, 3]);\nif (JSON.stringify(result2) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nconst result3 = flattenArray([]);\nif (JSON.stringify(result3) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "JavaScript", "function_name": "flattenArray", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-016", "query_text": "Write a Python function named `max_subarray` that finds the contiguous subarray with the largest sum using Kadane's algorithm. Language: Python. Function name: max_subarray", "reference_answer": "def max_subarray(nums: list[int]) -> int:\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "assertions": "assert max_subarray([-2,1,-3,4,-1,2,1,-5,4]) == 6\nassert max_subarray([1]) == 1\nassert max_subarray([5,4,-1,7,8]) == 23\nassert max_subarray([-1]) == -1", "metadata": {"language": "Python", "function_name": "max_subarray", "difficulty": "medium", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-017", "query_text": "Write a TypeScript function named `debounce` that creates a debounced version of a function. Language: TypeScript. Function name: debounce", "reference_answer": "function debounce<T extends (...args: any[]) => void>(func: T, wait: number): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout | null = null;\n    return (...args: Parameters<T>) => {\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(() => func(...args), wait);\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst debouncedIncrement = debounce(increment, 100);\ndebouncedIncrement();\ndebouncedIncrement();\ndebouncedIncrement();\nsetTimeout(() => {\n    if (counter !== 1) throw new Error('Failed');\n}, 150);", "metadata": {"language": "TypeScript", "function_name": "debounce", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-018", "query_text": "Write a TypeScript function named `deepClone` that performs a deep clone of an object. Language: TypeScript. Function name: deepClone", "reference_answer": "function deepClone<T>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (obj instanceof Date) return new Date(obj.getTime()) as any;\n    if (obj instanceof Array) return obj.map(item => deepClone(item)) as any;\n    const cloned: any = {};\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            cloned[key] = deepClone((obj as any)[key]);\n        }\n    }\n    return cloned;\n}", "assertions": "const original = { a: 1, b: { c: 2, d: [3, 4] } };\nconst cloned = deepClone(original);\nif (cloned.b.c !== 2 || cloned.b.d[0] !== 3) throw new Error('Failed');\ncloned.b.c = 99;\nif (original.b.c === 99) throw new Error('Failed - not deep cloned');", "metadata": {"language": "TypeScript", "function_name": "deepClone", "difficulty": "advanced", "category": "data_structures", "complexity": 0.75}}
{"query_id": "synthetic-019", "query_text": "Write a Python function named `quicksort` that implements the quicksort algorithm to sort a list. Language: Python. Function name: quicksort", "reference_answer": "def quicksort(arr: list[int]) -> list[int]:\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)", "assertions": "assert quicksort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\nassert quicksort([]) == []\nassert quicksort([1]) == [1]\nassert quicksort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]", "metadata": {"language": "Python", "function_name": "quicksort", "difficulty": "advanced", "category": "sorting", "complexity": 0.7}}
{"query_id": "synthetic-020", "query_text": "Write a Python function named `lcs` that finds the longest common subsequence of two strings using dynamic programming. Language: Python. Function name: lcs", "reference_answer": "def lcs(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [['' for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + s1[i-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n    \n    return dp[m][n]", "assertions": "assert lcs('ABCDGH', 'AEDFHR') == 'ADH'\nassert lcs('AGGTAB', 'GXTXAYB') == 'GTAB'\nassert lcs('', 'ABC') == ''\nassert lcs('ABC', '') == ''\nassert lcs('ABC', 'ABC') == 'ABC'", "metadata": {"language": "Python", "function_name": "lcs", "difficulty": "advanced", "category": "dynamic_programming", "complexity": 0.75}}
{"query_id": "synthetic-021", "query_text": "Write a Python function named `build_trie` that builds a trie data structure from a list of words. Language: Python. Function name: build_trie", "reference_answer": "def build_trie(words: list[str]) -> dict:\n    root = {}\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    return root", "assertions": "trie = build_trie(['cat', 'car', 'dog'])\nassert 'c' in trie and 'a' in trie['c'] and 't' in trie['c']['a']\nassert 'd' in trie and 'o' in trie['d'] and 'g' in trie['d']['o']\nassert '$' in trie['c']['a']['t'] and '$' in trie['c']['a']['r']\ntrie2 = build_trie([])\nassert trie2 == {}", "metadata": {"language": "Python", "function_name": "build_trie", "difficulty": "advanced", "category": "data_structures", "complexity": 0.7}}
{"query_id": "synthetic-022", "query_text": "Write a TypeScript function named `throttle` that creates a throttled version of a function that executes at most once per time period. Language: TypeScript. Function name: throttle", "reference_answer": "function throttle<T extends (...args: any[]) => void>(func: T, limit: number): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n        if (!inThrottle) {\n            func(...args);\n            inThrottle = true;\n            setTimeout(() => inThrottle = false, limit);\n        }\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst throttledIncrement = throttle(increment, 100);\nthrottledIncrement();\nthrottledIncrement();\nthrottledIncrement();\nsetTimeout(() => {\n    if (counter < 1 || counter > 2) throw new Error('Failed');\n}, 150);", "metadata": {"language": "TypeScript", "function_name": "throttle", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-023", "query_text": "Write a Python function named `reverse_linked_list` that reverses a singly linked list. Assume a Node class with val and next attributes. Language: Python. Function name: reverse_linked_list", "reference_answer": "class Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head: Node) -> Node:\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev", "assertions": "def list_to_linked_list(arr):\n    if not arr: return None\n    head = Node(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\nassert linked_list_to_list(reverse_linked_list(list_to_linked_list([1, 2, 3]))) == [3, 2, 1]\nassert linked_list_to_list(reverse_linked_list(list_to_linked_list([]))) == []\nassert linked_list_to_list(reverse_linked_list(list_to_linked_list([1]))) == [1]", "metadata": {"language": "Python", "function_name": "reverse_linked_list", "difficulty": "advanced", "category": "data_structures", "complexity": 0.65}}
{"query_id": "synthetic-024", "query_text": "Write a TypeScript function named `memoize` that creates a memoized version of a function. Language: TypeScript. Function name: memoize", "reference_answer": "function memoize<T extends (...args: any[]) => any>(fn: T): T {\n    const cache = new Map<string, ReturnType<T>>();\n    return ((...args: Parameters<T>) => {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    }) as T;\n}", "assertions": "let callCount = 0;\nconst expensive = (n: number) => { callCount++; return n * 2; };\nconst memoized = memoize(expensive);\nif (memoized(5) !== 10) throw new Error('Failed');\nif (memoized(5) !== 10) throw new Error('Failed');\nif (callCount !== 1) throw new Error('Failed - not memoized');", "metadata": {"language": "TypeScript", "function_name": "memoize", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-025", "query_text": "Write a Python function named `find_duplicates` that finds all duplicate elements in a list. Language: Python. Function name: find_duplicates", "reference_answer": "def find_duplicates(nums: list[int]) -> list[int]:\n    seen = set()\n    duplicates = set()\n    for num in nums:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    return sorted(list(duplicates))", "assertions": "assert find_duplicates([1, 2, 3, 2, 4, 1]) == [1, 2]\nassert find_duplicates([1, 1, 1, 1]) == [1]\nassert find_duplicates([1, 2, 3, 4, 5]) == []\nassert find_duplicates([]) == []\nassert find_duplicates([5, 5, 6, 6, 7]) == [5, 6]", "metadata": {"language": "Python", "function_name": "find_duplicates", "difficulty": "medium", "category": "data_structures", "complexity": 0.3}}
{"query_id": "synthetic-026", "query_text": "Write a TypeScript function named `chunk` that splits an array into chunks of a specified size. Language: TypeScript. Function name: chunk", "reference_answer": "function chunk<T>(arr: T[], size: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < arr.length; i += size) {\n        chunks.push(arr.slice(i, i + size));\n    }\n    return chunks;\n}", "assertions": "if (JSON.stringify(chunk([1, 2, 3, 4, 5], 2)) !== JSON.stringify([[1, 2], [3, 4], [5]])) throw new Error('Failed');\nif (JSON.stringify(chunk([1, 2, 3, 4, 5], 3)) !== JSON.stringify([[1, 2, 3], [4, 5]])) throw new Error('Failed');\nif (JSON.stringify(chunk([], 2)) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "chunk", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-027", "query_text": "Write a Python function named `merge_sorted_lists` that merges two sorted lists into one sorted list. Language: Python. Function name: merge_sorted_lists", "reference_answer": "def merge_sorted_lists(list1: list[int], list2: list[int]) -> list[int]:\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result", "assertions": "assert merge_sorted_lists([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6]\nassert merge_sorted_lists([], [1, 2, 3]) == [1, 2, 3]\nassert merge_sorted_lists([1, 2, 3], []) == [1, 2, 3]\nassert merge_sorted_lists([1], [2]) == [1, 2]", "metadata": {"language": "Python", "function_name": "merge_sorted_lists", "difficulty": "medium", "category": "algorithms", "complexity": 0.4}}
{"query_id": "synthetic-028", "query_text": "Write a TypeScript function named `removeDuplicates` that removes duplicates from an array. Language: TypeScript. Function name: removeDuplicates", "reference_answer": "function removeDuplicates<T>(arr: T[]): T[] {\n    return Array.from(new Set(arr));\n}", "assertions": "if (JSON.stringify(removeDuplicates([1, 2, 2, 3, 3, 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(removeDuplicates(['a', 'b', 'a', 'c'])) !== JSON.stringify(['a', 'b', 'c'])) throw new Error('Failed');\nif (JSON.stringify(removeDuplicates([])) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "removeDuplicates", "difficulty": "medium", "category": "data_structures", "complexity": 0.3}}
{"query_id": "synthetic-029", "query_text": "Write a Go function named `Reverse` that reverses a slice of integers. Language: Go. Function name: Reverse", "reference_answer": "package main\n\nfunc Reverse(nums []int) []int {\n\tresult := make([]int, len(nums))\n\tfor i, num := range nums {\n\t\tresult[len(nums)-1-i] = num\n\t}\n\treturn result\n}", "assertions": "result1 := Reverse([]int{1, 2, 3, 4, 5})\nif len(result1) != 5 || result1[0] != 5 || result1[4] != 1 { panic(\"Failed\") }\nresult2 := Reverse([]int{})\nif len(result2) != 0 { panic(\"Failed\") }\nresult3 := Reverse([]int{10})\nif result3[0] != 10 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Reverse", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-030", "query_text": "Write a Go function named `Max` that finds the maximum value in a slice of integers. Language: Go. Function name: Max", "reference_answer": "package main\n\nfunc Max(nums []int) int {\n\tif len(nums) == 0 {\n\t\tpanic(\"empty slice\")\n\t}\n\tmax := nums[0]\n\tfor _, num := range nums[1:] {\n\t\tif num > max {\n\t\t\tmax = num\n\t\t}\n\t}\n\treturn max\n}", "assertions": "if Max([]int{1, 5, 3, 9, 2}) != 9 { panic(\"Failed\") }\nif Max([]int{10}) != 10 { panic(\"Failed\") }\nif Max([]int{-5, -2, -10}) != -2 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Max", "difficulty": "medium", "category": "algorithms", "complexity": 0.3}}
{"query_id": "synthetic-031", "query_text": "Write a Rust function named `reverse_vec` that reverses a vector of integers. Language: Rust. Function name: reverse_vec", "reference_answer": "pub fn reverse_vec(nums: &mut [i32]) {\n    let len = nums.len();\n    for i in 0..len / 2 {\n        nums.swap(i, len - 1 - i);\n    }\n}", "assertions": "let mut v1 = vec![1, 2, 3, 4, 5];\nreverse_vec(&mut v1);\nassert_eq!(v1, vec![5, 4, 3, 2, 1]);\nlet mut v2 = vec![];\nreverse_vec(&mut v2);\nassert_eq!(v2, vec![]);\nlet mut v3 = vec![10];\nreverse_vec(&mut v3);\nassert_eq!(v3, vec![10]);", "metadata": {"language": "Rust", "function_name": "reverse_vec", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-032", "query_text": "Write a C++ function named `factorial` that calculates the factorial of a number. Language: C++. Function name: factorial", "reference_answer": "#include <iostream>\nusing namespace std;\n\nlong long factorial(int n) {\n    if (n <= 1) return 1;\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}", "assertions": "if (factorial(0) != 1) throw runtime_error(\"Failed\");\nif (factorial(1) != 1) throw runtime_error(\"Failed\");\nif (factorial(5) != 120) throw runtime_error(\"Failed\");\nif (factorial(10) != 3628800) throw runtime_error(\"Failed\");", "metadata": {"language": "C++", "function_name": "factorial", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-033", "query_text": "Write a Ruby function named `palindrome?` that checks if a string is a palindrome. Language: Ruby. Function name: palindrome?", "reference_answer": "def palindrome?(str)\n  cleaned = str.downcase.gsub(/[^a-z0-9]/, '')\n  cleaned == cleaned.reverse\nend", "assertions": "if palindrome?('racecar') != true then raise 'Failed' end\nif palindrome?('hello') != false then raise 'Failed' end\nif palindrome?('A man a plan a canal Panama') != true then raise 'Failed' end\nif palindrome?('') != true then raise 'Failed' end", "metadata": {"language": "Ruby", "function_name": "palindrome?", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.4}}
{"query_id": "synthetic-034", "query_text": "Write a Swift function named `fibonacci` that calculates the nth Fibonacci number. Language: Swift. Function name: fibonacci", "reference_answer": "func fibonacci(_ n: Int) -> Int {\n    if n <= 1 {\n        return n\n    }\n    var a = 0, b = 1\n    for _ in 2...n {\n        let temp = a + b\n        a = b\n        b = temp\n    }\n    return b\n}", "assertions": "if fibonacci(0) != 0 { fatalError(\"Failed\") }\nif fibonacci(1) != 1 { fatalError(\"Failed\") }\nif fibonacci(5) != 5 { fatalError(\"Failed\") }\nif fibonacci(10) != 55 { fatalError(\"Failed\") }", "metadata": {"language": "Swift", "function_name": "fibonacci", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-035", "query_text": "Write a Kotlin function named `sumList` that calculates the sum of integers in a list. Language: Kotlin. Function name: sumList", "reference_answer": "fun sumList(nums: List<Int>): Int {\n    return nums.sum()\n}", "assertions": "if (sumList(listOf(1, 2, 3, 4, 5)) != 15) throw Exception(\"Failed\")\nif (sumList(listOf()) != 0) throw Exception(\"Failed\")\nif (sumList(listOf(-1, -2, -3)) != -6) throw Exception(\"Failed\")\nif (sumList(listOf(100)) != 100) throw Exception(\"Failed\")", "metadata": {"language": "Kotlin", "function_name": "sumList", "difficulty": "medium", "category": "algorithms", "complexity": 0.2}}
{"query_id": "synthetic-036", "query_text": "Write a C# function named `IsPalindrome` that checks if a string is a palindrome. Language: C#. Function name: IsPalindrome", "reference_answer": "using System;\nusing System.Linq;\n\npublic class Solution {\n    public static bool IsPalindrome(string s) {\n        string cleaned = new string(s.ToLower().Where(c => char.IsLetterOrDigit(c)).ToArray());\n        return cleaned == new string(cleaned.Reverse().ToArray());\n    }\n}", "assertions": "if (Solution.IsPalindrome(\"racecar\") != true) throw new Exception(\"Failed\");\nif (Solution.IsPalindrome(\"hello\") != false) throw new Exception(\"Failed\");\nif (Solution.IsPalindrome(\"A man a plan a canal Panama\") != true) throw new Exception(\"Failed\");\nif (Solution.IsPalindrome(\"\") != true) throw new Exception(\"Failed\");", "metadata": {"language": "C#", "function_name": "IsPalindrome", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.4}}
{"query_id": "synthetic-037", "query_text": "Write a Python function named `dijkstra` that implements Dijkstra's algorithm to find shortest paths in a weighted graph. Language: Python. Function name: dijkstra", "reference_answer": "import heapq\n\ndef dijkstra(graph: dict, start: str) -> dict:\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    visited = set()\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current in visited:\n            continue\n        visited.add(current)\n        \n        for neighbor, weight in graph.get(current, {}).items():\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances", "assertions": "graph = {'A': {'B': 1, 'C': 4}, 'B': {'C': 2, 'D': 5}, 'C': {'D': 1}, 'D': {}}\nresult = dijkstra(graph, 'A')\nassert result['A'] == 0\nassert result['B'] == 1\nassert result['C'] == 3\nassert result['D'] == 4", "metadata": {"language": "Python", "function_name": "dijkstra", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.85}}
{"query_id": "synthetic-038", "query_text": "Write a TypeScript function named `asyncMap` that applies an async function to each element of an array concurrently with a concurrency limit. Language: TypeScript. Function name: asyncMap", "reference_answer": "async function asyncMap<T, R>(\n    arr: T[],\n    fn: (item: T) => Promise<R>,\n    concurrency: number\n): Promise<R[]> {\n    const results: R[] = [];\n    const executing: Promise<void>[] = [];\n    \n    for (const item of arr) {\n        const promise = fn(item).then(result => {\n            results.push(result);\n            executing.splice(executing.indexOf(promise), 1);\n        });\n        executing.push(promise);\n        \n        if (executing.length >= concurrency) {\n            await Promise.race(executing);\n        }\n    }\n    \n    await Promise.all(executing);\n    return results;\n}", "assertions": "const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\nconst double = async (n: number) => { await delay(10); return n * 2; };\nasync function test() {\n    const result = await asyncMap([1, 2, 3, 4, 5], double, 2);\n    if (JSON.stringify(result) !== JSON.stringify([1, 2, 3, 4, 5].map(n => n * 2))) throw new Error('Failed');\n}\ntest();", "metadata": {"language": "TypeScript", "function_name": "asyncMap", "difficulty": "very_advanced", "category": "async", "complexity": 0.9}}
{"query_id": "synthetic-039", "query_text": "Write a Python function named `thread_safe_counter` that implements a thread-safe counter using locks. Language: Python. Function name: thread_safe_counter", "reference_answer": "from threading import Lock\n\nclass ThreadSafeCounter:\n    def __init__(self, initial_value: int = 0):\n        self._value = initial_value\n        self._lock = Lock()\n    \n    def increment(self) -> int:\n        with self._lock:\n            self._value += 1\n            return self._value\n    \n    def decrement(self) -> int:\n        with self._lock:\n            self._value -= 1\n            return self._value\n    \n    def get_value(self) -> int:\n        with self._lock:\n            return self._value", "assertions": "from threading import Thread\ncounter = ThreadSafeCounter()\nthreads = [Thread(target=counter.increment) for _ in range(10)]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\nassert counter.get_value() == 10", "metadata": {"language": "Python", "function_name": "thread_safe_counter", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.8}}
{"query_id": "synthetic-040", "query_text": "Write a TypeScript function named `LRUCache` that implements a Least Recently Used cache with O(1) operations. Language: TypeScript. Function name: LRUCache", "reference_answer": "class LRUCache {\n    private capacity: number;\n    private cache: Map<number, number>;\n    \n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.cache = new Map();\n    }\n    \n    get(key: number): number {\n        if (!this.cache.has(key)) return -1;\n        const value = this.cache.get(key)!;\n        this.cache.delete(key);\n        this.cache.set(key, value);\n        return value;\n    }\n    \n    put(key: number, value: number): void {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        } else if (this.cache.size >= this.capacity) {\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        this.cache.set(key, value);\n    }\n}", "assertions": "const cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\nif (cache.get(1) !== 1) throw new Error('Failed');\ncache.put(3, 3);\nif (cache.get(2) !== -1) throw new Error('Failed');\nif (cache.get(3) !== 3) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "LRUCache", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.85}}
{"query_id": "synthetic-041", "query_text": "Write a Python function named `knapsack` that solves the 0/1 knapsack problem using dynamic programming. Language: Python. Function name: knapsack", "reference_answer": "def knapsack(weights: list[int], values: list[int], capacity: int) -> int:\n    n = len(weights)\n    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]", "assertions": "assert knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9\nassert knapsack([10, 20, 30], [60, 100, 120], 50) == 220\nassert knapsack([], [], 10) == 0\nassert knapsack([1], [10], 0) == 0", "metadata": {"language": "Python", "function_name": "knapsack", "difficulty": "very_advanced", "category": "dynamic_programming", "complexity": 0.9}}
{"query_id": "synthetic-042", "query_text": "Write a TypeScript function named `topologicalSort` that performs topological sorting on a directed acyclic graph. Language: TypeScript. Function name: topologicalSort", "reference_answer": "function topologicalSort(graph: Map<number, number[]>): number[] {\n    const inDegree = new Map<number, number>();\n    const queue: number[] = [];\n    const result: number[] = [];\n    \n    for (const [node, neighbors] of graph) {\n        inDegree.set(node, inDegree.get(node) || 0);\n        for (const neighbor of neighbors) {\n            inDegree.set(neighbor, (inDegree.get(neighbor) || 0) + 1);\n        }\n    }\n    \n    for (const [node, degree] of inDegree) {\n        if (degree === 0) queue.push(node);\n    }\n    \n    while (queue.length > 0) {\n        const node = queue.shift()!;\n        result.push(node);\n        for (const neighbor of graph.get(node) || []) {\n            const newDegree = (inDegree.get(neighbor) || 0) - 1;\n            inDegree.set(neighbor, newDegree);\n            if (newDegree === 0) queue.push(neighbor);\n        }\n    }\n    \n    return result;\n}", "assertions": "const graph = new Map([[0, [1, 2]], [1, [3]], [2, [3]], [3, []]]);\nconst result = topologicalSort(graph);\nif (result.length !== 4) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "topologicalSort", "difficulty": "very_advanced", "category": "graph_algorithms", "complexity": 0.9}}
{"query_id": "synthetic-043", "query_text": "Write a Python function named `merge_sort` that implements merge sort algorithm. Language: Python. Function name: merge_sort", "reference_answer": "def merge_sort(arr: list[int]) -> list[int]:\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(left: list[int], right: list[int]) -> list[int]:\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result", "assertions": "assert merge_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\nassert merge_sort([]) == []\nassert merge_sort([1]) == [1]\nassert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]", "metadata": {"language": "Python", "function_name": "merge_sort", "difficulty": "advanced", "category": "sorting", "complexity": 0.7}}
{"query_id": "synthetic-044", "query_text": "Write a TypeScript function named `binaryTreeInorder` that performs inorder traversal of a binary tree. Assume a TreeNode class with val, left, and right properties. Language: TypeScript. Function name: binaryTreeInorder", "reference_answer": "class TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val: number) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nfunction binaryTreeInorder(root: TreeNode | null): number[] {\n    const result: number[] = [];\n    function traverse(node: TreeNode | null) {\n        if (!node) return;\n        traverse(node.left);\n        result.push(node.val);\n        traverse(node.right);\n    }\n    traverse(root);\n    return result;\n}", "assertions": "const root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\nconst result = binaryTreeInorder(root);\nif (JSON.stringify(result) !== JSON.stringify([4, 2, 5, 1, 3])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "binaryTreeInorder", "difficulty": "advanced", "category": "data_structures", "complexity": 0.65}}
{"query_id": "synthetic-045", "query_text": "Write a Python function named `heap_sort` that implements heap sort algorithm. Language: Python. Function name: heap_sort", "reference_answer": "import heapq\n\ndef heap_sort(arr: list[int]) -> list[int]:\n    heapq.heapify(arr)\n    return [heapq.heappop(arr) for _ in range(len(arr))]", "assertions": "assert heap_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10]\nassert heap_sort([]) == []\nassert heap_sort([1]) == [1]\nassert heap_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]", "metadata": {"language": "Python", "function_name": "heap_sort", "difficulty": "advanced", "category": "sorting", "complexity": 0.75}}
{"query_id": "synthetic-046", "query_text": "Write a TypeScript function named `permutations` that generates all permutations of an array. Language: TypeScript. Function name: permutations", "reference_answer": "function permutations<T>(arr: T[]): T[][] {\n    if (arr.length <= 1) return [arr];\n    const result: T[][] = [];\n    for (let i = 0; i < arr.length; i++) {\n        const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];\n        for (const perm of permutations(rest)) {\n            result.push([arr[i], ...perm]);\n        }\n    }\n    return result;\n}", "assertions": "const result = permutations([1, 2, 3]);\nif (result.length !== 6) throw new Error('Failed');\nif (JSON.stringify(permutations([])) !== JSON.stringify([[]])) throw new Error('Failed');\nif (JSON.stringify(permutations([1])) !== JSON.stringify([[1]])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "permutations", "difficulty": "advanced", "category": "algorithms", "complexity": 0.8}}
{"query_id": "synthetic-047", "query_text": "Write a Python function named `validate_email` that validates an email address using regex. Language: Python. Function name: validate_email", "reference_answer": "import re\n\ndef validate_email(email: str) -> bool:\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))", "assertions": "assert validate_email('test@example.com') == True\nassert validate_email('user.name@domain.co.uk') == True\nassert validate_email('invalid.email') == False\nassert validate_email('@example.com') == False\nassert validate_email('test@') == False", "metadata": {"language": "Python", "function_name": "validate_email", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.4}}
{"query_id": "synthetic-048", "query_text": "Write a TypeScript function named `capitalizeWords` that capitalizes the first letter of each word in a string. Language: TypeScript. Function name: capitalizeWords", "reference_answer": "function capitalizeWords(str: string): string {\n    return str.split(' ').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()\n    ).join(' ');\n}", "assertions": "if (capitalizeWords('hello world') !== 'Hello World') throw new Error('Failed');\nif (capitalizeWords('HELLO WORLD') !== 'Hello World') throw new Error('Failed');\nif (capitalizeWords('') !== '') throw new Error('Failed');\nif (capitalizeWords('a') !== 'A') throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "capitalizeWords", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.35}}
{"query_id": "synthetic-049", "query_text": "Write a Python function named `count_words` that counts the frequency of each word in a string. Language: Python. Function name: count_words", "reference_answer": "def count_words(text: str) -> dict[str, int]:\n    words = text.lower().split()\n    word_count = {}\n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n    return word_count", "assertions": "result = count_words('hello world hello')\nassert result['hello'] == 2\nassert result['world'] == 1\nassert count_words('') == {}\nassert count_words('a a a') == {'a': 3}", "metadata": {"language": "Python", "function_name": "count_words", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.3}}
{"query_id": "synthetic-050", "query_text": "Write a TypeScript function named `shuffle` that randomly shuffles an array using Fisher-Yates algorithm. Language: TypeScript. Function name: shuffle", "reference_answer": "function shuffle<T>(arr: T[]): T[] {\n    const result = [...arr];\n    for (let i = result.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [result[i], result[j]] = [result[j], result[i]];\n    }\n    return result;\n}", "assertions": "const original = [1, 2, 3, 4, 5];\nconst shuffled = shuffle(original);\nif (shuffled.length !== original.length) throw new Error('Failed');\nif (JSON.stringify(shuffled.sort()) !== JSON.stringify(original.sort())) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "shuffle", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-051", "query_text": "Write a Go function named `BubbleSort` that implements bubble sort algorithm. Language: Go. Function name: BubbleSort", "reference_answer": "package main\n\nfunc BubbleSort(nums []int) []int {\n\tresult := make([]int, len(nums))\n\tcopy(result, nums)\n\tfor i := 0; i < len(result); i++ {\n\t\tfor j := 0; j < len(result)-1-i; j++ {\n\t\t\tif result[j] > result[j+1] {\n\t\t\t\tresult[j], result[j+1] = result[j+1], result[j]\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}", "assertions": "result := BubbleSort([]int{3, 6, 8, 10, 1, 2, 1})\nif len(result) != 7 || result[0] != 1 || result[6] != 10 { panic(\"Failed\") }\nresult2 := BubbleSort([]int{})\nif len(result2) != 0 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "BubbleSort", "difficulty": "medium", "category": "sorting", "complexity": 0.5}}
{"query_id": "synthetic-052", "query_text": "Write a Go function named `BinarySearch` that performs binary search on a sorted slice. Language: Go. Function name: BinarySearch", "reference_answer": "package main\n\nfunc BinarySearch(nums []int, target int) int {\n\tleft, right := 0, len(nums)-1\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t} else if nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn -1\n}", "assertions": "if BinarySearch([]int{1, 2, 3, 4, 5}, 3) != 2 { panic(\"Failed\") }\nif BinarySearch([]int{1, 2, 3, 4, 5}, 6) != -1 { panic(\"Failed\") }\nif BinarySearch([]int{}, 1) != -1 { panic(\"Failed\") }\nif BinarySearch([]int{10}, 10) != 0 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "BinarySearch", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-053", "query_text": "Write a Go function named `IsPrime` that checks if a number is prime. Language: Go. Function name: IsPrime", "reference_answer": "package main\n\nfunc IsPrime(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}", "assertions": "if IsPrime(2) != true { panic(\"Failed\") }\nif IsPrime(4) != false { panic(\"Failed\") }\nif IsPrime(17) != true { panic(\"Failed\") }\nif IsPrime(1) != false { panic(\"Failed\") }\nif IsPrime(0) != false { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "IsPrime", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-054", "query_text": "Write a Java function named `reverseString` that reverses a string. Language: Java. Function name: reverseString", "reference_answer": "public class Solution {\n    public static String reverseString(String s) {\n        return new StringBuilder(s).reverse().toString();\n    }\n}", "assertions": "if (!Solution.reverseString(\"hello\").equals(\"olleh\")) throw new RuntimeException(\"Failed\");\nif (!Solution.reverseString(\"world\").equals(\"dlrow\")) throw new RuntimeException(\"Failed\");\nif (!Solution.reverseString(\"\").equals(\"\")) throw new RuntimeException(\"Failed\");\nif (!Solution.reverseString(\"a\").equals(\"a\")) throw new RuntimeException(\"Failed\");", "metadata": {"language": "Java", "function_name": "reverseString", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.25}}
{"query_id": "synthetic-055", "query_text": "Write a Java function named `isAnagram` that checks if two strings are anagrams. Language: Java. Function name: isAnagram", "reference_answer": "import java.util.Arrays;\n\npublic class Solution {\n    public static boolean isAnagram(String s1, String s2) {\n        if (s1.length() != s2.length()) return false;\n        char[] arr1 = s1.toCharArray();\n        char[] arr2 = s2.toCharArray();\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n        return Arrays.equals(arr1, arr2);\n    }\n}", "assertions": "if (Solution.isAnagram(\"listen\", \"silent\") != true) throw new RuntimeException(\"Failed\");\nif (Solution.isAnagram(\"hello\", \"world\") != false) throw new RuntimeException(\"Failed\");\nif (Solution.isAnagram(\"\", \"\") != true) throw new RuntimeException(\"Failed\");\nif (Solution.isAnagram(\"a\", \"a\") != true) throw new RuntimeException(\"Failed\");", "metadata": {"language": "Java", "function_name": "isAnagram", "difficulty": "medium", "category": "string_manipulation", "complexity": 0.4}}
{"query_id": "synthetic-056", "query_text": "Write a JavaScript function named `debounce` that creates a debounced version of a function. Language: JavaScript. Function name: debounce", "reference_answer": "function debounce(func, wait) {\n    let timeout;\n    return function(...args) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst debouncedIncrement = debounce(increment, 100);\ndebouncedIncrement();\ndebouncedIncrement();\ndebouncedIncrement();\nsetTimeout(() => {\n    if (counter !== 1) throw new Error('Failed');\n}, 150);", "metadata": {"language": "JavaScript", "function_name": "debounce", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-057", "query_text": "Write a C++ function named `reverseArray` that reverses an array in place. Language: C++. Function name: reverseArray", "reference_answer": "#include <algorithm>\nusing namespace std;\n\nvoid reverseArray(int arr[], int size) {\n    for (int i = 0; i < size / 2; i++) {\n        swap(arr[i], arr[size - 1 - i]);\n    }\n}", "assertions": "int arr1[] = {1, 2, 3, 4, 5};\nreverseArray(arr1, 5);\nif (arr1[0] != 5 || arr1[4] != 1) throw runtime_error(\"Failed\");\nint arr2[] = {10};\nreverseArray(arr2, 1);\nif (arr2[0] != 10) throw runtime_error(\"Failed\");", "metadata": {"language": "C++", "function_name": "reverseArray", "difficulty": "medium", "category": "algorithms", "complexity": 0.35}}
{"query_id": "synthetic-058", "query_text": "Write a Python function named `edit_distance` that calculates the Levenshtein distance between two strings. Language: Python. Function name: edit_distance", "reference_answer": "def edit_distance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]", "assertions": "assert edit_distance('kitten', 'sitting') == 3\nassert edit_distance('', 'abc') == 3\nassert edit_distance('abc', '') == 3\nassert edit_distance('abc', 'abc') == 0\nassert edit_distance('abc', 'def') == 3", "metadata": {"language": "Python", "function_name": "edit_distance", "difficulty": "advanced", "category": "dynamic_programming", "complexity": 0.8}}
{"query_id": "synthetic-059", "query_text": "Write a TypeScript function named `quickSelect` that finds the kth smallest element in an array using quickselect algorithm. Language: TypeScript. Function name: quickSelect", "reference_answer": "function quickSelect(arr: number[], k: number): number {\n    const pivot = arr[Math.floor(Math.random() * arr.length)];\n    const left = arr.filter(x => x < pivot);\n    const middle = arr.filter(x => x === pivot);\n    const right = arr.filter(x => x > pivot);\n    \n    if (k <= left.length) {\n        return quickSelect(left, k);\n    } else if (k <= left.length + middle.length) {\n        return pivot;\n    } else {\n        return quickSelect(right, k - left.length - middle.length);\n    }\n}", "assertions": "const arr = [3, 2, 1, 5, 6, 4];\nif (quickSelect([...arr], 2) !== 2) throw new Error('Failed');\nif (quickSelect([...arr], 4) !== 4) throw new Error('Failed');\nif (quickSelect([1], 1) !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "quickSelect", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-060", "query_text": "Write a Python function named `regex_matcher` that implements a simple regex matcher supporting '.' and '*' patterns. Language: Python. Function name: regex_matcher", "reference_answer": "def regex_matcher(s: str, p: str) -> bool:\n    if not p:\n        return not s\n    \n    first_match = bool(s) and (p[0] == s[0] or p[0] == '.')\n    \n    if len(p) >= 2 and p[1] == '*':\n        return regex_matcher(s, p[2:]) or (first_match and regex_matcher(s[1:], p))\n    else:\n        return first_match and regex_matcher(s[1:], p[1:])", "assertions": "assert regex_matcher('aa', 'a') == False\nassert regex_matcher('aa', 'a*') == True\nassert regex_matcher('ab', '.*') == True\nassert regex_matcher('aab', 'c*a*b') == True\nassert regex_matcher('mississippi', 'mis*is*p*.') == False", "metadata": {"language": "Python", "function_name": "regex_matcher", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-061", "query_text": "Write a TypeScript function named `Observer` that implements the Observer design pattern. Language: TypeScript. Function name: Observer", "reference_answer": "class Subject {\n    private observers: Array<() => void> = [];\n    \n    subscribe(observer: () => void): () => void {\n        this.observers.push(observer);\n        return () => {\n            this.observers = this.observers.filter(o => o !== observer);\n        };\n    }\n    \n    notify(): void {\n        this.observers.forEach(observer => observer());\n    }\n}", "assertions": "const subject = new Subject();\nlet count = 0;\nconst unsubscribe = subject.subscribe(() => count++);\nsubject.notify();\nif (count !== 1) throw new Error('Failed');\nsubject.notify();\nif (count !== 2) throw new Error('Failed');\nunsubscribe();\nsubject.notify();\nif (count !== 2) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "Observer", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.75}}
{"query_id": "synthetic-062", "query_text": "Write a Python function named `async_fetch_all` that fetches multiple URLs concurrently using asyncio. Language: Python. Function name: async_fetch_all", "reference_answer": "import asyncio\nimport aiohttp\n\nasync def async_fetch_all(urls: list[str]) -> list[str]:\n    async with aiohttp.ClientSession() as session:\n        async def fetch(url: str) -> str:\n            async with session.get(url) as response:\n                return await response.text()\n        return await asyncio.gather(*[fetch(url) for url in urls])", "assertions": "import asyncio\nasync def test():\n    results = await async_fetch_all(['https://httpbin.org/get'])\n    assert len(results) == 1\n    assert 'url' in results[0]\nasyncio.run(test())", "metadata": {"language": "Python", "function_name": "async_fetch_all", "difficulty": "very_advanced", "category": "async", "complexity": 0.85}}
{"query_id": "synthetic-063", "query_text": "Write a TypeScript function named `PromiseAll` that implements Promise.all functionality. Language: TypeScript. Function name: PromiseAll", "reference_answer": "function PromiseAll<T>(promises: Promise<T>[]): Promise<T[]> {\n    return new Promise((resolve, reject) => {\n        const results: T[] = [];\n        let completed = 0;\n        \n        if (promises.length === 0) {\n            resolve(results);\n            return;\n        }\n        \n        promises.forEach((promise, index) => {\n            promise.then(value => {\n                results[index] = value;\n                completed++;\n                if (completed === promises.length) {\n                    resolve(results);\n                }\n            }).catch(reject);\n        });\n    });\n}", "assertions": "const p1 = Promise.resolve(1);\nconst p2 = Promise.resolve(2);\nconst p3 = Promise.resolve(3);\nPromiseAll([p1, p2, p3]).then(results => {\n    if (JSON.stringify(results) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "PromiseAll", "difficulty": "very_advanced", "category": "async", "complexity": 0.85}}
{"query_id": "synthetic-064", "query_text": "Write a Python function named `circular_buffer` that implements a circular buffer data structure. Language: Python. Function name: circular_buffer", "reference_answer": "from collections import deque\n\nclass CircularBuffer:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.buffer = deque(maxlen=capacity)\n    \n    def append(self, item):\n        self.buffer.append(item)\n    \n    def get(self, index: int):\n        return self.buffer[index] if 0 <= index < len(self.buffer) else None\n    \n    def size(self) -> int:\n        return len(self.buffer)", "assertions": "cb = CircularBuffer(3)\ncb.append(1)\ncb.append(2)\ncb.append(3)\nassert cb.size() == 3\ncb.append(4)\nassert cb.size() == 3\nassert cb.get(0) == 2", "metadata": {"language": "Python", "function_name": "circular_buffer", "difficulty": "advanced", "category": "data_structures", "complexity": 0.7}}
{"query_id": "synthetic-065", "query_text": "Write a TypeScript function named `EventEmitter` that implements an event emitter pattern. Language: TypeScript. Function name: EventEmitter", "reference_answer": "class EventEmitter {\n    private events: Map<string, Array<(...args: any[]) => void>> = new Map();\n    \n    on(event: string, listener: (...args: any[]) => void): void {\n        if (!this.events.has(event)) {\n            this.events.set(event, []);\n        }\n        this.events.get(event)!.push(listener);\n    }\n    \n    emit(event: string, ...args: any[]): void {\n        const listeners = this.events.get(event);\n        if (listeners) {\n            listeners.forEach(listener => listener(...args));\n        }\n    }\n    \n    off(event: string, listener: (...args: any[]) => void): void {\n        const listeners = this.events.get(event);\n        if (listeners) {\n            const index = listeners.indexOf(listener);\n            if (index > -1) listeners.splice(index, 1);\n        }\n    }\n}", "assertions": "const emitter = new EventEmitter();\nlet count = 0;\nconst listener = () => count++;\nemitter.on('test', listener);\nemitter.emit('test');\nif (count !== 1) throw new Error('Failed');\nemitter.off('test', listener);\nemitter.emit('test');\nif (count !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "EventEmitter", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.8}}
{"query_id": "synthetic-066", "query_text": "Write a Python function named `validate_credit_card` that validates a credit card number using Luhn algorithm. Language: Python. Function name: validate_credit_card", "reference_answer": "def validate_credit_card(card_number: str) -> bool:\n    card_number = card_number.replace(' ', '').replace('-', '')\n    if not card_number.isdigit():\n        return False\n    \n    digits = [int(d) for d in card_number]\n    for i in range(len(digits) - 2, -1, -2):\n        digits[i] *= 2\n        if digits[i] > 9:\n            digits[i] -= 9\n    \n    return sum(digits) % 10 == 0", "assertions": "assert validate_credit_card('4532015112830366') == True\nassert validate_credit_card('4532-0151-1283-0366') == True\nassert validate_credit_card('1234567890123456') == False\nassert validate_credit_card('') == False", "metadata": {"language": "Python", "function_name": "validate_credit_card", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-067", "query_text": "Write a TypeScript function named `flattenDeep` that deeply flattens a nested array. Language: TypeScript. Function name: flattenDeep", "reference_answer": "function flattenDeep<T>(arr: any[]): T[] {\n    const result: T[] = [];\n    for (const item of arr) {\n        if (Array.isArray(item)) {\n            result.push(...flattenDeep<T>(item));\n        } else {\n            result.push(item as T);\n        }\n    }\n    return result;\n}", "assertions": "if (JSON.stringify(flattenDeep([1, [2, [3, 4], 5], 6])) !== JSON.stringify([1, 2, 3, 4, 5, 6])) throw new Error('Failed');\nif (JSON.stringify(flattenDeep([1, 2, 3])) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nif (JSON.stringify(flattenDeep([])) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "flattenDeep", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-068", "query_text": "Write a Python function named `roman_to_int` that converts a Roman numeral to an integer. Language: Python. Function name: roman_to_int", "reference_answer": "def roman_to_int(s: str) -> int:\n    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    \n    return total", "assertions": "assert roman_to_int('III') == 3\nassert roman_to_int('IV') == 4\nassert roman_to_int('IX') == 9\nassert roman_to_int('LVIII') == 58\nassert roman_to_int('MCMXCIV') == 1994", "metadata": {"language": "Python", "function_name": "roman_to_int", "difficulty": "medium", "category": "algorithms", "complexity": 0.55}}
{"query_id": "synthetic-069", "query_text": "Write a TypeScript function named `intersection` that finds the intersection of two arrays. Language: TypeScript. Function name: intersection", "reference_answer": "function intersection<T>(arr1: T[], arr2: T[]): T[] {\n    const set2 = new Set(arr2);\n    return arr1.filter(item => set2.has(item));\n}", "assertions": "if (JSON.stringify(intersection([1, 2, 3], [2, 3, 4])) !== JSON.stringify([2, 3])) throw new Error('Failed');\nif (JSON.stringify(intersection([1, 2, 3], [4, 5, 6])) !== JSON.stringify([])) throw new Error('Failed');\nif (JSON.stringify(intersection([], [])) !== JSON.stringify([])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "intersection", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-070", "query_text": "Write a Python function named `int_to_roman` that converts an integer to a Roman numeral. Language: Python. Function name: int_to_roman", "reference_answer": "def int_to_roman(num: int) -> str:\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    result = ''\n    \n    for i, value in enumerate(values):\n        count = num // value\n        result += symbols[i] * count\n        num %= value\n    \n    return result", "assertions": "assert int_to_roman(3) == 'III'\nassert int_to_roman(4) == 'IV'\nassert int_to_roman(9) == 'IX'\nassert int_to_roman(58) == 'LVIII'\nassert int_to_roman(1994) == 'MCMXCIV'", "metadata": {"language": "Python", "function_name": "int_to_roman", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id":"synthetic-071","query_text":"Write a Python function named `word_break` that determines if a string can be segmented into space-separated words from a dictionary. Language: Python. Function name: word_break","reference_answer":"def word_break(s: str, word_dict: list[str]) -> bool:\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    \n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[len(s)]","assertions":"assert word_break('leetcode', ['leet', 'code']) == True\nassert word_break('applepenapple', ['apple', 'pen']) == True\nassert word_break('catsandog', ['cats', 'dog', 'sand', 'and', 'cat']) == False\nassert word_break('', ['a', 'b']) == True","metadata":{"language":"Python","function_name":"word_break","difficulty":"advanced","category":"dynamic_programming","complexity":0.75}}
{"query_id":"synthetic-072","query_text":"Write a TypeScript function named `binarySearchTree` that implements a binary search tree with insert and search operations. Language: TypeScript. Function name: binarySearchTree","reference_answer":"class TreeNode {\n    val: number;\n    left: TreeNode | null;\n    right: TreeNode | null;\n    constructor(val: number) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BinarySearchTree {\n    root: TreeNode | null = null;\n    \n    insert(val: number): void {\n        this.root = this._insert(this.root, val);\n    }\n    \n    private _insert(node: TreeNode | null, val: number): TreeNode {\n        if (!node) return new TreeNode(val);\n        if (val < node.val) node.left = this._insert(node.left, val);\n        else if (val > node.val) node.right = this._insert(node.right, val);\n        return node;\n    }\n    \n    search(val: number): boolean {\n        return this._search(this.root, val);\n    }\n    \n    private _search(node: TreeNode | null, val: number): boolean {\n        if (!node) return false;\n        if (val === node.val) return true;\n        return val < node.val ? this._search(node.left, val) : this._search(node.right, val);\n    }\n}","assertions":"const bst = new BinarySearchTree();\nbst.insert(5);\nbst.insert(3);\nbst.insert(7);\nif (bst.search(5) !== true) throw new Error('Failed');\nif (bst.search(3) !== true) throw new Error('Failed');\nif (bst.search(10) !== false) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"binarySearchTree","difficulty":"advanced","category":"data_structures","complexity":0.7}}
{"query_id":"synthetic-073","query_text":"Write a Python function named `coin_change` that finds the minimum number of coins needed to make a target amount. Language: Python. Function name: coin_change","reference_answer":"def coin_change(coins: list[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1","assertions":"assert coin_change([1, 2, 5], 11) == 3\nassert coin_change([2], 3) == -1\nassert coin_change([1], 0) == 0\nassert coin_change([1], 1) == 1","metadata":{"language":"Python","function_name":"coin_change","difficulty":"advanced","category":"dynamic_programming","complexity":0.8}}
{"query_id":"synthetic-074","query_text":"Write a TypeScript function named `union` that finds the union of two arrays. Language: TypeScript. Function name: union","reference_answer":"function union<T>(arr1: T[], arr2: T[]): T[] {\n    return Array.from(new Set([...arr1, ...arr2]));\n}","assertions":"if (JSON.stringify(union([1, 2, 3], [2, 3, 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(union([], [1, 2])) !== JSON.stringify([1, 2])) throw new Error('Failed');\nif (JSON.stringify(union([1, 2], [])) !== JSON.stringify([1, 2])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"union","difficulty":"medium","category":"data_structures","complexity":0.3}}
{"query_id":"synthetic-075","query_text":"Write a Python function named `longest_palindrome` that finds the longest palindromic substring in a string. Language: Python. Function name: longest_palindrome","reference_answer":"def longest_palindrome(s: str) -> str:\n    if not s:\n        return ''\n    \n    start = 0\n    max_len = 1\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        length = max(len1, len2)\n        \n        if length > max_len:\n            max_len = length\n            start = i - (length - 1) // 2\n    \n    return s[start:start + max_len]","assertions":"assert longest_palindrome('babad') == 'bab' or longest_palindrome('babad') == 'aba'\nassert longest_palindrome('cbbd') == 'bb'\nassert longest_palindrome('a') == 'a'\nassert longest_palindrome('') == ''","metadata":{"language":"Python","function_name":"longest_palindrome","difficulty":"advanced","category":"algorithms","complexity":0.75}}
{"query_id":"synthetic-076","query_text":"Write a TypeScript function named `difference` that finds the difference between two arrays (elements in first but not in second). Language: TypeScript. Function name: difference","reference_answer":"function difference<T>(arr1: T[], arr2: T[]): T[] {\n    const set2 = new Set(arr2);\n    return arr1.filter(item => !set2.has(item));\n}","assertions":"if (JSON.stringify(difference([1, 2, 3], [2, 3, 4])) !== JSON.stringify([1])) throw new Error('Failed');\nif (JSON.stringify(difference([1, 2, 3], [4, 5, 6])) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nif (JSON.stringify(difference([], [1, 2])) !== JSON.stringify([])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"difference","difficulty":"medium","category":"data_structures","complexity":0.35}}
{"query_id":"synthetic-077","query_text":"Write a Python function named `num_islands` that counts the number of islands in a 2D grid (1s are land, 0s are water). Language: Python. Function name: num_islands","reference_answer":"def num_islands(grid: list[list[str]]) -> int:\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(r: int, c: int):\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':\n            return\n        grid[r][c] = '0'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                dfs(r, c)\n    \n    return count","assertions":"grid1 = [['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']]\nassert num_islands(grid1) == 1\ngrid2 = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]\nassert num_islands(grid2) == 3","metadata":{"language":"Python","function_name":"num_islands","difficulty":"very_advanced","category":"graph_algorithms","complexity":0.85}}
{"query_id":"synthetic-078","query_text":"Write a TypeScript function named `zip` that combines two arrays into an array of pairs. Language: TypeScript. Function name: zip","reference_answer":"function zip<T, U>(arr1: T[], arr2: U[]): [T, U][] {\n    const result: [T, U][] = [];\n    const minLen = Math.min(arr1.length, arr2.length);\n    for (let i = 0; i < minLen; i++) {\n        result.push([arr1[i], arr2[i]]);\n    }\n    return result;\n}","assertions":"if (JSON.stringify(zip([1, 2, 3], ['a', 'b', 'c'])) !== JSON.stringify([[1, 'a'], [2, 'b'], [3, 'c']])) throw new Error('Failed');\nif (JSON.stringify(zip([1, 2], ['a', 'b', 'c'])) !== JSON.stringify([[1, 'a'], [2, 'b']])) throw new Error('Failed');\nif (JSON.stringify(zip([], [])) !== JSON.stringify([])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"zip","difficulty":"medium","category":"data_structures","complexity":0.4}}
{"query_id":"synthetic-079","query_text":"Write a Python function named `course_schedule` that determines if all courses can be finished given prerequisites (detect cycles). Language: Python. Function name: course_schedule","reference_answer":"def course_schedule(num_courses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(num_courses)]\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n    \n    visited = [0] * num_courses\n    \n    def has_cycle(node: int) -> bool:\n        if visited[node] == 1:\n            return True\n        if visited[node] == 2:\n            return False\n        visited[node] = 1\n        for neighbor in graph[node]:\n            if has_cycle(neighbor):\n                return True\n        visited[node] = 2\n        return False\n    \n    for i in range(num_courses):\n        if visited[i] == 0 and has_cycle(i):\n            return False\n    return True","assertions":"assert course_schedule(2, [[1, 0]]) == True\nassert course_schedule(2, [[1, 0], [0, 1]]) == False\nassert course_schedule(3, [[1, 0], [2, 1]]) == True\nassert course_schedule(1, []) == True","metadata":{"language":"Python","function_name":"course_schedule","difficulty":"very_advanced","category":"graph_algorithms","complexity":0.9}}
{"query_id":"synthetic-080","query_text":"Write a TypeScript function named `partition` that partitions an array based on a predicate function. Language: TypeScript. Function name: partition","reference_answer":"function partition<T>(arr: T[], predicate: (item: T) => boolean): [T[], T[]] {\n    const truthy: T[] = [];\n    const falsy: T[] = [];\n    for (const item of arr) {\n        if (predicate(item)) {\n            truthy.push(item);\n        } else {\n            falsy.push(item);\n        }\n    }\n    return [truthy, falsy];\n}","assertions":"const [even, odd] = partition([1, 2, 3, 4, 5], n => n % 2 === 0);\nif (JSON.stringify(even) !== JSON.stringify([2, 4]) || JSON.stringify(odd) !== JSON.stringify([1, 3, 5])) throw new Error('Failed');\nconst [pos, neg] = partition([-1, 2, -3, 4], n => n > 0);\nif (JSON.stringify(pos) !== JSON.stringify([2, 4]) || JSON.stringify(neg) !== JSON.stringify([-1, -3])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"partition","difficulty":"medium","category":"data_structures","complexity":0.45}}
{"query_id":"synthetic-081","query_text":"Write a Python function named `trap_rainwater` that calculates how much rainwater can be trapped between bars. Language: Python. Function name: trap_rainwater","reference_answer":"def trap_rainwater(height: list[int]) -> int:\n    if not height:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max, right_max = 0, 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water","assertions":"assert trap_rainwater([0,1,0,2,1,0,1,3,2,1,2,1]) == 6\nassert trap_rainwater([4,2,0,3,2,5]) == 9\nassert trap_rainwater([]) == 0\nassert trap_rainwater([1]) == 0","metadata":{"language":"Python","function_name":"trap_rainwater","difficulty":"very_advanced","category":"algorithms","complexity":0.9}}
{"query_id":"synthetic-082","query_text":"Write a TypeScript function named `unique` that returns unique elements from an array while preserving order. Language: TypeScript. Function name: unique","reference_answer":"function unique<T>(arr: T[]): T[] {\n    const seen = new Set<T>();\n    const result: T[] = [];\n    for (const item of arr) {\n        if (!seen.has(item)) {\n            seen.add(item);\n            result.push(item);\n        }\n    }\n    return result;\n}","assertions":"if (JSON.stringify(unique([1, 2, 2, 3, 3, 4])) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(unique(['a', 'b', 'a', 'c'])) !== JSON.stringify(['a', 'b', 'c'])) throw new Error('Failed');\nif (JSON.stringify(unique([])) !== JSON.stringify([])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"unique","difficulty":"medium","category":"data_structures","complexity":0.3}}
{"query_id":"synthetic-083","query_text":"Write a Python function named `sliding_window_max` that finds the maximum in each sliding window of size k. Language: Python. Function name: sliding_window_max","reference_answer":"from collections import deque\n\ndef sliding_window_max(nums: list[int], k: int) -> list[int]:\n    if not nums or k == 0:\n        return []\n    \n    dq = deque()\n    result = []\n    \n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        \n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        dq.append(i)\n        \n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result","assertions":"assert sliding_window_max([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7]\nassert sliding_window_max([1], 1) == [1]\nassert sliding_window_max([1,-1], 1) == [1,-1]\nassert sliding_window_max([], 1) == []","metadata":{"language":"Python","function_name":"sliding_window_max","difficulty":"very_advanced","category":"algorithms","complexity":0.85}}
{"query_id":"synthetic-084","query_text":"Write a TypeScript function named `take` that takes the first n elements from an array. Language: TypeScript. Function name: take","reference_answer":"function take<T>(arr: T[], n: number): T[] {\n    return arr.slice(0, n);\n}","assertions":"if (JSON.stringify(take([1, 2, 3, 4, 5], 3)) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nif (JSON.stringify(take([1, 2, 3], 5)) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nif (JSON.stringify(take([], 3)) !== JSON.stringify([])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"take","difficulty":"medium","category":"data_structures","complexity":0.2}}
{"query_id":"synthetic-085","query_text":"Write a Python function named `min_path_sum` that finds the minimum path sum from top-left to bottom-right in a grid. Language: Python. Function name: min_path_sum","reference_answer":"def min_path_sum(grid: list[list[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    \n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    \n    for j in range(1, n):\n        grid[0][j] += grid[0][j-1]\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    \n    return grid[m-1][n-1]","assertions":"assert min_path_sum([[1,3,1],[1,5,1],[4,2,1]]) == 7\nassert min_path_sum([[1,2,3],[4,5,6]]) == 12\nassert min_path_sum([[1]]) == 1","metadata":{"language":"Python","function_name":"min_path_sum","difficulty":"advanced","category":"dynamic_programming","complexity":0.75}}
{"query_id":"synthetic-086","query_text":"Write a TypeScript function named `drop` that drops the first n elements from an array. Language: TypeScript. Function name: drop","reference_answer":"function drop<T>(arr: T[], n: number): T[] {\n    return arr.slice(n);\n}","assertions":"if (JSON.stringify(drop([1, 2, 3, 4, 5], 2)) !== JSON.stringify([3, 4, 5])) throw new Error('Failed');\nif (JSON.stringify(drop([1, 2, 3], 5)) !== JSON.stringify([])) throw new Error('Failed');\nif (JSON.stringify(drop([], 2)) !== JSON.stringify([])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"drop","difficulty":"medium","category":"data_structures","complexity":0.25}}
{"query_id":"synthetic-087","query_text":"Write a Python function named `longest_increasing_subsequence` that finds the length of the longest increasing subsequence. Language: Python. Function name: longest_increasing_subsequence","reference_answer":"def longest_increasing_subsequence(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    \n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)","assertions":"assert longest_increasing_subsequence([10,9,2,5,3,7,101,18]) == 4\nassert longest_increasing_subsequence([0,1,0,3,2,3]) == 4\nassert longest_increasing_subsequence([7,7,7,7,7,7,7]) == 1\nassert longest_increasing_subsequence([]) == 0","metadata":{"language":"Python","function_name":"longest_increasing_subsequence","difficulty":"very_advanced","category":"dynamic_programming","complexity":0.85}}
{"query_id":"synthetic-088","query_text":"Write a TypeScript function named `compact` that removes falsy values from an array. Language: TypeScript. Function name: compact","reference_answer":"function compact<T>(arr: (T | null | undefined | false | 0 | '' | NaN)[]): T[] {\n    return arr.filter((item): item is T => Boolean(item)) as T[];\n}","assertions":"if (JSON.stringify(compact([0, 1, false, 2, '', 3])) !== JSON.stringify([1, 2, 3])) throw new Error('Failed');\nif (JSON.stringify(compact([null, undefined, 1, 2])) !== JSON.stringify([1, 2])) throw new Error('Failed');\nif (JSON.stringify(compact([])) !== JSON.stringify([])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"compact","difficulty":"medium","category":"data_structures","complexity":0.35}}
{"query_id":"synthetic-089","query_text":"Write a Python function named `decode_ways` that counts the number of ways to decode a string of digits (A=1, B=2, ..., Z=26). Language: Python. Function name: decode_ways","reference_answer":"def decode_ways(s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    \n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n        two_digit = int(s[i-2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i-2]\n    \n    return dp[n]","assertions":"assert decode_ways('12') == 2\nassert decode_ways('226') == 3\nassert decode_ways('06') == 0\nassert decode_ways('') == 0","metadata":{"language":"Python","function_name":"decode_ways","difficulty":"very_advanced","category":"dynamic_programming","complexity":0.9}}
{"query_id":"synthetic-090","query_text":"Write a TypeScript function named `range` that generates an array of numbers from start to end (exclusive). Language: TypeScript. Function name: range","reference_answer":"function range(start: number, end: number, step: number = 1): number[] {\n    const result: number[] = [];\n    if (step > 0) {\n        for (let i = start; i < end; i += step) {\n            result.push(i);\n        }\n    } else if (step < 0) {\n        for (let i = start; i > end; i += step) {\n            result.push(i);\n        }\n    }\n    return result;\n}","assertions":"if (JSON.stringify(range(0, 5)) !== JSON.stringify([0, 1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(range(1, 10, 2)) !== JSON.stringify([1, 3, 5, 7, 9])) throw new Error('Failed');\nif (JSON.stringify(range(5, 0, -1)) !== JSON.stringify([5, 4, 3, 2, 1])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"range","difficulty":"medium","category":"algorithms","complexity":0.4}}
{"query_id":"synthetic-091","query_text":"Write a Python function named `max_product_subarray` that finds the maximum product of a contiguous subarray. Language: Python. Function name: max_product_subarray","reference_answer":"def max_product_subarray(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    \n    max_prod = min_prod = result = nums[0]\n    \n    for num in nums[1:]:\n        if num < 0:\n            max_prod, min_prod = min_prod, max_prod\n        \n        max_prod = max(num, max_prod * num)\n        min_prod = min(num, min_prod * num)\n        result = max(result, max_prod)\n    \n    return result","assertions":"assert max_product_subarray([2,3,-2,4]) == 6\nassert max_product_subarray([-2,0,-1]) == 0\nassert max_product_subarray([-2,3,-4]) == 24\nassert max_product_subarray([1]) == 1","metadata":{"language":"Python","function_name":"max_product_subarray","difficulty":"advanced","category":"algorithms","complexity":0.8}}
{"query_id":"synthetic-092","query_text":"Write a TypeScript function named `pluck` that extracts a property value from each object in an array. Language: TypeScript. Function name: pluck","reference_answer":"function pluck<T, K extends keyof T>(arr: T[], key: K): T[K][] {\n    return arr.map(item => item[key]);\n}","assertions":"const users = [{name: 'Alice', age: 30}, {name: 'Bob', age: 25}];\nif (JSON.stringify(pluck(users, 'name')) !== JSON.stringify(['Alice', 'Bob'])) throw new Error('Failed');\nif (JSON.stringify(pluck(users, 'age')) !== JSON.stringify([30, 25])) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"pluck","difficulty":"medium","category":"data_structures","complexity":0.4}}
{"query_id":"synthetic-093","query_text":"Write a Python function named `spiral_order` that returns elements of a matrix in spiral order. Language: Python. Function name: spiral_order","reference_answer":"def spiral_order(matrix: list[list[int]]) -> list[int]:\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result","assertions":"assert spiral_order([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]\nassert spiral_order([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == [1,2,3,4,8,12,11,10,9,5,6,7]\nassert spiral_order([[1]]) == [1]\nassert spiral_order([]) == []","metadata":{"language":"Python","function_name":"spiral_order","difficulty":"very_advanced","category":"algorithms","complexity":0.85}}
{"query_id":"synthetic-094","query_text":"Write a TypeScript function named `keyBy` that creates an object from an array using a key function. Language: TypeScript. Function name: keyBy","reference_answer":"function keyBy<T>(arr: T[], keyFn: (item: T) => string): Record<string, T> {\n    return arr.reduce((acc, item) => {\n        acc[keyFn(item)] = item;\n        return acc;\n    }, {} as Record<string, T>);\n}","assertions":"const users = [{id: '1', name: 'Alice'}, {id: '2', name: 'Bob'}];\nconst result = keyBy(users, u => u.id);\nif (result['1'].name !== 'Alice' || result['2'].name !== 'Bob') throw new Error('Failed');\nif (Object.keys(keyBy([], () => '')).length !== 0) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"keyBy","difficulty":"medium","category":"data_structures","complexity":0.45}}
{"query_id":"synthetic-095","query_text":"Write a Python function named `wildcard_match` that matches a string against a pattern with '?' (single char) and '*' (any sequence). Language: Python. Function name: wildcard_match","reference_answer":"def wildcard_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(1, n + 1):\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j-1] == '*':\n                dp[i][j] = dp[i][j-1] or dp[i-1][j]\n            elif p[j-1] == '?' or p[j-1] == s[i-1]:\n                dp[i][j] = dp[i-1][j-1]\n    \n    return dp[m][n]","assertions":"assert wildcard_match('aa', 'a') == False\nassert wildcard_match('aa', '*') == True\nassert wildcard_match('cb', '?a') == False\nassert wildcard_match('adceb', '*a*b') == True\nassert wildcard_match('acdcb', 'a*c?b') == False","metadata":{"language":"Python","function_name":"wildcard_match","difficulty":"very_advanced","category":"algorithms","complexity":0.9}}
{"query_id":"synthetic-096","query_text":"Write a TypeScript function named `sortBy` that sorts an array by a key function. Language: TypeScript. Function name: sortBy","reference_answer":"function sortBy<T>(arr: T[], keyFn: (item: T) => number | string): T[] {\n    return [...arr].sort((a, b) => {\n        const keyA = keyFn(a);\n        const keyB = keyFn(b);\n        return keyA < keyB ? -1 : keyA > keyB ? 1 : 0;\n    });\n}","assertions":"const users = [{name: 'Bob', age: 30}, {name: 'Alice', age: 25}];\nconst sorted = sortBy(users, u => u.age);\nif (sorted[0].name !== 'Alice' || sorted[1].name !== 'Bob') throw new Error('Failed');\nconst sortedByName = sortBy(users, u => u.name);\nif (sortedByName[0].name !== 'Alice' || sortedByName[1].name !== 'Bob') throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"sortBy","difficulty":"medium","category":"algorithms","complexity":0.5}}
{"query_id":"synthetic-097","query_text":"Write a Python function named `merge_k_sorted_lists` that merges k sorted linked lists into one sorted list. Assume a ListNode class with val and next. Language: Python. Function name: merge_k_sorted_lists","reference_answer":"class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_k_sorted_lists(lists: list[ListNode]) -> ListNode:\n    import heapq\n    \n    heap = []\n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n    \n    dummy = ListNode()\n    current = dummy\n    \n    while heap:\n        val, idx, node = heapq.heappop(heap)\n        current.next = ListNode(val)\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, idx, node.next))\n    \n    return dummy.next","assertions":"def list_to_linked_list(arr):\n    if not arr: return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    current = head\n    while current:\n        result.append(current.val)\n        current = current.next\n    return result\n\nlist1 = list_to_linked_list([1, 4, 5])\nlist2 = list_to_linked_list([1, 3, 4])\nlist3 = list_to_linked_list([2, 6])\nresult = merge_k_sorted_lists([list1, list2, list3])\nassert linked_list_to_list(result) == [1, 1, 2, 3, 4, 4, 5, 6]","metadata":{"language":"Python","function_name":"merge_k_sorted_lists","difficulty":"very_advanced","category":"algorithms","complexity":0.9}}
{"query_id":"synthetic-098","query_text":"Write a TypeScript function named `omit` that creates an object with specified keys omitted. Language: TypeScript. Function name: omit","reference_answer":"function omit<T, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n    const result = { ...obj };\n    for (const key of keys) {\n        delete result[key];\n    }\n    return result as Omit<T, K>;\n}","assertions":"const obj = {a: 1, b: 2, c: 3};\nconst result = omit(obj, ['b']);\nif ('b' in result || result.a !== 1 || result.c !== 3) throw new Error('Failed');\nconst result2 = omit(obj, ['a', 'c']);\nif ('a' in result2 || 'c' in result2 || result2.b !== 2) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"omit","difficulty":"medium","category":"data_structures","complexity":0.4}}
{"query_id":"synthetic-099","query_text":"Write a Python function named `largest_rectangle` that finds the largest rectangle area in a histogram. Language: Python. Function name: largest_rectangle","reference_answer":"def largest_rectangle(heights: list[int]) -> int:\n    stack = []\n    max_area = 0\n    \n    for i, height in enumerate(heights):\n        while stack and heights[stack[-1]] > height:\n            h = heights[stack.pop()]\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n    \n    while stack:\n        h = heights[stack.pop()]\n        w = len(heights) if not stack else len(heights) - stack[-1] - 1\n        max_area = max(max_area, h * w)\n    \n    return max_area","assertions":"assert largest_rectangle([2,1,5,6,2,3]) == 10\nassert largest_rectangle([2,4]) == 4\nassert largest_rectangle([1]) == 1\nassert largest_rectangle([]) == 0","metadata":{"language":"Python","function_name":"largest_rectangle","difficulty":"very_advanced","category":"algorithms","complexity":0.9}}
{"query_id":"synthetic-100","query_text":"Write a TypeScript function named `pick` that creates an object with only specified keys. Language: TypeScript. Function name: pick","reference_answer":"function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n    const result = {} as Pick<T, K>;\n    for (const key of keys) {\n        if (key in obj) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}","assertions":"const obj = {a: 1, b: 2, c: 3};\nconst result = pick(obj, ['a', 'c']);\nif (result.a !== 1 || result.c !== 3 || 'b' in result) throw new Error('Failed');\nconst result2 = pick(obj, ['b']);\nif (result2.b !== 2 || 'a' in result2 || 'c' in result2) throw new Error('Failed');","metadata":{"language":"TypeScript","function_name":"pick","difficulty":"medium","category":"data_structures","complexity":0.35}}
