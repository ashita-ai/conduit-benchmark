{"query_id": "synthetic-001", "query_text": "Write a Python function named `merge_intervals` that takes a list of intervals and merges all overlapping intervals. Language: Python. Function name: merge_intervals", "reference_answer": "def merge_intervals(intervals: list[list[int]]) -> list[list[int]]:\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged", "assertions": "assert merge_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\nassert merge_intervals([[1,4],[4,5]]) == [[1,5]]\nassert merge_intervals([]) == []\nassert merge_intervals([[1,4],[0,4]]) == [[0,4]]\nassert merge_intervals([[1,4],[2,3]]) == [[1,4]]", "metadata": {"language": "Python", "function_name": "merge_intervals", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-002", "query_text": "Write a Python function named `topological_sort` that performs topological sorting on a directed acyclic graph represented as an adjacency list. Language: Python. Function name: topological_sort", "reference_answer": "def topological_sort(graph: dict[int, list[int]]) -> list[int]:\n    visited = set()\n    result = []\n    \n    def dfs(node: int) -> None:\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph.get(node, []):\n            dfs(neighbor)\n        result.append(node)\n    \n    for node in graph:\n        dfs(node)\n    return result[::-1]", "assertions": "assert topological_sort({0: [1, 2], 1: [3], 2: [3], 3: []}) in [[0, 1, 2, 3], [0, 2, 1, 3]]\nassert topological_sort({0: [], 1: [], 2: []}) in [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]\nassert topological_sort({}) == []\nassert topological_sort({0: [1], 1: [2], 2: []}) == [0, 1, 2]", "metadata": {"language": "Python", "function_name": "topological_sort", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-003", "query_text": "Write a Python function named `lru_cache_impl` that implements an LRU cache with get and put operations. Language: Python. Function name: lru_cache_impl", "reference_answer": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n    \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\ndef lru_cache_impl(capacity: int) -> LRUCache:\n    return LRUCache(capacity)", "assertions": "cache = lru_cache_impl(2)\ncache.put(1, 1)\ncache.put(2, 2)\nassert cache.get(1) == 1\ncache.put(3, 3)\nassert cache.get(2) == -1\ncache.put(4, 4)\nassert cache.get(1) == -1\nassert cache.get(3) == 3\nassert cache.get(4) == 4", "metadata": {"language": "Python", "function_name": "lru_cache_impl", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.9}}
{"query_id": "synthetic-004", "query_text": "Write a Python function named `serialize_binary_tree` that serializes a binary tree to a string and deserializes it back. Language: Python. Function name: serialize_binary_tree", "reference_answer": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef serialize_binary_tree(root: TreeNode | None) -> str:\n    if not root:\n        return 'null'\n    return f'{root.val},{serialize_binary_tree(root.left)},{serialize_binary_tree(root.right)}'\n\ndef deserialize_binary_tree(data: str) -> TreeNode | None:\n    def helper(nodes):\n        val = next(nodes)\n        if val == 'null':\n            return None\n        node = TreeNode(int(val))\n        node.left = helper(nodes)\n        node.right = helper(nodes)\n        return node\n    return helper(iter(data.split(',')))", "assertions": "root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))\nserialized = serialize_binary_tree(root)\ndeserialized = deserialize_binary_tree(serialized)\nassert deserialized.val == 1\nassert deserialized.left.val == 2\nassert deserialized.right.val == 3\nassert serialize_binary_tree(None) == 'null'\nassert deserialize_binary_tree('null') is None", "metadata": {"language": "Python", "function_name": "serialize_binary_tree", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.88}}
{"query_id": "synthetic-005", "query_text": "Write a Python function named `word_ladder` that finds the shortest transformation sequence from beginWord to endWord. Language: Python. Function name: word_ladder", "reference_answer": "from collections import deque\n\ndef word_ladder(begin_word: str, end_word: str, word_list: list[str]) -> int:\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return 0\n    \n    queue = deque([(begin_word, 1)])\n    visited = {begin_word}\n    \n    while queue:\n        word, length = queue.popleft()\n        if word == end_word:\n            return length\n        \n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                new_word = word[:i] + c + word[i+1:]\n                if new_word in word_set and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, length + 1))\n    return 0", "assertions": "assert word_ladder('hit', 'cog', ['hot','dot','dog','lot','log','cog']) == 5\nassert word_ladder('hit', 'cog', ['hot','dot','dog','lot','log']) == 0\nassert word_ladder('a', 'c', ['a','b','c']) == 2\nassert word_ladder('hot', 'dog', ['hot','dog']) == 0", "metadata": {"language": "Python", "function_name": "word_ladder", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.92}}
{"query_id": "synthetic-006", "query_text": "Write a Python function named `kmp_search` that implements the KMP string matching algorithm. Language: Python. Function name: kmp_search", "reference_answer": "def kmp_search(text: str, pattern: str) -> list[int]:\n    if not pattern:\n        return list(range(len(text) + 1))\n    \n    def build_lps(pattern: str) -> list[int]:\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            elif length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n        return lps\n    \n    lps = build_lps(pattern)\n    result = []\n    i = j = 0\n    \n    while i < len(text):\n        if text[i] == pattern[j]:\n            i += 1\n            j += 1\n            if j == len(pattern):\n                result.append(i - j)\n                j = lps[j - 1]\n        elif j != 0:\n            j = lps[j - 1]\n        else:\n            i += 1\n    return result", "assertions": "assert kmp_search('ABABDABACDABABCABAB', 'ABABCABAB') == [10]\nassert kmp_search('AAAAAA', 'AAA') == [0, 1, 2, 3]\nassert kmp_search('ABC', 'D') == []\nassert kmp_search('', 'A') == []\nassert kmp_search('ABCABC', 'ABC') == [0, 3]", "metadata": {"language": "Python", "function_name": "kmp_search", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-007", "query_text": "Write a Python function named `find_median_stream` that finds the median from a data stream efficiently. Language: Python. Function name: find_median_stream", "reference_answer": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max heap (inverted)\n        self.large = []  # min heap\n    \n    def add_num(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    \n    def find_median(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2\n\ndef find_median_stream() -> MedianFinder:\n    return MedianFinder()", "assertions": "mf = find_median_stream()\nmf.add_num(1)\nassert mf.find_median() == 1.0\nmf.add_num(2)\nassert mf.find_median() == 1.5\nmf.add_num(3)\nassert mf.find_median() == 2.0\nmf.add_num(4)\nassert mf.find_median() == 2.5\nmf.add_num(5)\nassert mf.find_median() == 3.0", "metadata": {"language": "Python", "function_name": "find_median_stream", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.88}}
{"query_id": "synthetic-008", "query_text": "Write a Python function named `longest_increasing_path` that finds the longest increasing path in a matrix. Language: Python. Function name: longest_increasing_path", "reference_answer": "def longest_increasing_path(matrix: list[list[int]]) -> int:\n    if not matrix or not matrix[0]:\n        return 0\n    \n    m, n = len(matrix), len(matrix[0])\n    memo = {}\n    \n    def dfs(i: int, j: int) -> int:\n        if (i, j) in memo:\n            return memo[(i, j)]\n        \n        result = 1\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                result = max(result, 1 + dfs(ni, nj))\n        \n        memo[(i, j)] = result\n        return result\n    \n    return max(dfs(i, j) for i in range(m) for j in range(n))", "assertions": "assert longest_increasing_path([[9,9,4],[6,6,8],[2,1,1]]) == 4\nassert longest_increasing_path([[3,4,5],[3,2,6],[2,2,1]]) == 4\nassert longest_increasing_path([[1]]) == 1\nassert longest_increasing_path([]) == 0\nassert longest_increasing_path([[1,2],[4,3]]) == 4", "metadata": {"language": "Python", "function_name": "longest_increasing_path", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.87}}
{"query_id": "synthetic-009", "query_text": "Write a TypeScript function named `throttle` that creates a throttled version of a function. Language: TypeScript. Function name: throttle", "reference_answer": "function throttle<T extends (...args: any[]) => void>(func: T, limit: number): (...args: Parameters<T>) => void {\n    let lastCall = 0;\n    let lastResult: ReturnType<T>;\n    return (...args: Parameters<T>) => {\n        const now = Date.now();\n        if (now - lastCall >= limit) {\n            lastCall = now;\n            lastResult = func(...args) as ReturnType<T>;\n        }\n    };\n}", "assertions": "let counter = 0;\nconst increment = () => counter++;\nconst throttledIncrement = throttle(increment, 100);\nthrottledIncrement();\nthrottledIncrement();\nthrottledIncrement();\nif (counter !== 1) throw new Error('Failed - should only call once immediately');\nsetTimeout(() => {\n    throttledIncrement();\n    if (counter !== 2) throw new Error('Failed - should call again after limit');\n}, 150);", "metadata": {"language": "TypeScript", "function_name": "throttle", "difficulty": "advanced", "category": "concurrency", "complexity": 0.7}}
{"query_id": "synthetic-010", "query_text": "Write a TypeScript function named `memoize` that creates a memoized version of a function. Language: TypeScript. Function name: memoize", "reference_answer": "function memoize<T extends (...args: any[]) => any>(fn: T): T {\n    const cache = new Map<string, ReturnType<T>>();\n    return ((...args: Parameters<T>): ReturnType<T> => {\n        const key = JSON.stringify(args);\n        if (cache.has(key)) {\n            return cache.get(key)!;\n        }\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    }) as T;\n}", "assertions": "let callCount = 0;\nconst expensiveFunc = (n: number) => { callCount++; return n * 2; };\nconst memoizedFunc = memoize(expensiveFunc);\nif (memoizedFunc(5) !== 10) throw new Error('Failed');\nif (memoizedFunc(5) !== 10) throw new Error('Failed');\nif (callCount !== 1) throw new Error('Failed - should cache result');\nif (memoizedFunc(10) !== 20) throw new Error('Failed');\nif (callCount !== 2) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "memoize", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.72}}
{"query_id": "synthetic-011", "query_text": "Write a TypeScript function named `retry` that retries a promise-returning function with exponential backoff. Language: TypeScript. Function name: retry", "reference_answer": "async function retry<T>(\n    fn: () => Promise<T>,\n    maxRetries: number = 3,\n    baseDelay: number = 100\n): Promise<T> {\n    let lastError: Error;\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n            return await fn();\n        } catch (error) {\n            lastError = error as Error;\n            if (attempt < maxRetries) {\n                await new Promise(resolve => \n                    setTimeout(resolve, baseDelay * Math.pow(2, attempt))\n                );\n            }\n        }\n    }\n    throw lastError!;\n}", "assertions": "let attempts = 0;\nconst failTwice = async () => {\n    attempts++;\n    if (attempts < 3) throw new Error('Fail');\n    return 'success';\n};\nretry(failTwice).then(result => {\n    if (result !== 'success') throw new Error('Failed');\n    if (attempts !== 3) throw new Error('Failed - wrong attempt count');\n});\nlet neverSucceeds = 0;\nconst alwaysFail = async () => { neverSucceeds++; throw new Error('Always fails'); };\nretry(alwaysFail, 2).catch(e => {\n    if (neverSucceeds !== 3) throw new Error('Failed - should try 3 times');\n});", "metadata": {"language": "TypeScript", "function_name": "retry", "difficulty": "advanced", "category": "error_handling", "complexity": 0.75}}
{"query_id": "synthetic-012", "query_text": "Write a TypeScript function named `EventEmitter` that implements a simple event emitter pattern. Language: TypeScript. Function name: EventEmitter", "reference_answer": "class EventEmitter {\n    private events: Map<string, Function[]> = new Map();\n    \n    on(event: string, callback: Function): void {\n        if (!this.events.has(event)) {\n            this.events.set(event, []);\n        }\n        this.events.get(event)!.push(callback);\n    }\n    \n    off(event: string, callback: Function): void {\n        const callbacks = this.events.get(event);\n        if (callbacks) {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1) callbacks.splice(index, 1);\n        }\n    }\n    \n    emit(event: string, ...args: any[]): void {\n        const callbacks = this.events.get(event);\n        if (callbacks) {\n            callbacks.forEach(cb => cb(...args));\n        }\n    }\n    \n    once(event: string, callback: Function): void {\n        const wrapper = (...args: any[]) => {\n            callback(...args);\n            this.off(event, wrapper);\n        };\n        this.on(event, wrapper);\n    }\n}", "assertions": "const emitter = new EventEmitter();\nlet value = 0;\nconst handler = (n: number) => value += n;\nemitter.on('add', handler);\nemitter.emit('add', 5);\nif (value !== 5) throw new Error('Failed');\nemitter.emit('add', 3);\nif (value !== 8) throw new Error('Failed');\nemitter.off('add', handler);\nemitter.emit('add', 10);\nif (value !== 8) throw new Error('Failed');\nlet onceValue = 0;\nemitter.once('single', (n: number) => onceValue = n);\nemitter.emit('single', 42);\nemitter.emit('single', 100);\nif (onceValue !== 42) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "EventEmitter", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.78}}
{"query_id": "synthetic-013", "query_text": "Write a TypeScript function named `pipe` that composes functions from left to right. Language: TypeScript. Function name: pipe", "reference_answer": "function pipe<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {\n    return (arg: T) => fns.reduce((result, fn) => fn(result), arg);\n}\n\nfunction pipeAsync<T>(...fns: Array<(arg: T) => T | Promise<T>>): (arg: T) => Promise<T> {\n    return async (arg: T) => {\n        let result = arg;\n        for (const fn of fns) {\n            result = await fn(result);\n        }\n        return result;\n    };\n}", "assertions": "const addOne = (x: number) => x + 1;\nconst double = (x: number) => x * 2;\nconst square = (x: number) => x * x;\nconst composed = pipe(addOne, double, square);\nif (composed(2) !== 36) throw new Error('Failed: (2+1)*2=6, 6^2=36');\nif (composed(0) !== 4) throw new Error('Failed: (0+1)*2=2, 2^2=4');\nconst identity = pipe<number>();\nif (identity(5) !== 5) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "pipe", "difficulty": "medium", "category": "design_patterns", "complexity": 0.55}}
{"query_id": "synthetic-014", "query_text": "Write a TypeScript function named `flatMap` that maps and flattens an array in one pass. Language: TypeScript. Function name: flatMap", "reference_answer": "function flatMap<T, U>(arr: T[], fn: (item: T, index: number) => U[]): U[] {\n    const result: U[] = [];\n    for (let i = 0; i < arr.length; i++) {\n        const mapped = fn(arr[i], i);\n        for (const item of mapped) {\n            result.push(item);\n        }\n    }\n    return result;\n}", "assertions": "const result1 = flatMap([1, 2, 3], x => [x, x * 2]);\nif (JSON.stringify(result1) !== JSON.stringify([1, 2, 2, 4, 3, 6])) throw new Error('Failed');\nconst result2 = flatMap(['hello', 'world'], s => s.split(''));\nif (result2.length !== 10) throw new Error('Failed');\nconst result3 = flatMap([], (x: number) => [x]);\nif (result3.length !== 0) throw new Error('Failed');\nconst result4 = flatMap([1, 2], x => x % 2 === 0 ? [x] : []);\nif (JSON.stringify(result4) !== JSON.stringify([2])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "flatMap", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-015", "query_text": "Write a Go function named `MergeSort` that implements merge sort. Language: Go. Function name: MergeSort", "reference_answer": "package main\n\nfunc MergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tmid := len(arr) / 2\n\tleft := MergeSort(arr[:mid])\n\tright := MergeSort(arr[mid:])\n\treturn merge(left, right)\n}\n\nfunc merge(left, right []int) []int {\n\tresult := make([]int, 0, len(left)+len(right))\n\ti, j := 0, 0\n\tfor i < len(left) && j < len(right) {\n\t\tif left[i] <= right[j] {\n\t\t\tresult = append(result, left[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tresult = append(result, right[j])\n\t\t\tj++\n\t\t}\n\t}\n\tresult = append(result, left[i:]...)\n\tresult = append(result, right[j:]...)\n\treturn result\n}", "assertions": "import \"reflect\"\nif !reflect.DeepEqual(MergeSort([]int{64, 34, 25, 12, 22, 11, 90}), []int{11, 12, 22, 25, 34, 64, 90}) { panic(\"Failed\") }\nif !reflect.DeepEqual(MergeSort([]int{}), []int{}) { panic(\"Failed\") }\nif !reflect.DeepEqual(MergeSort([]int{1}), []int{1}) { panic(\"Failed\") }\nif !reflect.DeepEqual(MergeSort([]int{5, 4, 3, 2, 1}), []int{1, 2, 3, 4, 5}) { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "MergeSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-016", "query_text": "Write a Go function named `BinarySearch` that performs binary search on a sorted slice. Language: Go. Function name: BinarySearch", "reference_answer": "package main\n\nfunc BinarySearch(arr []int, target int) int {\n\tleft, right := 0, len(arr)-1\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif arr[mid] == target {\n\t\t\treturn mid\n\t\t} else if arr[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else {\n\t\t\tright = mid - 1\n\t\t}\n\t}\n\treturn -1\n}", "assertions": "if BinarySearch([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}, 5) != 4 { panic(\"Failed\") }\nif BinarySearch([]int{1, 2, 3, 4, 5}, 1) != 0 { panic(\"Failed\") }\nif BinarySearch([]int{1, 2, 3, 4, 5}, 5) != 4 { panic(\"Failed\") }\nif BinarySearch([]int{1, 2, 3, 4, 5}, 6) != -1 { panic(\"Failed\") }\nif BinarySearch([]int{}, 1) != -1 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "BinarySearch", "difficulty": "advanced", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-017", "query_text": "Write a Rust function named `merge_sort` that implements merge sort. Language: Rust. Function name: merge_sort", "reference_answer": "pub fn merge_sort(arr: &mut [i32]) {\n    let len = arr.len();\n    if len <= 1 {\n        return;\n    }\n    let mid = len / 2;\n    merge_sort(&mut arr[..mid]);\n    merge_sort(&mut arr[mid..]);\n    let mut temp = arr.to_vec();\n    merge(&arr[..mid], &arr[mid..], &mut temp);\n    arr.copy_from_slice(&temp);\n}\n\nfn merge(left: &[i32], right: &[i32], result: &mut [i32]) {\n    let (mut i, mut j, mut k) = (0, 0, 0);\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] {\n            result[k] = left[i];\n            i += 1;\n        } else {\n            result[k] = right[j];\n            j += 1;\n        }\n        k += 1;\n    }\n    while i < left.len() {\n        result[k] = left[i];\n        i += 1;\n        k += 1;\n    }\n    while j < right.len() {\n        result[k] = right[j];\n        j += 1;\n        k += 1;\n    }\n}", "assertions": "let mut arr1 = vec![64, 34, 25, 12, 22, 11, 90];\nmerge_sort(&mut arr1);\nassert_eq!(arr1, vec![11, 12, 22, 25, 34, 64, 90]);\nlet mut arr2: Vec<i32> = vec![];\nmerge_sort(&mut arr2);\nassert_eq!(arr2, vec![]);\nlet mut arr3 = vec![5, 4, 3, 2, 1];\nmerge_sort(&mut arr3);\nassert_eq!(arr3, vec![1, 2, 3, 4, 5]);", "metadata": {"language": "Rust", "function_name": "merge_sort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-018", "query_text": "Write a Java function named `findKthLargest` that finds the kth largest element in an array. Language: Java. Function name: findKthLargest", "reference_answer": "import java.util.PriorityQueue;\n\npublic class Solution {\n    public static int findKthLargest(int[] nums, int k) {\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        for (int num : nums) {\n            minHeap.offer(num);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n        return minHeap.peek();\n    }\n}", "assertions": "if (Solution.findKthLargest(new int[]{3,2,1,5,6,4}, 2) != 5) throw new RuntimeException(\"Failed\");\nif (Solution.findKthLargest(new int[]{3,2,3,1,2,4,5,5,6}, 4) != 4) throw new RuntimeException(\"Failed\");\nif (Solution.findKthLargest(new int[]{1}, 1) != 1) throw new RuntimeException(\"Failed\");\nif (Solution.findKthLargest(new int[]{7,6,5,4,3,2,1}, 5) != 3) throw new RuntimeException(\"Failed\");", "metadata": {"language": "Java", "function_name": "findKthLargest", "difficulty": "advanced", "category": "algorithms", "complexity": 0.72}}
{"query_id": "synthetic-019", "query_text": "Write a JavaScript function named `curry` that curries a function. Language: JavaScript. Function name: curry", "reference_answer": "function curry(fn) {\n    return function curried(...args) {\n        if (args.length >= fn.length) {\n            return fn.apply(this, args);\n        }\n        return function(...moreArgs) {\n            return curried.apply(this, args.concat(moreArgs));\n        };\n    };\n}", "assertions": "const add = (a, b, c) => a + b + c;\nconst curriedAdd = curry(add);\nif (curriedAdd(1)(2)(3) !== 6) throw new Error('Failed');\nif (curriedAdd(1, 2)(3) !== 6) throw new Error('Failed');\nif (curriedAdd(1)(2, 3) !== 6) throw new Error('Failed');\nif (curriedAdd(1, 2, 3) !== 6) throw new Error('Failed');\nconst multiply = (a, b) => a * b;\nconst curriedMultiply = curry(multiply);\nif (curriedMultiply(3)(4) !== 12) throw new Error('Failed');", "metadata": {"language": "JavaScript", "function_name": "curry", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.75}}
{"query_id": "synthetic-020", "query_text": "Write a C++ function named `longestPalindromicSubstring` that finds the longest palindromic substring. Language: C++. Function name: longestPalindromicSubstring", "reference_answer": "#include <string>\nusing namespace std;\n\nstring longestPalindromicSubstring(const string& s) {\n    if (s.empty()) return \"\";\n    int n = s.length();\n    int start = 0, maxLen = 1;\n    \n    auto expandAroundCenter = [&](int left, int right) {\n        while (left >= 0 && right < n && s[left] == s[right]) {\n            if (right - left + 1 > maxLen) {\n                start = left;\n                maxLen = right - left + 1;\n            }\n            left--;\n            right++;\n        }\n    };\n    \n    for (int i = 0; i < n; i++) {\n        expandAroundCenter(i, i);\n        expandAroundCenter(i, i + 1);\n    }\n    return s.substr(start, maxLen);\n}", "assertions": "#include <cassert>\nassert(longestPalindromicSubstring(\"babad\") == \"bab\" || longestPalindromicSubstring(\"babad\") == \"aba\");\nassert(longestPalindromicSubstring(\"cbbd\") == \"bb\");\nassert(longestPalindromicSubstring(\"a\") == \"a\");\nassert(longestPalindromicSubstring(\"\") == \"\");\nassert(longestPalindromicSubstring(\"racecar\") == \"racecar\");", "metadata": {"language": "C++", "function_name": "longestPalindromicSubstring", "difficulty": "advanced", "category": "algorithms", "complexity": 0.78}}
{"query_id": "synthetic-021", "query_text": "Write a Python function named `dijkstra` that implements Dijkstra's shortest path algorithm. Language: Python. Function name: dijkstra", "reference_answer": "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph: dict[int, list[tuple[int, int]]], start: int) -> dict[int, int]:\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph.get(current, []):\n            distance = current_dist + weight\n            if distance < distances.get(neighbor, float('inf')):\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return {k: v for k, v in distances.items() if v != float('inf')}", "assertions": "graph = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}\nresult = dijkstra(graph, 0)\nassert result[0] == 0\nassert result[1] == 3\nassert result[2] == 1\nassert result[3] == 4\nassert dijkstra({0: []}, 0) == {0: 0}", "metadata": {"language": "Python", "function_name": "dijkstra", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-022", "query_text": "Write a Python function named `levenshtein_distance` that calculates the edit distance between two strings. Language: Python. Function name: levenshtein_distance", "reference_answer": "def levenshtein_distance(s1: str, s2: str) -> int:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]", "assertions": "assert levenshtein_distance('kitten', 'sitting') == 3\nassert levenshtein_distance('', '') == 0\nassert levenshtein_distance('abc', '') == 3\nassert levenshtein_distance('', 'abc') == 3\nassert levenshtein_distance('same', 'same') == 0\nassert levenshtein_distance('a', 'b') == 1", "metadata": {"language": "Python", "function_name": "levenshtein_distance", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-023", "query_text": "Write a Python function named `knapsack` that solves the 0/1 knapsack problem. Language: Python. Function name: knapsack", "reference_answer": "def knapsack(weights: list[int], values: list[int], capacity: int) -> int:\n    n = len(weights)\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(capacity + 1):\n            if weights[i-1] <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w - weights[i-1]] + values[i-1])\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return dp[n][capacity]", "assertions": "assert knapsack([1, 2, 3], [6, 10, 12], 5) == 22\nassert knapsack([2, 3, 4, 5], [3, 4, 5, 6], 5) == 7\nassert knapsack([], [], 10) == 0\nassert knapsack([10], [100], 5) == 0\nassert knapsack([1, 1, 1], [10, 20, 30], 2) == 50", "metadata": {"language": "Python", "function_name": "knapsack", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-024", "query_text": "Write a Python function named `min_window_substring` that finds the minimum window containing all characters. Language: Python. Function name: min_window_substring", "reference_answer": "from collections import Counter\n\ndef min_window_substring(s: str, t: str) -> str:\n    if not s or not t:\n        return ''\n    \n    target = Counter(t)\n    required = len(target)\n    left = 0\n    formed = 0\n    window = {}\n    result = (float('inf'), 0, 0)\n    \n    for right, char in enumerate(s):\n        window[char] = window.get(char, 0) + 1\n        if char in target and window[char] == target[char]:\n            formed += 1\n        \n        while formed == required:\n            if right - left + 1 < result[0]:\n                result = (right - left + 1, left, right)\n            \n            left_char = s[left]\n            window[left_char] -= 1\n            if left_char in target and window[left_char] < target[left_char]:\n                formed -= 1\n            left += 1\n    \n    return '' if result[0] == float('inf') else s[result[1]:result[2] + 1]", "assertions": "assert min_window_substring('ADOBECODEBANC', 'ABC') == 'BANC'\nassert min_window_substring('a', 'a') == 'a'\nassert min_window_substring('a', 'aa') == ''\nassert min_window_substring('', 'A') == ''\nassert min_window_substring('aa', 'aa') == 'aa'", "metadata": {"language": "Python", "function_name": "min_window_substring", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.92}}
{"query_id": "synthetic-025", "query_text": "Write a Python function named `count_inversions` that counts the number of inversions in an array using merge sort. Language: Python. Function name: count_inversions", "reference_answer": "def count_inversions(arr: list[int]) -> int:\n    def merge_count(arr: list[int]) -> tuple[list[int], int]:\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, left_inv = merge_count(arr[:mid])\n        right, right_inv = merge_count(arr[mid:])\n        \n        merged = []\n        inversions = left_inv + right_inv\n        i = j = 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inversions += len(left) - i\n                j += 1\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    return merge_count(arr)[1]", "assertions": "assert count_inversions([2, 4, 1, 3, 5]) == 3\nassert count_inversions([1, 2, 3, 4, 5]) == 0\nassert count_inversions([5, 4, 3, 2, 1]) == 10\nassert count_inversions([]) == 0\nassert count_inversions([1]) == 0\nassert count_inversions([2, 1]) == 1", "metadata": {"language": "Python", "function_name": "count_inversions", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-026", "query_text": "Write a Python function named `tarjan_scc` that finds strongly connected components using Tarjan's algorithm. Language: Python. Function name: tarjan_scc", "reference_answer": "def tarjan_scc(graph: dict[int, list[int]]) -> list[list[int]]:\n    index_counter = [0]\n    stack = []\n    lowlink = {}\n    index = {}\n    on_stack = {}\n    result = []\n    \n    def strongconnect(v):\n        index[v] = index_counter[0]\n        lowlink[v] = index_counter[0]\n        index_counter[0] += 1\n        stack.append(v)\n        on_stack[v] = True\n        \n        for w in graph.get(v, []):\n            if w not in index:\n                strongconnect(w)\n                lowlink[v] = min(lowlink[v], lowlink[w])\n            elif on_stack.get(w, False):\n                lowlink[v] = min(lowlink[v], index[w])\n        \n        if lowlink[v] == index[v]:\n            scc = []\n            while True:\n                w = stack.pop()\n                on_stack[w] = False\n                scc.append(w)\n                if w == v:\n                    break\n            result.append(scc)\n    \n    for v in graph:\n        if v not in index:\n            strongconnect(v)\n    \n    return result", "assertions": "graph = {0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3]}\nsccs = tarjan_scc(graph)\nassert len(sccs) == 2\nassert tarjan_scc({0: [], 1: [], 2: []}) == [[2], [1], [0]] or len(tarjan_scc({0: [], 1: [], 2: []})) == 3\nassert tarjan_scc({}) == []", "metadata": {"language": "Python", "function_name": "tarjan_scc", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-027", "query_text": "Write a Python function named `async_rate_limiter` that implements an async rate limiter. Language: Python. Function name: async_rate_limiter", "reference_answer": "import asyncio\nfrom collections import deque\nimport time\n\nclass AsyncRateLimiter:\n    def __init__(self, max_calls: int, period: float):\n        self.max_calls = max_calls\n        self.period = period\n        self.calls = deque()\n        self.lock = asyncio.Lock()\n    \n    async def acquire(self):\n        async with self.lock:\n            now = time.monotonic()\n            while self.calls and now - self.calls[0] >= self.period:\n                self.calls.popleft()\n            \n            if len(self.calls) >= self.max_calls:\n                sleep_time = self.period - (now - self.calls[0])\n                await asyncio.sleep(sleep_time)\n                return await self.acquire()\n            \n            self.calls.append(now)\n            return True\n\ndef async_rate_limiter(max_calls: int, period: float) -> AsyncRateLimiter:\n    return AsyncRateLimiter(max_calls, period)", "assertions": "import asyncio\nasync def test():\n    limiter = async_rate_limiter(2, 1.0)\n    start = time.monotonic()\n    await limiter.acquire()\n    await limiter.acquire()\n    elapsed = time.monotonic() - start\n    assert elapsed < 0.1, 'First two calls should be immediate'\nasyncio.run(test())", "metadata": {"language": "Python", "function_name": "async_rate_limiter", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.9}}
{"query_id": "synthetic-028", "query_text": "Write a Python function named `bloom_filter` that implements a Bloom filter. Language: Python. Function name: bloom_filter", "reference_answer": "import hashlib\n\nclass BloomFilter:\n    def __init__(self, size: int, num_hashes: int):\n        self.size = size\n        self.num_hashes = num_hashes\n        self.bit_array = [False] * size\n    \n    def _hashes(self, item: str) -> list[int]:\n        hashes = []\n        for i in range(self.num_hashes):\n            h = hashlib.sha256(f'{item}{i}'.encode()).hexdigest()\n            hashes.append(int(h, 16) % self.size)\n        return hashes\n    \n    def add(self, item: str) -> None:\n        for h in self._hashes(item):\n            self.bit_array[h] = True\n    \n    def might_contain(self, item: str) -> bool:\n        return all(self.bit_array[h] for h in self._hashes(item))\n\ndef bloom_filter(size: int = 1000, num_hashes: int = 3) -> BloomFilter:\n    return BloomFilter(size, num_hashes)", "assertions": "bf = bloom_filter(1000, 3)\nbf.add('hello')\nbf.add('world')\nassert bf.might_contain('hello') == True\nassert bf.might_contain('world') == True\nassert bf.might_contain('python') == False or bf.might_contain('python') == True\nbf2 = bloom_filter(100, 5)\nassert bf2.might_contain('anything') == False", "metadata": {"language": "Python", "function_name": "bloom_filter", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.85}}
{"query_id": "synthetic-029", "query_text": "Write a TypeScript function named `Observable` that implements a simple observable pattern. Language: TypeScript. Function name: Observable", "reference_answer": "type Observer<T> = (value: T) => void;\n\nclass Observable<T> {\n    private observers: Set<Observer<T>> = new Set();\n    private _value: T;\n    \n    constructor(initialValue: T) {\n        this._value = initialValue;\n    }\n    \n    get value(): T {\n        return this._value;\n    }\n    \n    set value(newValue: T) {\n        this._value = newValue;\n        this.observers.forEach(observer => observer(newValue));\n    }\n    \n    subscribe(observer: Observer<T>): () => void {\n        this.observers.add(observer);\n        return () => this.observers.delete(observer);\n    }\n    \n    map<U>(fn: (value: T) => U): Observable<U> {\n        const derived = new Observable<U>(fn(this._value));\n        this.subscribe(value => derived.value = fn(value));\n        return derived;\n    }\n}", "assertions": "const obs = new Observable<number>(10);\nlet lastValue = 0;\nconst unsubscribe = obs.subscribe(v => lastValue = v);\nobs.value = 20;\nif (lastValue !== 20) throw new Error('Failed');\nunsubscribe();\nobs.value = 30;\nif (lastValue !== 20) throw new Error('Failed - should not update after unsubscribe');\nconst doubled = obs.map(x => x * 2);\nif (doubled.value !== 60) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "Observable", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.8}}
{"query_id": "synthetic-030", "query_text": "Write a TypeScript function named `promisePool` that limits concurrent promise execution. Language: TypeScript. Function name: promisePool", "reference_answer": "async function promisePool<T>(\n    tasks: (() => Promise<T>)[],\n    poolSize: number\n): Promise<T[]> {\n    const results: T[] = [];\n    let index = 0;\n    \n    async function runTask(): Promise<void> {\n        while (index < tasks.length) {\n            const currentIndex = index++;\n            results[currentIndex] = await tasks[currentIndex]();\n        }\n    }\n    \n    const workers = Array(Math.min(poolSize, tasks.length))\n        .fill(null)\n        .map(() => runTask());\n    \n    await Promise.all(workers);\n    return results;\n}", "assertions": "const delay = (ms: number, val: number) => new Promise<number>(r => setTimeout(() => r(val), ms));\nconst tasks = [() => delay(50, 1), () => delay(50, 2), () => delay(50, 3), () => delay(50, 4)];\nconst start = Date.now();\npromisePool(tasks, 2).then(results => {\n    const elapsed = Date.now() - start;\n    if (JSON.stringify(results) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed');\n    if (elapsed < 90 || elapsed > 150) throw new Error('Failed - wrong timing');\n});", "metadata": {"language": "TypeScript", "function_name": "promisePool", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.88}}
{"query_id": "synthetic-031", "query_text": "Write a TypeScript function named `LRUCache` that implements an LRU cache with O(1) operations. Language: TypeScript. Function name: LRUCache", "reference_answer": "class LRUCache<K, V> {\n    private capacity: number;\n    private cache: Map<K, V>;\n    \n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.cache = new Map();\n    }\n    \n    get(key: K): V | undefined {\n        if (!this.cache.has(key)) return undefined;\n        const value = this.cache.get(key)!;\n        this.cache.delete(key);\n        this.cache.set(key, value);\n        return value;\n    }\n    \n    put(key: K, value: V): void {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        } else if (this.cache.size >= this.capacity) {\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        this.cache.set(key, value);\n    }\n    \n    size(): number {\n        return this.cache.size;\n    }\n}", "assertions": "const cache = new LRUCache<number, number>(2);\ncache.put(1, 1);\ncache.put(2, 2);\nif (cache.get(1) !== 1) throw new Error('Failed');\ncache.put(3, 3);\nif (cache.get(2) !== undefined) throw new Error('Failed - 2 should be evicted');\ncache.put(4, 4);\nif (cache.get(1) !== undefined) throw new Error('Failed - 1 should be evicted');\nif (cache.get(3) !== 3 || cache.get(4) !== 4) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "LRUCache", "difficulty": "advanced", "category": "data_structures", "complexity": 0.78}}
{"query_id": "synthetic-032", "query_text": "Write a TypeScript function named `Trie` that implements a trie data structure with insert, search, and startsWith. Language: TypeScript. Function name: Trie", "reference_answer": "class TrieNode {\n    children: Map<string, TrieNode> = new Map();\n    isEndOfWord: boolean = false;\n}\n\nclass Trie {\n    private root: TrieNode = new TrieNode();\n    \n    insert(word: string): void {\n        let node = this.root;\n        for (const char of word) {\n            if (!node.children.has(char)) {\n                node.children.set(char, new TrieNode());\n            }\n            node = node.children.get(char)!;\n        }\n        node.isEndOfWord = true;\n    }\n    \n    search(word: string): boolean {\n        const node = this.findNode(word);\n        return node !== null && node.isEndOfWord;\n    }\n    \n    startsWith(prefix: string): boolean {\n        return this.findNode(prefix) !== null;\n    }\n    \n    private findNode(prefix: string): TrieNode | null {\n        let node = this.root;\n        for (const char of prefix) {\n            if (!node.children.has(char)) return null;\n            node = node.children.get(char)!;\n        }\n        return node;\n    }\n}", "assertions": "const trie = new Trie();\ntrie.insert('apple');\nif (trie.search('apple') !== true) throw new Error('Failed');\nif (trie.search('app') !== false) throw new Error('Failed');\nif (trie.startsWith('app') !== true) throw new Error('Failed');\ntrie.insert('app');\nif (trie.search('app') !== true) throw new Error('Failed');\nif (trie.startsWith('b') !== false) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "Trie", "difficulty": "advanced", "category": "data_structures", "complexity": 0.75}}
{"query_id": "synthetic-033", "query_text": "Write a TypeScript function named `dijkstra` that implements Dijkstra's algorithm for shortest paths. Language: TypeScript. Function name: dijkstra", "reference_answer": "interface Edge {\n    to: number;\n    weight: number;\n}\n\nfunction dijkstra(graph: Map<number, Edge[]>, start: number): Map<number, number> {\n    const distances = new Map<number, number>();\n    const visited = new Set<number>();\n    const pq: [number, number][] = [[0, start]];\n    \n    for (const node of graph.keys()) {\n        distances.set(node, Infinity);\n    }\n    distances.set(start, 0);\n    \n    while (pq.length > 0) {\n        pq.sort((a, b) => a[0] - b[0]);\n        const [dist, current] = pq.shift()!;\n        \n        if (visited.has(current)) continue;\n        visited.add(current);\n        \n        for (const edge of graph.get(current) || []) {\n            const newDist = dist + edge.weight;\n            if (newDist < (distances.get(edge.to) || Infinity)) {\n                distances.set(edge.to, newDist);\n                pq.push([newDist, edge.to]);\n            }\n        }\n    }\n    \n    return distances;\n}", "assertions": "const graph = new Map<number, Edge[]>();\ngraph.set(0, [{to: 1, weight: 4}, {to: 2, weight: 1}]);\ngraph.set(1, [{to: 3, weight: 1}]);\ngraph.set(2, [{to: 1, weight: 2}, {to: 3, weight: 5}]);\ngraph.set(3, []);\nconst dists = dijkstra(graph, 0);\nif (dists.get(0) !== 0) throw new Error('Failed');\nif (dists.get(1) !== 3) throw new Error('Failed');\nif (dists.get(2) !== 1) throw new Error('Failed');\nif (dists.get(3) !== 4) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "dijkstra", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-034", "query_text": "Write a TypeScript function named `mergeSort` that implements merge sort. Language: TypeScript. Function name: mergeSort", "reference_answer": "function mergeSort<T>(arr: T[], compareFn: (a: T, b: T) => number = (a, b) => (a as any) - (b as any)): T[] {\n    if (arr.length <= 1) return arr;\n    \n    const mid = Math.floor(arr.length / 2);\n    const left = mergeSort(arr.slice(0, mid), compareFn);\n    const right = mergeSort(arr.slice(mid), compareFn);\n    \n    return merge(left, right, compareFn);\n}\n\nfunction merge<T>(left: T[], right: T[], compareFn: (a: T, b: T) => number): T[] {\n    const result: T[] = [];\n    let i = 0, j = 0;\n    \n    while (i < left.length && j < right.length) {\n        if (compareFn(left[i], right[j]) <= 0) {\n            result.push(left[i++]);\n        } else {\n            result.push(right[j++]);\n        }\n    }\n    \n    return result.concat(left.slice(i)).concat(right.slice(j));\n}", "assertions": "if (JSON.stringify(mergeSort([5, 3, 8, 4, 2])) !== JSON.stringify([2, 3, 4, 5, 8])) throw new Error('Failed');\nif (JSON.stringify(mergeSort([])) !== JSON.stringify([])) throw new Error('Failed');\nif (JSON.stringify(mergeSort([1])) !== JSON.stringify([1])) throw new Error('Failed');\nconst strs = mergeSort(['banana', 'apple', 'cherry'], (a, b) => a.localeCompare(b));\nif (JSON.stringify(strs) !== JSON.stringify(['apple', 'banana', 'cherry'])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "mergeSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-035", "query_text": "Write a Go function named `LRUCache` that implements an LRU cache. Language: Go. Function name: LRUCache", "reference_answer": "package main\n\nimport \"container/list\"\n\ntype LRUCache struct {\n\tcapacity int\n\tcache    map[int]*list.Element\n\tlist     *list.List\n}\n\ntype entry struct {\n\tkey   int\n\tvalue int\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n\treturn &LRUCache{\n\t\tcapacity: capacity,\n\t\tcache:    make(map[int]*list.Element),\n\t\tlist:     list.New(),\n\t}\n}\n\nfunc (c *LRUCache) Get(key int) int {\n\tif elem, ok := c.cache[key]; ok {\n\t\tc.list.MoveToFront(elem)\n\t\treturn elem.Value.(*entry).value\n\t}\n\treturn -1\n}\n\nfunc (c *LRUCache) Put(key, value int) {\n\tif elem, ok := c.cache[key]; ok {\n\t\tc.list.MoveToFront(elem)\n\t\telem.Value.(*entry).value = value\n\t\treturn\n\t}\n\tif c.list.Len() >= c.capacity {\n\t\toldest := c.list.Back()\n\t\tdelete(c.cache, oldest.Value.(*entry).key)\n\t\tc.list.Remove(oldest)\n\t}\n\telem := c.list.PushFront(&entry{key, value})\n\tc.cache[key] = elem\n}", "assertions": "cache := NewLRUCache(2)\ncache.Put(1, 1)\ncache.Put(2, 2)\nif cache.Get(1) != 1 { panic(\"Failed\") }\ncache.Put(3, 3)\nif cache.Get(2) != -1 { panic(\"Failed - 2 should be evicted\") }\ncache.Put(4, 4)\nif cache.Get(1) != -1 { panic(\"Failed - 1 should be evicted\") }\nif cache.Get(3) != 3 { panic(\"Failed\") }\nif cache.Get(4) != 4 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "LRUCache", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.85}}
{"query_id": "synthetic-036", "query_text": "Write a Go function named `ConcurrentMap` that implements a thread-safe map. Language: Go. Function name: ConcurrentMap", "reference_answer": "package main\n\nimport \"sync\"\n\ntype ConcurrentMap[K comparable, V any] struct {\n\tmu    sync.RWMutex\n\tstore map[K]V\n}\n\nfunc NewConcurrentMap[K comparable, V any]() *ConcurrentMap[K, V] {\n\treturn &ConcurrentMap[K, V]{\n\t\tstore: make(map[K]V),\n\t}\n}\n\nfunc (m *ConcurrentMap[K, V]) Set(key K, value V) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.store[key] = value\n}\n\nfunc (m *ConcurrentMap[K, V]) Get(key K) (V, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tval, ok := m.store[key]\n\treturn val, ok\n}\n\nfunc (m *ConcurrentMap[K, V]) Delete(key K) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tdelete(m.store, key)\n}\n\nfunc (m *ConcurrentMap[K, V]) Len() int {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\treturn len(m.store)\n}", "assertions": "cm := NewConcurrentMap[string, int]()\ncm.Set(\"a\", 1)\ncm.Set(\"b\", 2)\nif v, ok := cm.Get(\"a\"); !ok || v != 1 { panic(\"Failed\") }\nif v, ok := cm.Get(\"c\"); ok { panic(\"Failed - should not exist\") }\ncm.Delete(\"a\")\nif _, ok := cm.Get(\"a\"); ok { panic(\"Failed - should be deleted\") }\nif cm.Len() != 1 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "ConcurrentMap", "difficulty": "advanced", "category": "concurrency", "complexity": 0.75}}
{"query_id": "synthetic-037", "query_text": "Write a Rust function named `binary_search` that performs binary search on a sorted slice. Language: Rust. Function name: binary_search", "reference_answer": "pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {\n    let mut left = 0;\n    let mut right = arr.len();\n    \n    while left < right {\n        let mid = left + (right - left) / 2;\n        match arr[mid].cmp(target) {\n            std::cmp::Ordering::Equal => return Some(mid),\n            std::cmp::Ordering::Less => left = mid + 1,\n            std::cmp::Ordering::Greater => right = mid,\n        }\n    }\n    None\n}", "assertions": "assert_eq!(binary_search(&[1, 2, 3, 4, 5], &3), Some(2));\nassert_eq!(binary_search(&[1, 2, 3, 4, 5], &1), Some(0));\nassert_eq!(binary_search(&[1, 2, 3, 4, 5], &5), Some(4));\nassert_eq!(binary_search(&[1, 2, 3, 4, 5], &6), None);\nassert_eq!(binary_search::<i32>(&[], &1), None);", "metadata": {"language": "Rust", "function_name": "binary_search", "difficulty": "advanced", "category": "algorithms", "complexity": 0.65}}
{"query_id": "synthetic-038", "query_text": "Write a Ruby function named `permutations` that generates all permutations of an array. Language: Ruby. Function name: permutations", "reference_answer": "def permutations(arr)\n  return [[]] if arr.empty?\n  return [arr] if arr.length == 1\n  \n  result = []\n  arr.each_with_index do |elem, i|\n    rest = arr[0...i] + arr[i+1..-1]\n    permutations(rest).each do |perm|\n      result << [elem] + perm\n    end\n  end\n  result\nend", "assertions": "raise 'Failed' unless permutations([1, 2, 3]).length == 6\nraise 'Failed' unless permutations([1, 2, 3]).include?([1, 2, 3])\nraise 'Failed' unless permutations([1, 2, 3]).include?([3, 2, 1])\nraise 'Failed' unless permutations([]).length == 1\nraise 'Failed' unless permutations([1]).length == 1", "metadata": {"language": "Ruby", "function_name": "permutations", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-039", "query_text": "Write a Swift function named `quickSort` that implements quicksort. Language: Swift. Function name: quickSort", "reference_answer": "func quickSort<T: Comparable>(_ array: inout [T], low: Int, high: Int) {\n    if low < high {\n        let pivotIndex = partition(&array, low: low, high: high)\n        quickSort(&array, low: low, high: pivotIndex - 1)\n        quickSort(&array, low: pivotIndex + 1, high: high)\n    }\n}\n\nfunc partition<T: Comparable>(_ array: inout [T], low: Int, high: Int) -> Int {\n    let pivot = array[high]\n    var i = low - 1\n    \n    for j in low..<high {\n        if array[j] <= pivot {\n            i += 1\n            array.swapAt(i, j)\n        }\n    }\n    array.swapAt(i + 1, high)\n    return i + 1\n}\n\nfunc quickSortArray<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    if arr.count > 1 {\n        quickSort(&arr, low: 0, high: arr.count - 1)\n    }\n    return arr\n}", "assertions": "var arr1 = [5, 3, 8, 4, 2]\nquickSort(&arr1, low: 0, high: arr1.count - 1)\nassert(arr1 == [2, 3, 4, 5, 8], \"Failed\")\nvar arr2: [Int] = []\nquickSort(&arr2, low: 0, high: max(0, arr2.count - 1))\nassert(arr2 == [], \"Failed\")\nvar arr3 = [1]\nassert(quickSortArray(arr3) == [1], \"Failed\")", "metadata": {"language": "Swift", "function_name": "quickSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.72}}
{"query_id": "synthetic-040", "query_text": "Write a Kotlin function named `flatten` that flattens a nested list structure. Language: Kotlin. Function name: flatten", "reference_answer": "fun flatten(list: List<Any>): List<Any> {\n    val result = mutableListOf<Any>()\n    for (item in list) {\n        when (item) {\n            is List<*> -> result.addAll(flatten(item.filterNotNull() as List<Any>))\n            else -> result.add(item)\n        }\n    }\n    return result\n}\n\nfun <T> flattenTyped(list: List<Any>): List<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return flatten(list) as List<T>\n}", "assertions": "val result1 = flatten(listOf(1, listOf(2, listOf(3, 4), 5), 6))\nif (result1 != listOf(1, 2, 3, 4, 5, 6)) throw RuntimeException(\"Failed\")\nval result2 = flatten(listOf(1, 2, 3))\nif (result2 != listOf(1, 2, 3)) throw RuntimeException(\"Failed\")\nval result3 = flatten(emptyList<Any>())\nif (result3.isNotEmpty()) throw RuntimeException(\"Failed\")\nval result4 = flatten(listOf(listOf(listOf(1))))\nif (result4 != listOf(1)) throw RuntimeException(\"Failed\")", "metadata": {"language": "Kotlin", "function_name": "flatten", "difficulty": "medium", "category": "data_structures", "complexity": 0.55}}
{"query_id": "synthetic-041", "query_text": "Write a Python function named `coin_change` that finds the minimum number of coins needed to make a target amount. Language: Python. Function name: coin_change", "reference_answer": "def coin_change(coins: list[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    \n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1", "assertions": "assert coin_change([1, 2, 5], 11) == 3\nassert coin_change([2], 3) == -1\nassert coin_change([1], 0) == 0\nassert coin_change([1, 2, 5], 100) == 20\nassert coin_change([186, 419, 83, 408], 6249) == 20", "metadata": {"language": "Python", "function_name": "coin_change", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-042", "query_text": "Write a Python function named `max_subarray` that finds the maximum sum subarray using Kadane's algorithm. Language: Python. Function name: max_subarray", "reference_answer": "def max_subarray(nums: list[int]) -> tuple[int, int, int]:\n    if not nums:\n        return 0, 0, 0\n    \n    max_sum = current_sum = nums[0]\n    start = end = temp_start = 0\n    \n    for i in range(1, len(nums)):\n        if current_sum + nums[i] > nums[i]:\n            current_sum += nums[i]\n        else:\n            current_sum = nums[i]\n            temp_start = i\n        \n        if current_sum > max_sum:\n            max_sum = current_sum\n            start = temp_start\n            end = i\n    \n    return max_sum, start, end", "assertions": "assert max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])[0] == 6\nassert max_subarray([1])[0] == 1\nassert max_subarray([-1, -2, -3])[0] == -1\nassert max_subarray([5, 4, -1, 7, 8])[0] == 23\nassert max_subarray([])[0] == 0", "metadata": {"language": "Python", "function_name": "max_subarray", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-043", "query_text": "Write a Python function named `union_find` that implements a disjoint set union data structure. Language: Python. Function name: union_find", "reference_answer": "class UnionFind:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.count = n\n    \n    def find(self, x: int) -> int:\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x: int, y: int) -> bool:\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        self.count -= 1\n        return True\n    \n    def connected(self, x: int, y: int) -> bool:\n        return self.find(x) == self.find(y)\n\ndef union_find(n: int) -> UnionFind:\n    return UnionFind(n)", "assertions": "uf = union_find(5)\nassert uf.connected(0, 1) == False\nuf.union(0, 1)\nassert uf.connected(0, 1) == True\nuf.union(2, 3)\nuf.union(1, 3)\nassert uf.connected(0, 2) == True\nassert uf.count == 2", "metadata": {"language": "Python", "function_name": "union_find", "difficulty": "advanced", "category": "data_structures", "complexity": 0.8}}
{"query_id": "synthetic-044", "query_text": "Write a Python function named `segment_tree` that implements a segment tree for range sum queries. Language: Python. Function name: segment_tree", "reference_answer": "class SegmentTree:\n    def __init__(self, arr: list[int]):\n        self.n = len(arr)\n        self.tree = [0] * (2 * self.n)\n        for i in range(self.n):\n            self.tree[self.n + i] = arr[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.tree[2*i] + self.tree[2*i + 1]\n    \n    def update(self, idx: int, val: int) -> None:\n        idx += self.n\n        self.tree[idx] = val\n        while idx > 1:\n            idx //= 2\n            self.tree[idx] = self.tree[2*idx] + self.tree[2*idx + 1]\n    \n    def query(self, left: int, right: int) -> int:\n        result = 0\n        left += self.n\n        right += self.n\n        while left <= right:\n            if left % 2 == 1:\n                result += self.tree[left]\n                left += 1\n            if right % 2 == 0:\n                result += self.tree[right]\n                right -= 1\n            left //= 2\n            right //= 2\n        return result\n\ndef segment_tree(arr: list[int]) -> SegmentTree:\n    return SegmentTree(arr)", "assertions": "st = segment_tree([1, 3, 5, 7, 9, 11])\nassert st.query(0, 2) == 9\nassert st.query(1, 4) == 24\nst.update(2, 10)\nassert st.query(0, 2) == 14\nassert st.query(0, 5) == 41", "metadata": {"language": "Python", "function_name": "segment_tree", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.92}}
{"query_id": "synthetic-045", "query_text": "Write a Python function named `rabin_karp` that implements the Rabin-Karp string matching algorithm. Language: Python. Function name: rabin_karp", "reference_answer": "def rabin_karp(text: str, pattern: str) -> list[int]:\n    if not pattern or not text or len(pattern) > len(text):\n        return []\n    \n    base = 256\n    mod = 10**9 + 7\n    m, n = len(pattern), len(text)\n    \n    pattern_hash = 0\n    text_hash = 0\n    h = pow(base, m - 1, mod)\n    \n    for i in range(m):\n        pattern_hash = (base * pattern_hash + ord(pattern[i])) % mod\n        text_hash = (base * text_hash + ord(text[i])) % mod\n    \n    result = []\n    for i in range(n - m + 1):\n        if pattern_hash == text_hash:\n            if text[i:i+m] == pattern:\n                result.append(i)\n        if i < n - m:\n            text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % mod\n            if text_hash < 0:\n                text_hash += mod\n    \n    return result", "assertions": "assert rabin_karp('ABABDABACDABABCABAB', 'ABABCABAB') == [10]\nassert rabin_karp('AAAAAA', 'AAA') == [0, 1, 2, 3]\nassert rabin_karp('ABC', 'D') == []\nassert rabin_karp('hello world', 'o') == [4, 7]\nassert rabin_karp('', 'a') == []", "metadata": {"language": "Python", "function_name": "rabin_karp", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-046", "query_text": "Write a Python function named `treap` that implements a treap with random priorities. Language: Python. Function name: treap", "reference_answer": "import random\n\nclass TreapNode:\n    def __init__(self, key: int):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n    \n    def _rotate_right(self, node: TreapNode) -> TreapNode:\n        left = node.left\n        node.left = left.right\n        left.right = node\n        return left\n    \n    def _rotate_left(self, node: TreapNode) -> TreapNode:\n        right = node.right\n        node.right = right.left\n        right.left = node\n        return right\n    \n    def _insert(self, node: TreapNode | None, key: int) -> TreapNode:\n        if not node:\n            return TreapNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n            if node.left.priority > node.priority:\n                node = self._rotate_right(node)\n        else:\n            node.right = self._insert(node.right, key)\n            if node.right.priority > node.priority:\n                node = self._rotate_left(node)\n        return node\n    \n    def insert(self, key: int) -> None:\n        self.root = self._insert(self.root, key)\n    \n    def search(self, key: int) -> bool:\n        node = self.root\n        while node:\n            if key == node.key:\n                return True\n            node = node.left if key < node.key else node.right\n        return False\n\ndef treap() -> Treap:\n    return Treap()", "assertions": "t = treap()\nt.insert(5)\nt.insert(3)\nt.insert(7)\nt.insert(1)\nassert t.search(5) == True\nassert t.search(3) == True\nassert t.search(10) == False\nassert t.search(1) == True", "metadata": {"language": "Python", "function_name": "treap", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.9}}
{"query_id": "synthetic-047", "query_text": "Write a Python function named `longest_common_prefix` that finds the longest common prefix among strings. Language: Python. Function name: longest_common_prefix", "reference_answer": "def longest_common_prefix(strs: list[str]) -> str:\n    if not strs:\n        return ''\n    \n    prefix = strs[0]\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix", "assertions": "assert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['a']) == 'a'", "metadata": {"language": "Python", "function_name": "longest_common_prefix", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-048", "query_text": "Write a Python function named `rotate_matrix` that rotates a matrix 90 degrees clockwise in-place. Language: Python. Function name: rotate_matrix", "reference_answer": "def rotate_matrix(matrix: list[list[int]]) -> None:\n    n = len(matrix)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    \n    for row in matrix:\n        row.reverse()", "assertions": "m1 = [[1,2,3],[4,5,6],[7,8,9]]\nrotate_matrix(m1)\nassert m1 == [[7,4,1],[8,5,2],[9,6,3]]\nm2 = [[1,2],[3,4]]\nrotate_matrix(m2)\nassert m2 == [[3,1],[4,2]]\nm3 = [[1]]\nrotate_matrix(m3)\nassert m3 == [[1]]", "metadata": {"language": "Python", "function_name": "rotate_matrix", "difficulty": "medium", "category": "algorithms", "complexity": 0.55}}
{"query_id": "synthetic-049", "query_text": "Write a TypeScript function named `binarySearchInsert` that finds the insert position in a sorted array. Language: TypeScript. Function name: binarySearchInsert", "reference_answer": "function binarySearchInsert(nums: number[], target: number): number {\n    let left = 0;\n    let right = nums.length;\n    \n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}", "assertions": "if (binarySearchInsert([1, 3, 5, 6], 5) !== 2) throw new Error('Failed');\nif (binarySearchInsert([1, 3, 5, 6], 2) !== 1) throw new Error('Failed');\nif (binarySearchInsert([1, 3, 5, 6], 7) !== 4) throw new Error('Failed');\nif (binarySearchInsert([1, 3, 5, 6], 0) !== 0) throw new Error('Failed');\nif (binarySearchInsert([], 5) !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "binarySearchInsert", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-050", "query_text": "Write a TypeScript function named `shuffle` that shuffles an array using Fisher-Yates algorithm. Language: TypeScript. Function name: shuffle", "reference_answer": "function shuffle<T>(array: T[]): T[] {\n    const result = [...array];\n    for (let i = result.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [result[i], result[j]] = [result[j], result[i]];\n    }\n    return result;\n}", "assertions": "const original = [1, 2, 3, 4, 5];\nconst shuffled = shuffle(original);\nif (shuffled.length !== 5) throw new Error('Failed');\nif (shuffled.sort((a, b) => a - b).join(',') !== '1,2,3,4,5') throw new Error('Failed');\nif (JSON.stringify(original) !== JSON.stringify([1, 2, 3, 4, 5])) throw new Error('Failed - original modified');\nif (shuffle([]).length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "shuffle", "difficulty": "medium", "category": "algorithms", "complexity": 0.45}}
{"query_id": "synthetic-051", "query_text": "Write a TypeScript function named `zip` that zips multiple arrays together. Language: TypeScript. Function name: zip", "reference_answer": "function zip<T>(...arrays: T[][]): T[][] {\n    if (arrays.length === 0) return [];\n    const minLength = Math.min(...arrays.map(arr => arr.length));\n    const result: T[][] = [];\n    \n    for (let i = 0; i < minLength; i++) {\n        result.push(arrays.map(arr => arr[i]));\n    }\n    return result;\n}", "assertions": "const result1 = zip([1, 2, 3], ['a', 'b', 'c']);\nif (JSON.stringify(result1) !== JSON.stringify([[1, 'a'], [2, 'b'], [3, 'c']])) throw new Error('Failed');\nconst result2 = zip([1, 2], [3, 4], [5, 6]);\nif (JSON.stringify(result2) !== JSON.stringify([[1, 3, 5], [2, 4, 6]])) throw new Error('Failed');\nconst result3 = zip([1, 2, 3], [4, 5]);\nif (result3.length !== 2) throw new Error('Failed');\nif (zip().length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "zip", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-052", "query_text": "Write a TypeScript function named `chunk` that splits an array into chunks of specified size. Language: TypeScript. Function name: chunk", "reference_answer": "function chunk<T>(array: T[], size: number): T[][] {\n    if (size <= 0) throw new Error('Size must be positive');\n    const result: T[][] = [];\n    for (let i = 0; i < array.length; i += size) {\n        result.push(array.slice(i, i + size));\n    }\n    return result;\n}", "assertions": "const result1 = chunk([1, 2, 3, 4, 5], 2);\nif (JSON.stringify(result1) !== JSON.stringify([[1, 2], [3, 4], [5]])) throw new Error('Failed');\nconst result2 = chunk([1, 2, 3, 4], 4);\nif (JSON.stringify(result2) !== JSON.stringify([[1, 2, 3, 4]])) throw new Error('Failed');\nconst result3 = chunk([], 3);\nif (result3.length !== 0) throw new Error('Failed');\nconst result4 = chunk([1, 2, 3], 1);\nif (JSON.stringify(result4) !== JSON.stringify([[1], [2], [3]])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "chunk", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-053", "query_text": "Write a TypeScript function named `intersection` that finds the intersection of multiple arrays. Language: TypeScript. Function name: intersection", "reference_answer": "function intersection<T>(...arrays: T[][]): T[] {\n    if (arrays.length === 0) return [];\n    if (arrays.length === 1) return [...new Set(arrays[0])];\n    \n    const first = new Set(arrays[0]);\n    return arrays.slice(1).reduce((result, arr) => {\n        const arrSet = new Set(arr);\n        return result.filter(item => arrSet.has(item));\n    }, [...first]);\n}", "assertions": "const result1 = intersection([1, 2, 3], [2, 3, 4], [3, 4, 5]);\nif (JSON.stringify(result1) !== JSON.stringify([3])) throw new Error('Failed');\nconst result2 = intersection([1, 2], [3, 4]);\nif (result2.length !== 0) throw new Error('Failed');\nconst result3 = intersection([1, 1, 2], [1, 2, 2]);\nif (JSON.stringify(result3.sort()) !== JSON.stringify([1, 2])) throw new Error('Failed');\nif (intersection().length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "intersection", "difficulty": "medium", "category": "data_structures", "complexity": 0.55}}
{"query_id": "synthetic-054", "query_text": "Write a TypeScript function named `BinaryHeap` that implements a min-heap. Language: TypeScript. Function name: BinaryHeap", "reference_answer": "class BinaryHeap<T> {\n    private heap: T[] = [];\n    private compareFn: (a: T, b: T) => number;\n    \n    constructor(compareFn: (a: T, b: T) => number = (a, b) => (a as any) - (b as any)) {\n        this.compareFn = compareFn;\n    }\n    \n    push(value: T): void {\n        this.heap.push(value);\n        this.bubbleUp(this.heap.length - 1);\n    }\n    \n    pop(): T | undefined {\n        if (this.heap.length === 0) return undefined;\n        const result = this.heap[0];\n        const last = this.heap.pop()!;\n        if (this.heap.length > 0) {\n            this.heap[0] = last;\n            this.bubbleDown(0);\n        }\n        return result;\n    }\n    \n    peek(): T | undefined {\n        return this.heap[0];\n    }\n    \n    get size(): number {\n        return this.heap.length;\n    }\n    \n    private bubbleUp(index: number): void {\n        while (index > 0) {\n            const parent = Math.floor((index - 1) / 2);\n            if (this.compareFn(this.heap[index], this.heap[parent]) >= 0) break;\n            [this.heap[index], this.heap[parent]] = [this.heap[parent], this.heap[index]];\n            index = parent;\n        }\n    }\n    \n    private bubbleDown(index: number): void {\n        while (true) {\n            let smallest = index;\n            const left = 2 * index + 1;\n            const right = 2 * index + 2;\n            if (left < this.heap.length && this.compareFn(this.heap[left], this.heap[smallest]) < 0) smallest = left;\n            if (right < this.heap.length && this.compareFn(this.heap[right], this.heap[smallest]) < 0) smallest = right;\n            if (smallest === index) break;\n            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n            index = smallest;\n        }\n    }\n}", "assertions": "const heap = new BinaryHeap<number>();\nheap.push(5);\nheap.push(3);\nheap.push(7);\nheap.push(1);\nif (heap.peek() !== 1) throw new Error('Failed');\nif (heap.pop() !== 1) throw new Error('Failed');\nif (heap.pop() !== 3) throw new Error('Failed');\nif (heap.size !== 2) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "BinaryHeap", "difficulty": "advanced", "category": "data_structures", "complexity": 0.8}}
{"query_id": "synthetic-055", "query_text": "Write a TypeScript function named `topologicalSort` that performs topological sort on a directed acyclic graph. Language: TypeScript. Function name: topologicalSort", "reference_answer": "function topologicalSort(graph: Map<number, number[]>): number[] {\n    const visited = new Set<number>();\n    const result: number[] = [];\n    \n    function dfs(node: number): void {\n        if (visited.has(node)) return;\n        visited.add(node);\n        for (const neighbor of graph.get(node) || []) {\n            dfs(neighbor);\n        }\n        result.push(node);\n    }\n    \n    for (const node of graph.keys()) {\n        dfs(node);\n    }\n    \n    return result.reverse();\n}", "assertions": "const graph = new Map<number, number[]>();\ngraph.set(0, [1, 2]);\ngraph.set(1, [3]);\ngraph.set(2, [3]);\ngraph.set(3, []);\nconst result = topologicalSort(graph);\nif (result.indexOf(0) > result.indexOf(1)) throw new Error('Failed');\nif (result.indexOf(0) > result.indexOf(2)) throw new Error('Failed');\nif (result.indexOf(1) > result.indexOf(3)) throw new Error('Failed');\nif (result.indexOf(2) > result.indexOf(3)) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "topologicalSort", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-056", "query_text": "Write a TypeScript function named `levenshteinDistance` that calculates edit distance between two strings. Language: TypeScript. Function name: levenshteinDistance", "reference_answer": "function levenshteinDistance(s1: string, s2: string): number {\n    const m = s1.length;\n    const n = s2.length;\n    const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) dp[i][0] = i;\n    for (let j = 0; j <= n; j++) dp[0][j] = j;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s1[i - 1] === s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}", "assertions": "if (levenshteinDistance('kitten', 'sitting') !== 3) throw new Error('Failed');\nif (levenshteinDistance('', '') !== 0) throw new Error('Failed');\nif (levenshteinDistance('abc', '') !== 3) throw new Error('Failed');\nif (levenshteinDistance('same', 'same') !== 0) throw new Error('Failed');\nif (levenshteinDistance('a', 'b') !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "levenshteinDistance", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-057", "query_text": "Write a Go function named `QuickSort` that implements quicksort. Language: Go. Function name: QuickSort", "reference_answer": "package main\n\nfunc QuickSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\tresult := make([]int, len(arr))\n\tcopy(result, arr)\n\tquickSortHelper(result, 0, len(result)-1)\n\treturn result\n}\n\nfunc quickSortHelper(arr []int, low, high int) {\n\tif low < high {\n\t\tpivot := partition(arr, low, high)\n\t\tquickSortHelper(arr, low, pivot-1)\n\t\tquickSortHelper(arr, pivot+1, high)\n\t}\n}\n\nfunc partition(arr []int, low, high int) int {\n\tpivot := arr[high]\n\ti := low - 1\n\tfor j := low; j < high; j++ {\n\t\tif arr[j] <= pivot {\n\t\t\ti++\n\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\t\t}\n\t}\n\tarr[i+1], arr[high] = arr[high], arr[i+1]\n\treturn i + 1\n}", "assertions": "import \"reflect\"\nif !reflect.DeepEqual(QuickSort([]int{5, 3, 8, 4, 2}), []int{2, 3, 4, 5, 8}) { panic(\"Failed\") }\nif !reflect.DeepEqual(QuickSort([]int{}), []int{}) { panic(\"Failed\") }\nif !reflect.DeepEqual(QuickSort([]int{1}), []int{1}) { panic(\"Failed\") }\nif !reflect.DeepEqual(QuickSort([]int{5, 4, 3, 2, 1}), []int{1, 2, 3, 4, 5}) { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "QuickSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.72}}
{"query_id": "synthetic-058", "query_text": "Write a Rust function named `quicksort` that implements quicksort. Language: Rust. Function name: quicksort", "reference_answer": "pub fn quicksort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {\n    if arr.len() <= 1 {\n        return arr.to_vec();\n    }\n    \n    let pivot = arr[arr.len() / 2].clone();\n    let less: Vec<T> = arr.iter().filter(|x| **x < pivot).cloned().collect();\n    let equal: Vec<T> = arr.iter().filter(|x| **x == pivot).cloned().collect();\n    let greater: Vec<T> = arr.iter().filter(|x| **x > pivot).cloned().collect();\n    \n    let mut result = quicksort(&less);\n    result.extend(equal);\n    result.extend(quicksort(&greater));\n    result\n}", "assertions": "assert_eq!(quicksort(&[5, 3, 8, 4, 2]), vec![2, 3, 4, 5, 8]);\nassert_eq!(quicksort::<i32>(&[]), Vec::<i32>::new());\nassert_eq!(quicksort(&[1]), vec![1]);\nassert_eq!(quicksort(&[5, 4, 3, 2, 1]), vec![1, 2, 3, 4, 5]);\nassert_eq!(quicksort(&[1, 1, 1]), vec![1, 1, 1]);", "metadata": {"language": "Rust", "function_name": "quicksort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.72}}
{"query_id": "synthetic-059", "query_text": "Write a C# function named `MergeSort` that implements merge sort. Language: C#. Function name: MergeSort", "reference_answer": "using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public static T[] MergeSort<T>(T[] arr) where T : IComparable<T> {\n        if (arr.Length <= 1) return arr;\n        \n        int mid = arr.Length / 2;\n        T[] left = MergeSort(arr[..mid]);\n        T[] right = MergeSort(arr[mid..]);\n        \n        return Merge(left, right);\n    }\n    \n    private static T[] Merge<T>(T[] left, T[] right) where T : IComparable<T> {\n        var result = new List<T>();\n        int i = 0, j = 0;\n        \n        while (i < left.Length && j < right.Length) {\n            if (left[i].CompareTo(right[j]) <= 0) {\n                result.Add(left[i++]);\n            } else {\n                result.Add(right[j++]);\n            }\n        }\n        \n        while (i < left.Length) result.Add(left[i++]);\n        while (j < right.Length) result.Add(right[j++]);\n        \n        return result.ToArray();\n    }\n}", "assertions": "var result1 = Solution.MergeSort(new[] {5, 3, 8, 4, 2});\nif (!result1.SequenceEqual(new[] {2, 3, 4, 5, 8})) throw new Exception(\"Failed\");\nvar result2 = Solution.MergeSort(Array.Empty<int>());\nif (result2.Length != 0) throw new Exception(\"Failed\");\nvar result3 = Solution.MergeSort(new[] {1});\nif (!result3.SequenceEqual(new[] {1})) throw new Exception(\"Failed\");", "metadata": {"language": "C#", "function_name": "MergeSort", "difficulty": "advanced", "category": "algorithms", "complexity": 0.7}}
{"query_id": "synthetic-060", "query_text": "Write a PHP function named `binarySearch` that performs binary search on a sorted array. Language: PHP. Function name: binarySearch", "reference_answer": "<?php\nfunction binarySearch(array $arr, $target): int {\n    $left = 0;\n    $right = count($arr) - 1;\n    \n    while ($left <= $right) {\n        $mid = intdiv($left + $right, 2);\n        if ($arr[$mid] === $target) {\n            return $mid;\n        } elseif ($arr[$mid] < $target) {\n            $left = $mid + 1;\n        } else {\n            $right = $mid - 1;\n        }\n    }\n    return -1;\n}\n?>", "assertions": "<?php\nif (binarySearch([1, 2, 3, 4, 5], 3) !== 2) throw new Exception('Failed');\nif (binarySearch([1, 2, 3, 4, 5], 1) !== 0) throw new Exception('Failed');\nif (binarySearch([1, 2, 3, 4, 5], 5) !== 4) throw new Exception('Failed');\nif (binarySearch([1, 2, 3, 4, 5], 6) !== -1) throw new Exception('Failed');\nif (binarySearch([], 1) !== -1) throw new Exception('Failed');\n?>", "metadata": {"language": "PHP", "function_name": "binarySearch", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-061", "query_text": "Write a Python function named `astar` that implements the A* pathfinding algorithm. Language: Python. Function name: astar", "reference_answer": "import heapq\nfrom typing import Callable\n\ndef astar(\n    start: tuple[int, int],\n    goal: tuple[int, int],\n    grid: list[list[int]],\n    heuristic: Callable[[tuple[int, int], tuple[int, int]], float] = None\n) -> list[tuple[int, int]] | None:\n    if heuristic is None:\n        heuristic = lambda a, b: abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    rows, cols = len(grid), len(grid[0])\n    open_set = [(0, start)]\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, goal)}\n    \n    while open_set:\n        _, current = heapq.heappop(open_set)\n        \n        if current == goal:\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1]\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = current[0] + dx, current[1] + dy\n            neighbor = (nx, ny)\n            \n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0:\n                tentative_g = g_score[current] + 1\n                \n                if tentative_g < g_score.get(neighbor, float('inf')):\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g\n                    f_score[neighbor] = tentative_g + heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n    \n    return None", "assertions": "grid = [[0,0,0],[0,1,0],[0,0,0]]\npath = astar((0,0), (2,2), grid)\nassert path is not None\nassert path[0] == (0,0)\nassert path[-1] == (2,2)\nassert len(path) == 5\nassert astar((0,0), (1,1), [[0,0],[1,0]]) is None", "metadata": {"language": "Python", "function_name": "astar", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.92}}
{"query_id": "synthetic-062", "query_text": "Write a Python function named `huffman_encoding` that implements Huffman encoding. Language: Python. Function name: huffman_encoding", "reference_answer": "import heapq\nfrom collections import Counter\n\nclass HuffmanNode:\n    def __init__(self, char, freq):\n        self.char = char\n        self.freq = freq\n        self.left = None\n        self.right = None\n    \n    def __lt__(self, other):\n        return self.freq < other.freq\n\ndef huffman_encoding(text: str) -> tuple[dict[str, str], str]:\n    if not text:\n        return {}, ''\n    \n    freq = Counter(text)\n    heap = [HuffmanNode(char, f) for char, f in freq.items()]\n    heapq.heapify(heap)\n    \n    while len(heap) > 1:\n        left = heapq.heappop(heap)\n        right = heapq.heappop(heap)\n        merged = HuffmanNode(None, left.freq + right.freq)\n        merged.left = left\n        merged.right = right\n        heapq.heappush(heap, merged)\n    \n    codes = {}\n    def build_codes(node, code=''):\n        if node.char is not None:\n            codes[node.char] = code if code else '0'\n            return\n        build_codes(node.left, code + '0')\n        build_codes(node.right, code + '1')\n    \n    if heap:\n        build_codes(heap[0])\n    \n    encoded = ''.join(codes[c] for c in text)\n    return codes, encoded", "assertions": "codes, encoded = huffman_encoding('aab')\nassert 'a' in codes and 'b' in codes\nassert len(codes['a']) <= 1\ncodes2, encoded2 = huffman_encoding('')\nassert codes2 == {} and encoded2 == ''\ncodes3, encoded3 = huffman_encoding('aaaa')\nassert codes3 == {'a': '0'} and encoded3 == '0000'", "metadata": {"language": "Python", "function_name": "huffman_encoding", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-063", "query_text": "Write a Python function named `spiral_order` that returns elements of a matrix in spiral order. Language: Python. Function name: spiral_order", "reference_answer": "def spiral_order(matrix: list[list[int]]) -> list[int]:\n    if not matrix or not matrix[0]:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result", "assertions": "assert spiral_order([[1,2,3],[4,5,6],[7,8,9]]) == [1,2,3,6,9,8,7,4,5]\nassert spiral_order([[1,2,3,4],[5,6,7,8],[9,10,11,12]]) == [1,2,3,4,8,12,11,10,9,5,6,7]\nassert spiral_order([[1]]) == [1]\nassert spiral_order([]) == []\nassert spiral_order([[1,2],[3,4]]) == [1,2,4,3]", "metadata": {"language": "Python", "function_name": "spiral_order", "difficulty": "medium", "category": "algorithms", "complexity": 0.6}}
{"query_id": "synthetic-064", "query_text": "Write a Python function named `word_break` that determines if a string can be segmented into dictionary words. Language: Python. Function name: word_break", "reference_answer": "def word_break(s: str, word_dict: list[str]) -> bool:\n    word_set = set(word_dict)\n    n = len(s)\n    dp = [False] * (n + 1)\n    dp[0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    \n    return dp[n]", "assertions": "assert word_break('leetcode', ['leet', 'code']) == True\nassert word_break('applepenapple', ['apple', 'pen']) == True\nassert word_break('catsandog', ['cats', 'dog', 'sand', 'and', 'cat']) == False\nassert word_break('', ['a']) == True\nassert word_break('a', []) == False", "metadata": {"language": "Python", "function_name": "word_break", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
{"query_id": "synthetic-065", "query_text": "Write a Python function named `sliding_window_max` that finds the maximum in each sliding window. Language: Python. Function name: sliding_window_max", "reference_answer": "from collections import deque\n\ndef sliding_window_max(nums: list[int], k: int) -> list[int]:\n    if not nums or k == 0:\n        return []\n    \n    result = []\n    dq = deque()\n    \n    for i, num in enumerate(nums):\n        while dq and nums[dq[-1]] < num:\n            dq.pop()\n        dq.append(i)\n        \n        if dq[0] <= i - k:\n            dq.popleft()\n        \n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result", "assertions": "assert sliding_window_max([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7]\nassert sliding_window_max([1], 1) == [1]\nassert sliding_window_max([1,-1], 1) == [1,-1]\nassert sliding_window_max([9,11], 2) == [11]\nassert sliding_window_max([], 3) == []", "metadata": {"language": "Python", "function_name": "sliding_window_max", "difficulty": "advanced", "category": "algorithms", "complexity": 0.78}}
{"query_id": "synthetic-066", "query_text": "Write a Python function named `n_queens` that solves the N-Queens puzzle. Language: Python. Function name: n_queens", "reference_answer": "def n_queens(n: int) -> list[list[str]]:\n    def is_safe(board: list[int], row: int, col: int) -> bool:\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == abs(i - row):\n                return False\n        return True\n    \n    def solve(row: int, board: list[int]) -> None:\n        if row == n:\n            solution = []\n            for r in range(n):\n                line = ['.'] * n\n                line[board[r]] = 'Q'\n                solution.append(''.join(line))\n            results.append(solution)\n            return\n        \n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row] = col\n                solve(row + 1, board)\n    \n    results = []\n    solve(0, [-1] * n)\n    return results", "assertions": "assert len(n_queens(4)) == 2\nassert len(n_queens(1)) == 1\nassert len(n_queens(8)) == 92\nassert n_queens(2) == []\nassert n_queens(3) == []", "metadata": {"language": "Python", "function_name": "n_queens", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-067", "query_text": "Write a Python function named `sudoku_solver` that solves a Sudoku puzzle. Language: Python. Function name: sudoku_solver", "reference_answer": "def sudoku_solver(board: list[list[str]]) -> bool:\n    def is_valid(row: int, col: int, num: str) -> bool:\n        for i in range(9):\n            if board[row][i] == num:\n                return False\n            if board[i][col] == num:\n                return False\n        \n        box_row, box_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[box_row + i][box_col + j] == num:\n                    return False\n        return True\n    \n    def solve() -> bool:\n        for row in range(9):\n            for col in range(9):\n                if board[row][col] == '.':\n                    for num in '123456789':\n                        if is_valid(row, col, num):\n                            board[row][col] = num\n                            if solve():\n                                return True\n                            board[row][col] = '.'\n                    return False\n        return True\n    \n    return solve()", "assertions": "board = [['5','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],['.','9','8','.','.','.','.','6','.'],['8','.','.','.','6','.','.','.','3'],['4','.','.','8','.','3','.','.','1'],['7','.','.','.','2','.','.','.','6'],['.','6','.','.','.','.','2','8','.'],['.','.','.','4','1','9','.','.','5'],['.','.','.','.','8','.','.','7','9']]\nassert sudoku_solver(board) == True\nassert board[0][2] == '4'\nassert board[2][0] == '1'", "metadata": {"language": "Python", "function_name": "sudoku_solver", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-068", "query_text": "Write a Python function named `max_profit_k_transactions` that finds maximum profit with at most k transactions. Language: Python. Function name: max_profit_k_transactions", "reference_answer": "def max_profit_k_transactions(prices: list[int], k: int) -> int:\n    if not prices or k == 0:\n        return 0\n    \n    n = len(prices)\n    if k >= n // 2:\n        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))\n    \n    dp = [[0] * n for _ in range(k + 1)]\n    \n    for t in range(1, k + 1):\n        max_diff = -prices[0]\n        for d in range(1, n):\n            dp[t][d] = max(dp[t][d-1], prices[d] + max_diff)\n            max_diff = max(max_diff, dp[t-1][d] - prices[d])\n    \n    return dp[k][n-1]", "assertions": "assert max_profit_k_transactions([2,4,1], 2) == 2\nassert max_profit_k_transactions([3,2,6,5,0,3], 2) == 7\nassert max_profit_k_transactions([3,3,5,0,0,3,1,4], 2) == 6\nassert max_profit_k_transactions([], 1) == 0\nassert max_profit_k_transactions([1,2,3,4,5], 2) == 4", "metadata": {"language": "Python", "function_name": "max_profit_k_transactions", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-069", "query_text": "Write a TypeScript function named `partition` that partitions an array based on a predicate. Language: TypeScript. Function name: partition", "reference_answer": "function partition<T>(arr: T[], predicate: (item: T) => boolean): [T[], T[]] {\n    const pass: T[] = [];\n    const fail: T[] = [];\n    \n    for (const item of arr) {\n        if (predicate(item)) {\n            pass.push(item);\n        } else {\n            fail.push(item);\n        }\n    }\n    \n    return [pass, fail];\n}", "assertions": "const [even, odd] = partition([1, 2, 3, 4, 5, 6], n => n % 2 === 0);\nif (JSON.stringify(even) !== JSON.stringify([2, 4, 6])) throw new Error('Failed');\nif (JSON.stringify(odd) !== JSON.stringify([1, 3, 5])) throw new Error('Failed');\nconst [empty1, empty2] = partition([], n => true);\nif (empty1.length !== 0 || empty2.length !== 0) throw new Error('Failed');\nconst [all, none] = partition([1, 2, 3], () => true);\nif (all.length !== 3 || none.length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "partition", "difficulty": "medium", "category": "data_structures", "complexity": 0.4}}
{"query_id": "synthetic-070", "query_text": "Write a TypeScript function named `compose` that composes functions from right to left. Language: TypeScript. Function name: compose", "reference_answer": "function compose<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {\n    return (arg: T) => fns.reduceRight((result, fn) => fn(result), arg);\n}", "assertions": "const addOne = (x: number) => x + 1;\nconst double = (x: number) => x * 2;\nconst square = (x: number) => x * x;\nconst composed = compose(addOne, double, square);\nif (composed(2) !== 9) throw new Error('Failed: 2^2=4, 4*2=8, 8+1=9');\nif (composed(3) !== 19) throw new Error('Failed: 3^2=9, 9*2=18, 18+1=19');\nconst identity = compose<number>();\nif (identity(5) !== 5) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "compose", "difficulty": "medium", "category": "design_patterns", "complexity": 0.5}}
{"query_id": "synthetic-071", "query_text": "Write a TypeScript function named `uniqBy` that returns unique elements by a key function. Language: TypeScript. Function name: uniqBy", "reference_answer": "function uniqBy<T, K>(arr: T[], keyFn: (item: T) => K): T[] {\n    const seen = new Set<K>();\n    return arr.filter(item => {\n        const key = keyFn(item);\n        if (seen.has(key)) return false;\n        seen.add(key);\n        return true;\n    });\n}", "assertions": "const result1 = uniqBy([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 1, name: 'c' }], x => x.id);\nif (result1.length !== 2) throw new Error('Failed');\nif (result1[0].name !== 'a' || result1[1].name !== 'b') throw new Error('Failed');\nconst result2 = uniqBy([1.1, 1.9, 2.1, 2.9], Math.floor);\nif (JSON.stringify(result2) !== JSON.stringify([1.1, 2.1])) throw new Error('Failed');\nif (uniqBy([], x => x).length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "uniqBy", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-072", "query_text": "Write a TypeScript function named `range` that generates a range of numbers. Language: TypeScript. Function name: range", "reference_answer": "function range(start: number, end?: number, step: number = 1): number[] {\n    if (end === undefined) {\n        end = start;\n        start = 0;\n    }\n    \n    if (step === 0) throw new Error('Step cannot be zero');\n    \n    const result: number[] = [];\n    if (step > 0) {\n        for (let i = start; i < end; i += step) {\n            result.push(i);\n        }\n    } else {\n        for (let i = start; i > end; i += step) {\n            result.push(i);\n        }\n    }\n    return result;\n}", "assertions": "if (JSON.stringify(range(5)) !== JSON.stringify([0, 1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(range(1, 5)) !== JSON.stringify([1, 2, 3, 4])) throw new Error('Failed');\nif (JSON.stringify(range(0, 10, 2)) !== JSON.stringify([0, 2, 4, 6, 8])) throw new Error('Failed');\nif (JSON.stringify(range(5, 0, -1)) !== JSON.stringify([5, 4, 3, 2, 1])) throw new Error('Failed');\nif (range(0).length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "range", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-073", "query_text": "Write a TypeScript function named `pick` that picks specified keys from an object. Language: TypeScript. Function name: pick", "reference_answer": "function pick<T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n    const result = {} as Pick<T, K>;\n    for (const key of keys) {\n        if (key in obj) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}", "assertions": "const obj = { a: 1, b: 2, c: 3, d: 4 };\nconst result1 = pick(obj, ['a', 'c']);\nif (result1.a !== 1 || result1.c !== 3) throw new Error('Failed');\nif ('b' in result1 || 'd' in result1) throw new Error('Failed - should not include b or d');\nconst result2 = pick({ x: 10, y: 20 }, ['x']);\nif (Object.keys(result2).length !== 1) throw new Error('Failed');\nconst result3 = pick({}, []);\nif (Object.keys(result3).length !== 0) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "pick", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-074", "query_text": "Write a TypeScript function named `omit` that omits specified keys from an object. Language: TypeScript. Function name: omit", "reference_answer": "function omit<T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {\n    const result = { ...obj };\n    for (const key of keys) {\n        delete result[key];\n    }\n    return result as Omit<T, K>;\n}", "assertions": "const obj = { a: 1, b: 2, c: 3, d: 4 };\nconst result1 = omit(obj, ['a', 'c']);\nif ('a' in result1 || 'c' in result1) throw new Error('Failed');\nif ((result1 as any).b !== 2 || (result1 as any).d !== 4) throw new Error('Failed');\nconst result2 = omit({ x: 10, y: 20 }, ['x']);\nif ('x' in result2) throw new Error('Failed');\nconst result3 = omit({ a: 1 }, []);\nif ((result3 as any).a !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "omit", "difficulty": "medium", "category": "data_structures", "complexity": 0.45}}
{"query_id": "synthetic-075", "query_text": "Write a TypeScript function named `linkedList` that implements a doubly linked list. Language: TypeScript. Function name: linkedList", "reference_answer": "class ListNode<T> {\n    value: T;\n    prev: ListNode<T> | null = null;\n    next: ListNode<T> | null = null;\n    constructor(value: T) { this.value = value; }\n}\n\nclass DoublyLinkedList<T> {\n    private head: ListNode<T> | null = null;\n    private tail: ListNode<T> | null = null;\n    private _size: number = 0;\n    \n    get size(): number { return this._size; }\n    \n    pushFront(value: T): void {\n        const node = new ListNode(value);\n        if (!this.head) {\n            this.head = this.tail = node;\n        } else {\n            node.next = this.head;\n            this.head.prev = node;\n            this.head = node;\n        }\n        this._size++;\n    }\n    \n    pushBack(value: T): void {\n        const node = new ListNode(value);\n        if (!this.tail) {\n            this.head = this.tail = node;\n        } else {\n            node.prev = this.tail;\n            this.tail.next = node;\n            this.tail = node;\n        }\n        this._size++;\n    }\n    \n    popFront(): T | undefined {\n        if (!this.head) return undefined;\n        const value = this.head.value;\n        this.head = this.head.next;\n        if (this.head) this.head.prev = null;\n        else this.tail = null;\n        this._size--;\n        return value;\n    }\n    \n    popBack(): T | undefined {\n        if (!this.tail) return undefined;\n        const value = this.tail.value;\n        this.tail = this.tail.prev;\n        if (this.tail) this.tail.next = null;\n        else this.head = null;\n        this._size--;\n        return value;\n    }\n    \n    toArray(): T[] {\n        const result: T[] = [];\n        let node = this.head;\n        while (node) {\n            result.push(node.value);\n            node = node.next;\n        }\n        return result;\n    }\n}\n\nfunction linkedList<T>(): DoublyLinkedList<T> {\n    return new DoublyLinkedList<T>();\n}", "assertions": "const list = linkedList<number>();\nlist.pushBack(1);\nlist.pushBack(2);\nlist.pushFront(0);\nif (JSON.stringify(list.toArray()) !== JSON.stringify([0, 1, 2])) throw new Error('Failed');\nif (list.popFront() !== 0) throw new Error('Failed');\nif (list.popBack() !== 2) throw new Error('Failed');\nif (list.size !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "linkedList", "difficulty": "advanced", "category": "data_structures", "complexity": 0.75}}
{"query_id": "synthetic-076", "query_text": "Write a TypeScript function named `Graph` that implements an adjacency list graph with BFS and DFS. Language: TypeScript. Function name: Graph", "reference_answer": "class Graph<T> {\n    private adjacencyList: Map<T, T[]> = new Map();\n    \n    addVertex(vertex: T): void {\n        if (!this.adjacencyList.has(vertex)) {\n            this.adjacencyList.set(vertex, []);\n        }\n    }\n    \n    addEdge(v1: T, v2: T): void {\n        this.addVertex(v1);\n        this.addVertex(v2);\n        this.adjacencyList.get(v1)!.push(v2);\n        this.adjacencyList.get(v2)!.push(v1);\n    }\n    \n    bfs(start: T): T[] {\n        const visited = new Set<T>();\n        const result: T[] = [];\n        const queue: T[] = [start];\n        visited.add(start);\n        \n        while (queue.length > 0) {\n            const vertex = queue.shift()!;\n            result.push(vertex);\n            \n            for (const neighbor of this.adjacencyList.get(vertex) || []) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push(neighbor);\n                }\n            }\n        }\n        return result;\n    }\n    \n    dfs(start: T): T[] {\n        const visited = new Set<T>();\n        const result: T[] = [];\n        \n        const dfsHelper = (vertex: T) => {\n            visited.add(vertex);\n            result.push(vertex);\n            for (const neighbor of this.adjacencyList.get(vertex) || []) {\n                if (!visited.has(neighbor)) {\n                    dfsHelper(neighbor);\n                }\n            }\n        };\n        \n        dfsHelper(start);\n        return result;\n    }\n}", "assertions": "const graph = new Graph<number>();\ngraph.addEdge(1, 2);\ngraph.addEdge(1, 3);\ngraph.addEdge(2, 4);\ngraph.addEdge(3, 4);\nconst bfsResult = graph.bfs(1);\nif (bfsResult[0] !== 1) throw new Error('Failed');\nif (bfsResult.length !== 4) throw new Error('Failed');\nconst dfsResult = graph.dfs(1);\nif (dfsResult[0] !== 1) throw new Error('Failed');\nif (dfsResult.length !== 4) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "Graph", "difficulty": "advanced", "category": "data_structures", "complexity": 0.78}}
{"query_id": "synthetic-077", "query_text": "Write a Go function named `Dijkstra` that implements Dijkstra's algorithm. Language: Go. Function name: Dijkstra", "reference_answer": "package main\n\nimport (\n\t\"container/heap\"\n\t\"math\"\n)\n\ntype Edge struct {\n\tTo     int\n\tWeight int\n}\n\ntype Item struct {\n\tNode     int\n\tPriority int\n\tIndex    int\n}\n\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i].Priority < pq[j].Priority }\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].Index = i\n\tpq[j].Index = j\n}\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\titem := x.(*Item)\n\titem.Index = n\n\t*pq = append(*pq, item)\n}\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc Dijkstra(graph map[int][]Edge, start int) map[int]int {\n\tdist := make(map[int]int)\n\tfor node := range graph {\n\t\tdist[node] = math.MaxInt32\n\t}\n\tdist[start] = 0\n\n\tpq := &PriorityQueue{}\n\theap.Init(pq)\n\theap.Push(pq, &Item{Node: start, Priority: 0})\n\n\tfor pq.Len() > 0 {\n\t\titem := heap.Pop(pq).(*Item)\n\t\tif item.Priority > dist[item.Node] {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, edge := range graph[item.Node] {\n\t\t\tnewDist := dist[item.Node] + edge.Weight\n\t\t\tif newDist < dist[edge.To] {\n\t\t\t\tdist[edge.To] = newDist\n\t\t\t\theap.Push(pq, &Item{Node: edge.To, Priority: newDist})\n\t\t\t}\n\t\t}\n\t}\n\treturn dist\n}", "assertions": "graph := map[int][]Edge{\n\t0: {{1, 4}, {2, 1}},\n\t1: {{3, 1}},\n\t2: {{1, 2}, {3, 5}},\n\t3: {},\n}\ndist := Dijkstra(graph, 0)\nif dist[0] != 0 { panic(\"Failed\") }\nif dist[1] != 3 { panic(\"Failed\") }\nif dist[2] != 1 { panic(\"Failed\") }\nif dist[3] != 4 { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Dijkstra", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-078", "query_text": "Write a Go function named `Trie` that implements a trie data structure. Language: Go. Function name: Trie", "reference_answer": "package main\n\ntype TrieNode struct {\n\tchildren map[rune]*TrieNode\n\tisEnd    bool\n}\n\ntype Trie struct {\n\troot *TrieNode\n}\n\nfunc NewTrie() *Trie {\n\treturn &Trie{root: &TrieNode{children: make(map[rune]*TrieNode)}}\n}\n\nfunc (t *Trie) Insert(word string) {\n\tnode := t.root\n\tfor _, ch := range word {\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\tnode.children[ch] = &TrieNode{children: make(map[rune]*TrieNode)}\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\tnode.isEnd = true\n}\n\nfunc (t *Trie) Search(word string) bool {\n\tnode := t.findNode(word)\n\treturn node != nil && node.isEnd\n}\n\nfunc (t *Trie) StartsWith(prefix string) bool {\n\treturn t.findNode(prefix) != nil\n}\n\nfunc (t *Trie) findNode(prefix string) *TrieNode {\n\tnode := t.root\n\tfor _, ch := range prefix {\n\t\tif _, ok := node.children[ch]; !ok {\n\t\t\treturn nil\n\t\t}\n\t\tnode = node.children[ch]\n\t}\n\treturn node\n}", "assertions": "trie := NewTrie()\ntrie.Insert(\"apple\")\nif !trie.Search(\"apple\") { panic(\"Failed\") }\nif trie.Search(\"app\") { panic(\"Failed\") }\nif !trie.StartsWith(\"app\") { panic(\"Failed\") }\ntrie.Insert(\"app\")\nif !trie.Search(\"app\") { panic(\"Failed\") }\nif trie.StartsWith(\"b\") { panic(\"Failed\") }", "metadata": {"language": "Go", "function_name": "Trie", "difficulty": "advanced", "category": "data_structures", "complexity": 0.75}}
{"query_id": "synthetic-079", "query_text": "Write a Scala function named `foldLeft` that implements fold left operation. Language: Scala. Function name: foldLeft", "reference_answer": "object Solution {\n  def foldLeft[A, B](list: List[A], initial: B)(f: (B, A) => B): B = {\n    list match {\n      case Nil => initial\n      case head :: tail => foldLeft(tail, f(initial, head))(f)\n    }\n  }\n  \n  def sum(nums: List[Int]): Int = foldLeft(nums, 0)(_ + _)\n  \n  def reverse[A](list: List[A]): List[A] = foldLeft(list, List.empty[A])((acc, x) => x :: acc)\n}", "assertions": "if (Solution.sum(List(1, 2, 3, 4, 5)) != 15) throw new RuntimeException(\"Failed\")\nif (Solution.foldLeft(List(1, 2, 3), 0)(_ + _) != 6) throw new RuntimeException(\"Failed\")\nif (Solution.reverse(List(1, 2, 3)) != List(3, 2, 1)) throw new RuntimeException(\"Failed\")\nif (Solution.foldLeft(List.empty[Int], 10)(_ + _) != 10) throw new RuntimeException(\"Failed\")", "metadata": {"language": "Scala", "function_name": "foldLeft", "difficulty": "medium", "category": "design_patterns", "complexity": 0.55}}
{"query_id": "synthetic-080", "query_text": "Write a Haskell function named `quicksort` that implements quicksort. Language: Haskell. Function name: quicksort", "reference_answer": "quicksort :: Ord a => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) = quicksort smaller ++ [x] ++ quicksort larger\n  where\n    smaller = [a | a <- xs, a <= x]\n    larger = [a | a <- xs, a > x]", "assertions": "-- quicksort [5, 3, 8, 4, 2] == [2, 3, 4, 5, 8]\n-- quicksort [] == []\n-- quicksort [1] == [1]\n-- quicksort [5, 4, 3, 2, 1] == [1, 2, 3, 4, 5]\n-- quicksort [1, 1, 1] == [1, 1, 1]", "metadata": {"language": "Haskell", "function_name": "quicksort", "difficulty": "medium", "category": "algorithms", "complexity": 0.5}}
{"query_id": "synthetic-081", "query_text": "Write a Python function named `trie_autocomplete` that implements autocomplete using a trie. Language: Python. Function name: trie_autocomplete", "reference_answer": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        self.word = None\n\nclass AutocompleteTrie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n        node.word = word\n    \n    def autocomplete(self, prefix: str, limit: int = 10) -> list[str]:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return []\n            node = node.children[char]\n        \n        results = []\n        self._collect_words(node, results, limit)\n        return results\n    \n    def _collect_words(self, node: TrieNode, results: list[str], limit: int) -> None:\n        if len(results) >= limit:\n            return\n        if node.is_word:\n            results.append(node.word)\n        for child in sorted(node.children.values(), key=lambda n: list(n.children.keys()) if n.children else []):\n            self._collect_words(child, results, limit)\n\ndef trie_autocomplete() -> AutocompleteTrie:\n    return AutocompleteTrie()", "assertions": "trie = trie_autocomplete()\nfor word in ['apple', 'application', 'apply', 'banana', 'band']:\n    trie.insert(word)\nresults = trie.autocomplete('app')\nassert 'apple' in results\nassert 'application' in results\nassert 'apply' in results\nassert len(trie.autocomplete('ban')) == 2\nassert trie.autocomplete('xyz') == []", "metadata": {"language": "Python", "function_name": "trie_autocomplete", "difficulty": "advanced", "category": "data_structures", "complexity": 0.8}}
{"query_id": "synthetic-082", "query_text": "Write a Python function named `interval_scheduling` that solves the weighted interval scheduling problem. Language: Python. Function name: interval_scheduling", "reference_answer": "from bisect import bisect_right\n\ndef interval_scheduling(intervals: list[tuple[int, int, int]]) -> int:\n    if not intervals:\n        return 0\n    \n    sorted_intervals = sorted(intervals, key=lambda x: x[1])\n    n = len(sorted_intervals)\n    \n    end_times = [i[1] for i in sorted_intervals]\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        start, end, weight = sorted_intervals[i - 1]\n        \n        j = bisect_right(end_times, start, 0, i - 1)\n        \n        dp[i] = max(dp[i - 1], dp[j] + weight)\n    \n    return dp[n]", "assertions": "assert interval_scheduling([(1, 3, 5), (2, 5, 6), (4, 6, 5), (6, 7, 4), (5, 8, 11), (7, 9, 2)]) == 17\nassert interval_scheduling([]) == 0\nassert interval_scheduling([(1, 2, 10)]) == 10\nassert interval_scheduling([(1, 3, 5), (1, 3, 10)]) == 10\nassert interval_scheduling([(1, 2, 5), (3, 4, 6), (5, 6, 7)]) == 18", "metadata": {"language": "Python", "function_name": "interval_scheduling", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.88}}
{"query_id": "synthetic-083", "query_text": "Write a Python function named `matrix_chain_multiplication` that finds the optimal way to multiply matrices. Language: Python. Function name: matrix_chain_multiplication", "reference_answer": "def matrix_chain_multiplication(dims: list[int]) -> int:\n    n = len(dims) - 1\n    if n <= 0:\n        return 0\n    \n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                cost = dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1]\n                dp[i][j] = min(dp[i][j], cost)\n    \n    return dp[0][n-1]", "assertions": "assert matrix_chain_multiplication([10, 30, 5, 60]) == 4500\nassert matrix_chain_multiplication([40, 20, 30, 10, 30]) == 26000\nassert matrix_chain_multiplication([10, 20, 30]) == 6000\nassert matrix_chain_multiplication([10]) == 0\nassert matrix_chain_multiplication([]) == 0", "metadata": {"language": "Python", "function_name": "matrix_chain_multiplication", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.9}}
{"query_id": "synthetic-084", "query_text": "Write a Python function named `avl_tree` that implements an AVL tree with insert and search. Language: Python. Function name: avl_tree", "reference_answer": "class AVLNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    def __init__(self):\n        self.root = None\n    \n    def _height(self, node):\n        return node.height if node else 0\n    \n    def _balance(self, node):\n        return self._height(node.left) - self._height(node.right) if node else 0\n    \n    def _rotate_right(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        x.height = 1 + max(self._height(x.left), self._height(x.right))\n        return x\n    \n    def _rotate_left(self, x):\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        x.height = 1 + max(self._height(x.left), self._height(x.right))\n        y.height = 1 + max(self._height(y.left), self._height(y.right))\n        return y\n    \n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n    \n    def _insert(self, node, key):\n        if not node:\n            return AVLNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        else:\n            node.right = self._insert(node.right, key)\n        \n        node.height = 1 + max(self._height(node.left), self._height(node.right))\n        balance = self._balance(node)\n        \n        if balance > 1 and key < node.left.key:\n            return self._rotate_right(node)\n        if balance < -1 and key > node.right.key:\n            return self._rotate_left(node)\n        if balance > 1 and key > node.left.key:\n            node.left = self._rotate_left(node.left)\n            return self._rotate_right(node)\n        if balance < -1 and key < node.right.key:\n            node.right = self._rotate_right(node.right)\n            return self._rotate_left(node)\n        return node\n    \n    def search(self, key):\n        return self._search(self.root, key)\n    \n    def _search(self, node, key):\n        if not node:\n            return False\n        if key == node.key:\n            return True\n        return self._search(node.left, key) if key < node.key else self._search(node.right, key)\n\ndef avl_tree() -> AVLTree:\n    return AVLTree()", "assertions": "tree = avl_tree()\nfor i in [10, 20, 30, 40, 50, 25]:\n    tree.insert(i)\nassert tree.search(30) == True\nassert tree.search(25) == True\nassert tree.search(100) == False\nassert tree.root.height <= 3", "metadata": {"language": "Python", "function_name": "avl_tree", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.92}}
{"query_id": "synthetic-085", "query_text": "Write a Python function named `max_flow` that implements the Ford-Fulkerson algorithm for maximum flow. Language: Python. Function name: max_flow", "reference_answer": "from collections import defaultdict, deque\n\ndef max_flow(graph: dict[int, dict[int, int]], source: int, sink: int) -> int:\n    def bfs(source, sink, parent):\n        visited = {source}\n        queue = deque([source])\n        while queue:\n            u = queue.popleft()\n            for v in residual[u]:\n                if v not in visited and residual[u][v] > 0:\n                    visited.add(v)\n                    parent[v] = u\n                    if v == sink:\n                        return True\n                    queue.append(v)\n        return False\n    \n    residual = defaultdict(lambda: defaultdict(int))\n    for u in graph:\n        for v, cap in graph[u].items():\n            residual[u][v] = cap\n    \n    max_flow_value = 0\n    parent = {}\n    \n    while bfs(source, sink, parent):\n        path_flow = float('inf')\n        s = sink\n        while s != source:\n            path_flow = min(path_flow, residual[parent[s]][s])\n            s = parent[s]\n        \n        max_flow_value += path_flow\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = parent[v]\n        parent = {}\n    \n    return max_flow_value", "assertions": "graph = {0: {1: 16, 2: 13}, 1: {2: 10, 3: 12}, 2: {1: 4, 4: 14}, 3: {2: 9, 5: 20}, 4: {3: 7, 5: 4}}\nassert max_flow(graph, 0, 5) == 23\nassert max_flow({0: {1: 10}, 1: {}}, 0, 1) == 10\nassert max_flow({0: {}, 1: {}}, 0, 1) == 0", "metadata": {"language": "Python", "function_name": "max_flow", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.95}}
{"query_id": "synthetic-086", "query_text": "Write a Python function named `regex_match` that implements regular expression matching with '.' and '*'. Language: Python. Function name: regex_match", "reference_answer": "def regex_match(text: str, pattern: str) -> bool:\n    m, n = len(text), len(pattern)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(2, n + 1):\n        if pattern[j - 1] == '*':\n            dp[0][j] = dp[0][j - 2]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if pattern[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2]\n                if pattern[j - 2] == '.' or pattern[j - 2] == text[i - 1]:\n                    dp[i][j] = dp[i][j] or dp[i - 1][j]\n            elif pattern[j - 1] == '.' or pattern[j - 1] == text[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n    \n    return dp[m][n]", "assertions": "assert regex_match('aa', 'a') == False\nassert regex_match('aa', 'a*') == True\nassert regex_match('ab', '.*') == True\nassert regex_match('aab', 'c*a*b') == True\nassert regex_match('mississippi', 'mis*is*p*.') == False\nassert regex_match('', '.*') == True", "metadata": {"language": "Python", "function_name": "regex_match", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.92}}
{"query_id": "synthetic-087", "query_text": "Write a Python function named `skip_list` that implements a skip list data structure. Language: Python. Function name: skip_list", "reference_answer": "import random\n\nclass SkipNode:\n    def __init__(self, key, level):\n        self.key = key\n        self.forward = [None] * (level + 1)\n\nclass SkipList:\n    def __init__(self, max_level=16, p=0.5):\n        self.max_level = max_level\n        self.p = p\n        self.level = 0\n        self.header = SkipNode(-float('inf'), max_level)\n    \n    def random_level(self):\n        level = 0\n        while random.random() < self.p and level < self.max_level:\n            level += 1\n        return level\n    \n    def insert(self, key):\n        update = [None] * (self.max_level + 1)\n        current = self.header\n        \n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].key < key:\n                current = current.forward[i]\n            update[i] = current\n        \n        level = self.random_level()\n        if level > self.level:\n            for i in range(self.level + 1, level + 1):\n                update[i] = self.header\n            self.level = level\n        \n        new_node = SkipNode(key, level)\n        for i in range(level + 1):\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n    \n    def search(self, key):\n        current = self.header\n        for i in range(self.level, -1, -1):\n            while current.forward[i] and current.forward[i].key < key:\n                current = current.forward[i]\n        current = current.forward[0]\n        return current and current.key == key\n\ndef skip_list() -> SkipList:\n    return SkipList()", "assertions": "sl = skip_list()\nfor i in [3, 6, 7, 9, 12, 19, 17, 26, 21, 25]:\n    sl.insert(i)\nassert sl.search(19) == True\nassert sl.search(6) == True\nassert sl.search(100) == False\nassert sl.search(1) == False", "metadata": {"language": "Python", "function_name": "skip_list", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.9}}
{"query_id": "synthetic-088", "query_text": "Write a Python function named `edit_distance_operations` that returns the actual operations needed for edit distance. Language: Python. Function name: edit_distance_operations", "reference_answer": "def edit_distance_operations(s1: str, s2: str) -> list[str]:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    operations = []\n    i, j = m, n\n    while i > 0 or j > 0:\n        if i > 0 and j > 0 and s1[i-1] == s2[j-1]:\n            i -= 1\n            j -= 1\n        elif i > 0 and j > 0 and dp[i][j] == dp[i-1][j-1] + 1:\n            operations.append(f\"Replace '{s1[i-1]}' with '{s2[j-1]}' at position {i-1}\")\n            i -= 1\n            j -= 1\n        elif j > 0 and dp[i][j] == dp[i][j-1] + 1:\n            operations.append(f\"Insert '{s2[j-1]}' at position {i}\")\n            j -= 1\n        else:\n            operations.append(f\"Delete '{s1[i-1]}' at position {i-1}\")\n            i -= 1\n    \n    return operations[::-1]", "assertions": "ops = edit_distance_operations('kitten', 'sitting')\nassert len(ops) == 3\nops2 = edit_distance_operations('', 'abc')\nassert len(ops2) == 3\nops3 = edit_distance_operations('same', 'same')\nassert len(ops3) == 0\nops4 = edit_distance_operations('a', 'b')\nassert len(ops4) == 1", "metadata": {"language": "Python", "function_name": "edit_distance_operations", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-089", "query_text": "Write a TypeScript function named `asyncQueue` that implements an async task queue with concurrency control. Language: TypeScript. Function name: asyncQueue", "reference_answer": "class AsyncQueue<T> {\n    private queue: (() => Promise<T>)[] = [];\n    private running: number = 0;\n    private concurrency: number;\n    private results: T[] = [];\n    private resolveAll: ((results: T[]) => void) | null = null;\n    \n    constructor(concurrency: number = 1) {\n        this.concurrency = concurrency;\n    }\n    \n    push(task: () => Promise<T>): void {\n        this.queue.push(task);\n        this.runNext();\n    }\n    \n    private async runNext(): Promise<void> {\n        if (this.running >= this.concurrency || this.queue.length === 0) {\n            return;\n        }\n        \n        this.running++;\n        const task = this.queue.shift()!;\n        \n        try {\n            const result = await task();\n            this.results.push(result);\n        } finally {\n            this.running--;\n            this.runNext();\n            \n            if (this.running === 0 && this.queue.length === 0 && this.resolveAll) {\n                this.resolveAll(this.results);\n            }\n        }\n    }\n    \n    async drain(): Promise<T[]> {\n        if (this.running === 0 && this.queue.length === 0) {\n            return this.results;\n        }\n        \n        return new Promise(resolve => {\n            this.resolveAll = resolve;\n        });\n    }\n}\n\nfunction asyncQueue<T>(concurrency: number = 1): AsyncQueue<T> {\n    return new AsyncQueue<T>(concurrency);\n}", "assertions": "const queue = asyncQueue<number>(2);\nconst delay = (ms: number, val: number) => new Promise<number>(r => setTimeout(() => r(val), ms));\nqueue.push(() => delay(50, 1));\nqueue.push(() => delay(50, 2));\nqueue.push(() => delay(50, 3));\nqueue.push(() => delay(50, 4));\nqueue.drain().then(results => {\n    if (results.length !== 4) throw new Error('Failed');\n    if (!results.includes(1) || !results.includes(4)) throw new Error('Failed');\n});", "metadata": {"language": "TypeScript", "function_name": "asyncQueue", "difficulty": "very_advanced", "category": "concurrency", "complexity": 0.88}}
{"query_id": "synthetic-090", "query_text": "Write a TypeScript function named `PubSub` that implements a publish-subscribe pattern. Language: TypeScript. Function name: PubSub", "reference_answer": "type Callback<T> = (data: T) => void;\n\nclass PubSub<T = any> {\n    private subscribers: Map<string, Set<Callback<T>>> = new Map();\n    \n    subscribe(event: string, callback: Callback<T>): () => void {\n        if (!this.subscribers.has(event)) {\n            this.subscribers.set(event, new Set());\n        }\n        this.subscribers.get(event)!.add(callback);\n        \n        return () => {\n            this.subscribers.get(event)?.delete(callback);\n        };\n    }\n    \n    publish(event: string, data: T): void {\n        const callbacks = this.subscribers.get(event);\n        if (callbacks) {\n            callbacks.forEach(callback => callback(data));\n        }\n    }\n    \n    once(event: string, callback: Callback<T>): () => void {\n        const wrapper: Callback<T> = (data) => {\n            callback(data);\n            unsubscribe();\n        };\n        const unsubscribe = this.subscribe(event, wrapper);\n        return unsubscribe;\n    }\n    \n    clear(event?: string): void {\n        if (event) {\n            this.subscribers.delete(event);\n        } else {\n            this.subscribers.clear();\n        }\n    }\n}", "assertions": "const pubsub = new PubSub<number>();\nlet value = 0;\nconst unsub = pubsub.subscribe('test', (n) => value += n);\npubsub.publish('test', 5);\nif (value !== 5) throw new Error('Failed');\npubsub.publish('test', 3);\nif (value !== 8) throw new Error('Failed');\nunsub();\npubsub.publish('test', 10);\nif (value !== 8) throw new Error('Failed');\nlet onceValue = 0;\npubsub.once('once', (n) => onceValue = n);\npubsub.publish('once', 42);\npubsub.publish('once', 100);\nif (onceValue !== 42) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "PubSub", "difficulty": "advanced", "category": "design_patterns", "complexity": 0.75}}
{"query_id": "synthetic-091", "query_text": "Write a TypeScript function named `RateLimiter` that implements a token bucket rate limiter. Language: TypeScript. Function name: RateLimiter", "reference_answer": "class RateLimiter {\n    private tokens: number;\n    private maxTokens: number;\n    private refillRate: number;\n    private lastRefill: number;\n    \n    constructor(maxTokens: number, refillRate: number) {\n        this.tokens = maxTokens;\n        this.maxTokens = maxTokens;\n        this.refillRate = refillRate;\n        this.lastRefill = Date.now();\n    }\n    \n    private refill(): void {\n        const now = Date.now();\n        const elapsed = (now - this.lastRefill) / 1000;\n        const tokensToAdd = elapsed * this.refillRate;\n        this.tokens = Math.min(this.maxTokens, this.tokens + tokensToAdd);\n        this.lastRefill = now;\n    }\n    \n    tryAcquire(tokens: number = 1): boolean {\n        this.refill();\n        if (this.tokens >= tokens) {\n            this.tokens -= tokens;\n            return true;\n        }\n        return false;\n    }\n    \n    async acquire(tokens: number = 1): Promise<void> {\n        while (!this.tryAcquire(tokens)) {\n            await new Promise(resolve => setTimeout(resolve, 100));\n        }\n    }\n    \n    getAvailableTokens(): number {\n        this.refill();\n        return this.tokens;\n    }\n}", "assertions": "const limiter = new RateLimiter(5, 1);\nif (!limiter.tryAcquire()) throw new Error('Failed - should have tokens');\nif (!limiter.tryAcquire()) throw new Error('Failed');\nif (!limiter.tryAcquire()) throw new Error('Failed');\nif (!limiter.tryAcquire()) throw new Error('Failed');\nif (!limiter.tryAcquire()) throw new Error('Failed');\nif (limiter.tryAcquire()) throw new Error('Failed - should be empty');\nsetTimeout(() => {\n    if (!limiter.tryAcquire()) throw new Error('Failed - should have refilled');\n}, 1100);", "metadata": {"language": "TypeScript", "function_name": "RateLimiter", "difficulty": "advanced", "category": "concurrency", "complexity": 0.78}}
{"query_id": "synthetic-092", "query_text": "Write a TypeScript function named `SkipList` that implements a skip list. Language: TypeScript. Function name: SkipList", "reference_answer": "class SkipListNode<T> {\n    value: T;\n    forward: (SkipListNode<T> | null)[];\n    \n    constructor(value: T, level: number) {\n        this.value = value;\n        this.forward = new Array(level + 1).fill(null);\n    }\n}\n\nclass SkipList<T> {\n    private maxLevel: number;\n    private p: number;\n    private level: number = 0;\n    private header: SkipListNode<T>;\n    private compare: (a: T, b: T) => number;\n    \n    constructor(maxLevel: number = 16, p: number = 0.5, compare?: (a: T, b: T) => number) {\n        this.maxLevel = maxLevel;\n        this.p = p;\n        this.header = new SkipListNode<T>(null as any, maxLevel);\n        this.compare = compare || ((a, b) => (a as any) - (b as any));\n    }\n    \n    private randomLevel(): number {\n        let level = 0;\n        while (Math.random() < this.p && level < this.maxLevel) {\n            level++;\n        }\n        return level;\n    }\n    \n    insert(value: T): void {\n        const update: (SkipListNode<T> | null)[] = new Array(this.maxLevel + 1).fill(null);\n        let current = this.header;\n        \n        for (let i = this.level; i >= 0; i--) {\n            while (current.forward[i] && this.compare(current.forward[i]!.value, value) < 0) {\n                current = current.forward[i]!;\n            }\n            update[i] = current;\n        }\n        \n        const level = this.randomLevel();\n        if (level > this.level) {\n            for (let i = this.level + 1; i <= level; i++) {\n                update[i] = this.header;\n            }\n            this.level = level;\n        }\n        \n        const newNode = new SkipListNode(value, level);\n        for (let i = 0; i <= level; i++) {\n            newNode.forward[i] = update[i]!.forward[i];\n            update[i]!.forward[i] = newNode;\n        }\n    }\n    \n    search(value: T): boolean {\n        let current = this.header;\n        for (let i = this.level; i >= 0; i--) {\n            while (current.forward[i] && this.compare(current.forward[i]!.value, value) < 0) {\n                current = current.forward[i]!;\n            }\n        }\n        current = current.forward[0]!;\n        return current !== null && this.compare(current.value, value) === 0;\n    }\n}", "assertions": "const skipList = new SkipList<number>();\nskipList.insert(3);\nskipList.insert(6);\nskipList.insert(7);\nskipList.insert(9);\nskipList.insert(12);\nif (!skipList.search(6)) throw new Error('Failed');\nif (!skipList.search(9)) throw new Error('Failed');\nif (skipList.search(100)) throw new Error('Failed');\nif (skipList.search(1)) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "SkipList", "difficulty": "very_advanced", "category": "data_structures", "complexity": 0.9}}
{"query_id": "synthetic-093", "query_text": "Write a TypeScript function named `UnionFind` that implements a disjoint set union. Language: TypeScript. Function name: UnionFind", "reference_answer": "class UnionFind {\n    private parent: number[];\n    private rank: number[];\n    private _count: number;\n    \n    constructor(n: number) {\n        this.parent = Array.from({ length: n }, (_, i) => i);\n        this.rank = new Array(n).fill(0);\n        this._count = n;\n    }\n    \n    find(x: number): number {\n        if (this.parent[x] !== x) {\n            this.parent[x] = this.find(this.parent[x]);\n        }\n        return this.parent[x];\n    }\n    \n    union(x: number, y: number): boolean {\n        const px = this.find(x);\n        const py = this.find(y);\n        \n        if (px === py) return false;\n        \n        if (this.rank[px] < this.rank[py]) {\n            this.parent[px] = py;\n        } else if (this.rank[px] > this.rank[py]) {\n            this.parent[py] = px;\n        } else {\n            this.parent[py] = px;\n            this.rank[px]++;\n        }\n        this._count--;\n        return true;\n    }\n    \n    connected(x: number, y: number): boolean {\n        return this.find(x) === this.find(y);\n    }\n    \n    get count(): number {\n        return this._count;\n    }\n}", "assertions": "const uf = new UnionFind(5);\nif (uf.connected(0, 1)) throw new Error('Failed');\nuf.union(0, 1);\nif (!uf.connected(0, 1)) throw new Error('Failed');\nuf.union(2, 3);\nuf.union(1, 3);\nif (!uf.connected(0, 2)) throw new Error('Failed');\nif (uf.count !== 2) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "UnionFind", "difficulty": "advanced", "category": "data_structures", "complexity": 0.78}}
{"query_id": "synthetic-094", "query_text": "Write a TypeScript function named `CircularBuffer` that implements a circular buffer. Language: TypeScript. Function name: CircularBuffer", "reference_answer": "class CircularBuffer<T> {\n    private buffer: (T | undefined)[];\n    private capacity: number;\n    private head: number = 0;\n    private tail: number = 0;\n    private _size: number = 0;\n    \n    constructor(capacity: number) {\n        this.capacity = capacity;\n        this.buffer = new Array(capacity);\n    }\n    \n    push(item: T): boolean {\n        if (this._size === this.capacity) {\n            return false;\n        }\n        this.buffer[this.tail] = item;\n        this.tail = (this.tail + 1) % this.capacity;\n        this._size++;\n        return true;\n    }\n    \n    pop(): T | undefined {\n        if (this._size === 0) {\n            return undefined;\n        }\n        const item = this.buffer[this.head];\n        this.buffer[this.head] = undefined;\n        this.head = (this.head + 1) % this.capacity;\n        this._size--;\n        return item;\n    }\n    \n    peek(): T | undefined {\n        return this._size > 0 ? this.buffer[this.head] : undefined;\n    }\n    \n    get size(): number {\n        return this._size;\n    }\n    \n    get isFull(): boolean {\n        return this._size === this.capacity;\n    }\n    \n    get isEmpty(): boolean {\n        return this._size === 0;\n    }\n    \n    toArray(): T[] {\n        const result: T[] = [];\n        for (let i = 0; i < this._size; i++) {\n            result.push(this.buffer[(this.head + i) % this.capacity]!);\n        }\n        return result;\n    }\n}", "assertions": "const buffer = new CircularBuffer<number>(3);\nbuffer.push(1);\nbuffer.push(2);\nbuffer.push(3);\nif (buffer.push(4)) throw new Error('Failed - should be full');\nif (buffer.pop() !== 1) throw new Error('Failed');\nbuffer.push(4);\nif (JSON.stringify(buffer.toArray()) !== JSON.stringify([2, 3, 4])) throw new Error('Failed');\nif (buffer.size !== 3) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "CircularBuffer", "difficulty": "medium", "category": "data_structures", "complexity": 0.6}}
{"query_id": "synthetic-095", "query_text": "Write a TypeScript function named `Deque` that implements a double-ended queue. Language: TypeScript. Function name: Deque", "reference_answer": "class Deque<T> {\n    private items: T[] = [];\n    \n    pushFront(item: T): void {\n        this.items.unshift(item);\n    }\n    \n    pushBack(item: T): void {\n        this.items.push(item);\n    }\n    \n    popFront(): T | undefined {\n        return this.items.shift();\n    }\n    \n    popBack(): T | undefined {\n        return this.items.pop();\n    }\n    \n    peekFront(): T | undefined {\n        return this.items[0];\n    }\n    \n    peekBack(): T | undefined {\n        return this.items[this.items.length - 1];\n    }\n    \n    get size(): number {\n        return this.items.length;\n    }\n    \n    get isEmpty(): boolean {\n        return this.items.length === 0;\n    }\n    \n    toArray(): T[] {\n        return [...this.items];\n    }\n}", "assertions": "const deque = new Deque<number>();\ndeque.pushBack(1);\ndeque.pushBack(2);\ndeque.pushFront(0);\nif (JSON.stringify(deque.toArray()) !== JSON.stringify([0, 1, 2])) throw new Error('Failed');\nif (deque.popFront() !== 0) throw new Error('Failed');\nif (deque.popBack() !== 2) throw new Error('Failed');\nif (deque.size !== 1) throw new Error('Failed');\nif (deque.peekFront() !== 1) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "Deque", "difficulty": "medium", "category": "data_structures", "complexity": 0.5}}
{"query_id": "synthetic-096", "query_text": "Write a TypeScript function named `MaxStack` that implements a stack with getMax in O(1). Language: TypeScript. Function name: MaxStack", "reference_answer": "class MaxStack<T> {\n    private stack: T[] = [];\n    private maxStack: T[] = [];\n    private compare: (a: T, b: T) => number;\n    \n    constructor(compare?: (a: T, b: T) => number) {\n        this.compare = compare || ((a, b) => (a as any) - (b as any));\n    }\n    \n    push(item: T): void {\n        this.stack.push(item);\n        if (this.maxStack.length === 0 || this.compare(item, this.maxStack[this.maxStack.length - 1]) >= 0) {\n            this.maxStack.push(item);\n        }\n    }\n    \n    pop(): T | undefined {\n        const item = this.stack.pop();\n        if (item !== undefined && this.compare(item, this.maxStack[this.maxStack.length - 1]) === 0) {\n            this.maxStack.pop();\n        }\n        return item;\n    }\n    \n    peek(): T | undefined {\n        return this.stack[this.stack.length - 1];\n    }\n    \n    getMax(): T | undefined {\n        return this.maxStack[this.maxStack.length - 1];\n    }\n    \n    get size(): number {\n        return this.stack.length;\n    }\n    \n    get isEmpty(): boolean {\n        return this.stack.length === 0;\n    }\n}", "assertions": "const maxStack = new MaxStack<number>();\nmaxStack.push(5);\nmaxStack.push(1);\nmaxStack.push(5);\nif (maxStack.getMax() !== 5) throw new Error('Failed');\nmaxStack.pop();\nif (maxStack.getMax() !== 5) throw new Error('Failed');\nmaxStack.pop();\nif (maxStack.getMax() !== 5) throw new Error('Failed');\nmaxStack.pop();\nif (maxStack.getMax() !== undefined) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "MaxStack", "difficulty": "medium", "category": "data_structures", "complexity": 0.6}}
{"query_id": "synthetic-097", "query_text": "Write a TypeScript function named `BinaryTree` that implements a binary search tree with insert, search, and inorder traversal. Language: TypeScript. Function name: BinaryTree", "reference_answer": "class TreeNode<T> {\n    value: T;\n    left: TreeNode<T> | null = null;\n    right: TreeNode<T> | null = null;\n    constructor(value: T) { this.value = value; }\n}\n\nclass BinaryTree<T> {\n    root: TreeNode<T> | null = null;\n    private compare: (a: T, b: T) => number;\n    \n    constructor(compare?: (a: T, b: T) => number) {\n        this.compare = compare || ((a, b) => (a as any) - (b as any));\n    }\n    \n    insert(value: T): void {\n        this.root = this.insertNode(this.root, value);\n    }\n    \n    private insertNode(node: TreeNode<T> | null, value: T): TreeNode<T> {\n        if (!node) return new TreeNode(value);\n        if (this.compare(value, node.value) < 0) {\n            node.left = this.insertNode(node.left, value);\n        } else {\n            node.right = this.insertNode(node.right, value);\n        }\n        return node;\n    }\n    \n    search(value: T): boolean {\n        return this.searchNode(this.root, value);\n    }\n    \n    private searchNode(node: TreeNode<T> | null, value: T): boolean {\n        if (!node) return false;\n        const cmp = this.compare(value, node.value);\n        if (cmp === 0) return true;\n        return cmp < 0 ? this.searchNode(node.left, value) : this.searchNode(node.right, value);\n    }\n    \n    inorder(): T[] {\n        const result: T[] = [];\n        this.inorderTraverse(this.root, result);\n        return result;\n    }\n    \n    private inorderTraverse(node: TreeNode<T> | null, result: T[]): void {\n        if (node) {\n            this.inorderTraverse(node.left, result);\n            result.push(node.value);\n            this.inorderTraverse(node.right, result);\n        }\n    }\n}", "assertions": "const tree = new BinaryTree<number>();\ntree.insert(5);\ntree.insert(3);\ntree.insert(7);\ntree.insert(1);\ntree.insert(9);\nif (!tree.search(7)) throw new Error('Failed');\nif (tree.search(100)) throw new Error('Failed');\nif (JSON.stringify(tree.inorder()) !== JSON.stringify([1, 3, 5, 7, 9])) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "BinaryTree", "difficulty": "advanced", "category": "data_structures", "complexity": 0.72}}
{"query_id": "synthetic-098", "query_text": "Write a TypeScript function named `knapsack` that solves the 0/1 knapsack problem. Language: TypeScript. Function name: knapsack", "reference_answer": "function knapsack(weights: number[], values: number[], capacity: number): number {\n    const n = weights.length;\n    const dp: number[][] = Array.from({ length: n + 1 }, () => new Array(capacity + 1).fill(0));\n    \n    for (let i = 1; i <= n; i++) {\n        for (let w = 0; w <= capacity; w++) {\n            if (weights[i - 1] <= w) {\n                dp[i][w] = Math.max(\n                    dp[i - 1][w],\n                    dp[i - 1][w - weights[i - 1]] + values[i - 1]\n                );\n            } else {\n                dp[i][w] = dp[i - 1][w];\n            }\n        }\n    }\n    \n    return dp[n][capacity];\n}", "assertions": "if (knapsack([1, 2, 3], [6, 10, 12], 5) !== 22) throw new Error('Failed');\nif (knapsack([2, 3, 4, 5], [3, 4, 5, 6], 5) !== 7) throw new Error('Failed');\nif (knapsack([], [], 10) !== 0) throw new Error('Failed');\nif (knapsack([10], [100], 5) !== 0) throw new Error('Failed');\nif (knapsack([1, 1, 1], [10, 20, 30], 2) !== 50) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "knapsack", "difficulty": "very_advanced", "category": "algorithms", "complexity": 0.85}}
{"query_id": "synthetic-099", "query_text": "Write a TypeScript function named `longestIncreasingSubsequence` that finds the LIS length. Language: TypeScript. Function name: longestIncreasingSubsequence", "reference_answer": "function longestIncreasingSubsequence(nums: number[]): number {\n    if (nums.length === 0) return 0;\n    \n    const tails: number[] = [];\n    \n    for (const num of nums) {\n        let left = 0;\n        let right = tails.length;\n        \n        while (left < right) {\n            const mid = Math.floor((left + right) / 2);\n            if (tails[mid] < num) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        if (left === tails.length) {\n            tails.push(num);\n        } else {\n            tails[left] = num;\n        }\n    }\n    \n    return tails.length;\n}", "assertions": "if (longestIncreasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18]) !== 4) throw new Error('Failed');\nif (longestIncreasingSubsequence([0, 1, 0, 3, 2, 3]) !== 4) throw new Error('Failed');\nif (longestIncreasingSubsequence([7, 7, 7, 7, 7]) !== 1) throw new Error('Failed');\nif (longestIncreasingSubsequence([]) !== 0) throw new Error('Failed');\nif (longestIncreasingSubsequence([1, 2, 3, 4, 5]) !== 5) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "longestIncreasingSubsequence", "difficulty": "advanced", "category": "algorithms", "complexity": 0.78}}
{"query_id": "synthetic-100", "query_text": "Write a TypeScript function named `coinChange` that finds the minimum coins for a target amount. Language: TypeScript. Function name: coinChange", "reference_answer": "function coinChange(coins: number[], amount: number): number {\n    const dp: number[] = new Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n    \n    for (const coin of coins) {\n        for (let x = coin; x <= amount; x++) {\n            dp[x] = Math.min(dp[x], dp[x - coin] + 1);\n        }\n    }\n    \n    return dp[amount] === Infinity ? -1 : dp[amount];\n}", "assertions": "if (coinChange([1, 2, 5], 11) !== 3) throw new Error('Failed');\nif (coinChange([2], 3) !== -1) throw new Error('Failed');\nif (coinChange([1], 0) !== 0) throw new Error('Failed');\nif (coinChange([1, 2, 5], 100) !== 20) throw new Error('Failed');\nif (coinChange([186, 419, 83, 408], 6249) !== 20) throw new Error('Failed');", "metadata": {"language": "TypeScript", "function_name": "coinChange", "difficulty": "advanced", "category": "algorithms", "complexity": 0.75}}
